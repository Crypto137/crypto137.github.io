<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://crypto137.github.io/MHServerEmu/feed.xml" rel="self" type="application/atom+xml" /><link href="https://crypto137.github.io/MHServerEmu/" rel="alternate" type="text/html" /><updated>2024-03-10T18:17:55+03:00</updated><id>https://crypto137.github.io/MHServerEmu/feed.xml</id><title type="html">MHServerEmu Blog</title><subtitle>A volunteer-driven research project aimed at reverse engineering the technology developed by Gazillion Entertainment.</subtitle><entry><title type="html">MHServerEmu Progress Report: February 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: February 2024" /><published>2024-02-28T15:00:00+03:00</published><updated>2024-02-28T15:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html"><![CDATA[<p><img src="/MHServerEmu/assets/blog/progress-report/2024-02/header.jpg" alt="MHServerEmu Progress Report - February 2024" /></p>

<p>February may be the shortest month, but we are definitely not short on progress this time.</p>

<h2 id="the-merging-is-complete">The Merging is Complete</h2>

<p>The biggest news of the month is without doubt that the changes that AlexBond and Kawaikikinou have been implementing and testing on the experimental branch over the past few months have been merged with the master branch. The highlights of these changes include:</p>

<ul>
  <li>
    <p>Fully-featured implementation of DRAG (Dynamic Random Area Generator), which makes all regions not only explorable, but also different between visits. The current system refreshes regions every five minutes as long as there are no players in them, but this is something we will continue to iterate on.</p>
  </li>
  <li>
    <p>Early implementation of the population system, which handles the spawning of entities, including enemies, NPCs, and interactable objects, across the entire game. There is still a lot of work to be done here, including dynamic enemy spawning, but the regions now feel a lot less lonely.</p>
  </li>
  <li>
    <p>Early experiment that allows to deal damage to enemies. This is more of a quick hack than a real implementation, but it does make exploration way more fun.</p>
  </li>
</ul>

<p>This is an important milestone that brings us closer towards our first official “release”, 0.1.0, that we currently expect to happen in March. In addition to what you can see in the current nightly build, it is also going to have some more additional polish, including a streamlined setup process that would not require you to manually configure a web server.</p>

<p>Once that is out, the current plan is to shift our focus back towards fundamentals, including overhauling our entity management and replication systems.</p>

<p>With the important news out of the way, let us take a closer look at some of the more technical happenings of February.</p>

<h2 id="a-song-of-bits-and-bytes">A Song of Bits and Bytes</h2>

<p>What I have personally spent the most of my time working on this month is finally implementing one of the core systems of Marvel Heroes - properties.</p>

<p>All dynamic objects in the game are called <em>entities</em>. This includes player characters (internally called <em>avatars</em>), NPCs, enemies, projectiles, interactable objects, items, and so on. Entities are essentially collections of properties that define their state: what level they are, how much health they have, whether they are visible or not, and so on. Because of their integral role in pretty much all gameplay interactions, everything related to properties is very highly optimized, which makes it very difficult to untangle. If you include all the research and the foundational systems that had to be done beforehand, you could say that implementing properties actually took six months.</p>

<p>A property is a pair of two 64-bit values: a <em>PropertyId</em> and a <em>PropertyValue</em>. As you can probably guess from their names, one identifies a property, and the other contains its actual value.</p>

<p>The simplest form of a PropertyId looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png" alt="Property Id - Combat Level" /></a></p>

<p>The game initializes the so-called property info table and enumerates all property types during startup. Most of the properties are defined in code and are sorted alphabetically by their name. However, there are some additional data-only properties that are sorted by their blueprint id and appended at the end of the enumeration. Overall in version 1.52.0.1700 there are 1030 properties, of which 29 are data-only.</p>

<p>11 of the 64 bits in a PropertyId are allocated to the enum value, so the maximum possible number of property types is <code class="language-plaintext highlighter-rouge">1 &lt;&lt; 11 = 2048</code>. The remaining 53 bits are distributed amongst 0-4 <em>parameters</em>. For example, this PropertyId for a <code class="language-plaintext highlighter-rouge">Waypoint</code> property contains a single parameter that specifies which waypoint this property unlocks:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png" alt="Property Id - Waypoint" /></a></p>

<p>There are three supported types of parameters: integers, prototype ids, and asset ids. However, there is a problem: prototype and asset ids are actually 64-bit hashes, so how are we supposed to fit multiple 64-bit values in the 53 bits we have for parameters? This is where trickery comes in.</p>

<p>During game database initialization the game sorts all 64-bit prototype ids it contains, and then divides them into two types of buckets: by C++ class they bind to, and by Calligraphy blueprint they use. So you end up with arrays of sorted ids for each prototype class and blueprint. And by knowing which array to look in and where, you can retrieve the full id. A similar process happens for assets, so by knowing the asset type and its index you can get the id.</p>

<p>The game databases server-side and client-side are in sync, and the game makes heavy use of this in network communication to reduce the amount of data that needs to be sent back and forth. Instead of sending a number like <code class="language-plaintext highlighter-rouge">421791326977791218</code>, which is the prototype id of the playable Iron Man avatar, you can send just <code class="language-plaintext highlighter-rouge">3</code>, which is the index in the array of prototypes that use the avatar blueprint.</p>

<p>Property types have corresponding prototypes that contain additional metadata, including the types and subtypes (prototype blueprint or asset type) of all parameters. During property info table initialization the game processes all property prototypes and allocates the 53-bit param budget to defined parameters. First, it allocates the amount of bits needed to store the maximum index value for all prototype and asset parameters, and then it splits the remaining bits amongst any integer parameters, up to 31 bits (so only positive integers with a value up of up to <code class="language-plaintext highlighter-rouge">2147483647</code>). For example, here is a PropertyId for an <code class="language-plaintext highlighter-rouge">AvatarLibraryLevel</code> property that defines the displayed level in the hero roster for Iron Man:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png" alt="Property Id - Avatar Library Level" /></a></p>

<p>7 bits are allocated to hold the maximum value of the avatar prototype index, and then 31 of the remaining 46 bits are taken by an integer value. 15 bits in this case are left unused.</p>

<p>Finally, here is an example of a <code class="language-plaintext highlighter-rouge">Proc</code> property that has four parameters:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png" alt="Property Id - Proc" /></a></p>

<p>Param0 is the asset value that defines the proc trigger type, Param1 is the power prototype of the power triggered by this proc, and the remaining params are additional integer values. First <code class="language-plaintext highlighter-rouge">7 + 15 = 22</code> bits are allocated to asset and prototype params, and then the remaining bits are split evenly between integer params, <code class="language-plaintext highlighter-rouge">31 / 2 = 15</code> bits per parameter.</p>

<p>This is not where trickery ends however. Marvel Heroes makes heavy use of the encoding format developed by Google for their <a href="https://protobuf.dev/programming-guides/encoding/">Protocol Buffers</a> technology, and the way it works is that values can take anywhere from one to ten bytes depending on how high they are, with higher values taking more bytes. The number you end up with for a PropertyId often has a lot of zeroes at the end, so you waste a lot of network traffic if you send it as is. To circumvent this, the order of bytes is reversed before serialization: so <code class="language-plaintext highlighter-rouge">0x18E0000000000000</code> from the first example becomes <code class="language-plaintext highlighter-rouge">0x00000000000018E0</code>, or just <code class="language-plaintext highlighter-rouge">0x18E0</code>. However, there is an annoying inconsistency: when serializing a single property instead of a whole property collection, the game reverses the order of individual <em>bits</em> rather than <em>bytes</em>. So <code class="language-plaintext highlighter-rouge">0001 1000 1110 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code> becomes <code class="language-plaintext highlighter-rouge">0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 0001 1000</code>, or just <code class="language-plaintext highlighter-rouge">111 0001 1000</code>, which is equivalent to a hex value of <code class="language-plaintext highlighter-rouge">0x718</code>.</p>

<p>And then we have PropertyValue. Thankfully, this one is not nearly as complicated. There are eleven data types that can be stored in a property value, most of them are simple 64-bit integer or 32-bit floating point values. But there are two funny ones: <em>Curve</em> and <em>Int21Vector3</em>.</p>

<p>With a curve property rather than assigning it a value, you assign it an index property and a curve. And then the value of the curve property gets automatically updated from the curve, using the value of the index property as the curve index. For example, all heroes have a <code class="language-plaintext highlighter-rouge">HealthBase</code> property that uses <code class="language-plaintext highlighter-rouge">CombatLevel</code> as its index. So the value of <code class="language-plaintext highlighter-rouge">HealthBase</code> automatically changes whenever <code class="language-plaintext highlighter-rouge">CombatLevel</code> is updated (i.e. you level up). The default curve used by playable characters, <code class="language-plaintext highlighter-rouge">CharacterHealthMAX.curve</code>, actually goes all the way to level 101 and looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png" alt="HealthBase Curve Property" /></a></p>

<p>With an Int21Vector3 we have a Vector3 to store, which consists of three 32-bit floating point values (X, Y, and Z coordinates), but we only have 64 bits. In this case the compression is lossy: individual values are rounded and cast to integers. The 64 bits are split into <code class="language-plaintext highlighter-rouge">64 / 3 = 21</code> bits per value. The values remain signed, so we end up with 20 magnitude bits + 1 sign bit, which gives us a range from <code class="language-plaintext highlighter-rouge">-1048576</code> to <code class="language-plaintext highlighter-rouge">1048575</code> for each coordinate.</p>

<p>One challenge with implementing PropertyValue has been adapting the original C++ API to C#. Property collections in the client use templates for property getters and setters that look something along these lines:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="o">=</span> <span class="n">properties</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>
</code></pre></div></div>

<p>For the C# API we ended up with a combination of indexers and implicit casting that looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="p">=</span> <span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">];</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">]</span> <span class="p">=</span> <span class="m">60</span><span class="p">;</span>
</code></pre></div></div>

<p>The final piece of the property puzzle is aggregation. A property collection can be attached as a child to another property collection, and the values of the parent are going to be aggregated with the child. Each property collection actually contains two lists of properties: one for base values held in this particular collection, and one for values aggregated with all of its children. This system is what enables, for example, equipping and unequipping items that affect your character’s stats, or applying buffs and debuffs (internally called <em>conditions</em>). There is not too much interesting to say about aggregation, it is just a lot of mundane work to make sure that all values are updated properly.</p>

<p>And with all of that we now have a working property system. We have already started making use of it to replace some of the hardcoded data from captured packets we had to rely on, as well as doing little experiments, like the recently implemented damage dealing hack. One remaining aspect that we are going to have to tackle on in the future is the eval system, which allows properties to be used as variables in scripted formulas (for example, for calculating maximum health taking into account all bonuses and penalties). But that is going to be a whole massive endeavor of its own.</p>

<h2 id="an-interesting-development">An Interesting Development</h2>

<p>As Alex was implemeting region generation and entity spawning, an issue immerged. Turns out loading an entire region worth of environments and entities puts a significant amount of strain on the client, especially if you are running on lower-end hardware. So we needed to come up with a solution, at least a temporary one.</p>

<p>The way this is supposed to be handled is through a process called replication. The server is the “dungeon master”, it is aware of everything happening to everyone, but each client should only be aware of what is relevant to them. Not only does it reduce the amount of data that needs to be exchanged and improve performance, it also helps prevent some forms of cheating, such as map hacking. If the client literally has no information on what lies ahead, it is much harder to peek beyond what should be observable (<del>there is actually a potential way around this, but I am not going to disclose it here</del>).</p>

<p>Internally the game calls the data that needs to be sent to clients their <em>interest</em>, with each client having their own <em>areas of interest</em> (AOI). There are at least five area of interest channels that we are currently aware of:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToProximity</code>: the client needs to know what is happening around its physical location in the game world.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToParty</code>: the client needs to be informed of its party members even if they are not in proximity.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>: some entities should be replicated only to their owners. For example, this is not Diablo II, so only you should be able to see the loot you get from defeating enemies.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToDiscovered</code>: when the client finds an NPC or a transition to another region, the client should still be somewhat aware of the entity, even if they are no longer in proximity with one another (a bit like fog of war in RTS games).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToTrader</code>: when trading items the clients should be aware of what is being traded.</p>
  </li>
</ul>

<p>These channels can be mixed together, like <code class="language-plaintext highlighter-rouge">ReplicateToProximity</code> and <code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>, so the client is aware only of the loot that belongs to it and is in proximity. We are still investigating how this system works, so some of these examples may not be completely accurate.</p>

<p>In the current version of MHServerEmu we now have an early implementation of proximity-based area of interest. This allows us to send cell and entity data as you move in the game world, reducing load times significantly. We also have some additional functionality not present in the original game for players running on ultrawide monitors and/or with a custom camera maximum distance: by typing <code class="language-plaintext highlighter-rouge">!player AOIVolume value</code> in chat you can customize the “draw distance” of entities that are considered to be in proximity.</p>

<p>Replication is a core part of any online game, because it is what keeps all clients synchronized with the game state happening on the server. We will most likely go more in-depth on this in future reports, once it is closer to being finished.</p>

<h2 id="live-tuning">Live Tuning</h2>

<p>One fun thing we were able to do this month is get the live tuning system up and running. This is a system that allowed the developers to do quick hotfixes without patching the game. While somewhat limited compared to changing game data directly, there are some interesting things you can do with it.</p>

<p>For instance, regions have the following live tuning “knobs” available to them:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">RegionTuningVar</span> <span class="p">{</span>
    <span class="na">eRTV_PlayerLimit</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">eRTV_Enabled</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">eRT_BonusXPPct</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">eRT_XPBuffDisplay</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">eRT_BonusItemFindMultiplier</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="na">eRTV_NumRegionTuningVars</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eRTV_Enabled</code> allows the server to disable individual regions. This is how, for example, the Mystic Mayhem in Limbo event is implemented: Limbo is a regular region that is disabled with live tuning unless the event is running. So by turning off this setting we can make Limbo accessible in-game.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg" alt="Live Tuning - Limbo Waypoint" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg" alt="Live Tuning - Limbo" /></a></p>

<p>Or we can go in the opposite direction and disable everything <em>but</em> Limbo. Feels like 2013 again!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg" alt="Live Tuning - Disable Regions" /></a></p>

<p>Another group of tuning parameters affects avatar entities:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">AvatarEntityTuningVar</span> <span class="p">{</span>
	<span class="na">eAETV_BonusXPPct</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="na">eAETV_XPBuffDisplay</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="na">eAETV_EternitySplinterPrice</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="na">eAETV_Enabled</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="na">eAETV_NumAvatarEntityTuningVars</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eAETV_Enabled</code> here works similarly to regions, allowing us to disable individual heroes. One possible use for this feature could be implementing an Infinity War themed event where half of the playable heroes would be picked randomly and disabled for the duration of the event.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg" alt="Live Tuning - Disable Avatars" /></a></p>

<p>All the tuning parameters are defined in the protocol and can be found <a href="https://github.com/Crypto137/MHServerEmu/blob/master/proto/CommonMessages.proto#L42">here</a>. You can experiment with them yourself by editing <code class="language-plaintext highlighter-rouge">LiveTuningData.json</code> located in <code class="language-plaintext highlighter-rouge">MHServerEmu\Data\Game\</code>.</p>

<hr />

<p>This is all we have to share today. Thank you very much for following the development of MHServerEmu. See you next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: January 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: January 2024" /><published>2024-01-30T03:06:40+03:00</published><updated>2024-01-30T03:06:40+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-01/header.jpg" alt="MHServerEmu Progress Report - January 2024" /></p>

<p>Hello there! The first month of 2024 is now almost behind us, and we have been hard at work on all things Marvel Heroes. Let us dive right in!</p>

<h2 id="calligraphyserializer-is-a-lie">CalligraphySerializer is a Lie</h2>

<p>Before continuing I strongly suggest you read the reports from <a href="/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html">November 2023</a> and <a href="/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html">December 2023</a> if you have not done so already. You have been warned.</p>

<p>Most of my time in January has been spent untangling the web that is the <code class="language-plaintext highlighter-rouge">CalligraphySerializer</code> class. And the fun begins right from the name: despite being called a “serializer”, it literally cannot serialize any data. It is used strictly for deserialization of Calligraphy prototypes. You literally cannot trust things to do what they say they do.</p>

<p>What it actually does can be summarized like this:</p>

<ol>
  <li>
    <p>It takes a blank prototype instance of a certain type as input.</p>
  </li>
  <li>
    <p>If the prototype references a parent prototype, the parent data is copied to the child. If the parent has not yet been loaded, it goes through the deserialization process itself, and this continues until all parents are loaded.</p>
  </li>
  <li>
    <p>All serialized Calligraphy field groups are processed. Regular field group have their fields matched to fields defined in the prototype class, its parents, and mixin fields, and then deserialized using the appropriate parser method. Property field groups represent individual properties and are used to reconstruct property collections.</p>
  </li>
  <li>
    <p>A prototype can have embedded prototypes, so this whole process is recursive.</p>
  </li>
</ol>

<p>As of right now, we have most of the regular field group processing working, but we still need to implement property collection reconstruction, as well as some small things here and there. Our overall current implementation progress is represented in the following diagram:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png" alt="CalligraphySerializer WIP" /></a></p>

<p>One of the biggest challenges I have had to deal with implementing this has been matching serialized fields to appropriate class fields. The client uses a custom <a href="https://en.wikipedia.org/wiki/Run-time_type_information">run-time type information</a> system for this called GRTTI. While it should be technically possible to reimplement GRTTI, it would also be somewhat like reinventing the wheel when our server emulator is written in C#, which already has very strong reflection capabilities that can be used to get a very similar result.</p>

<p>C# reflection has its drawbacks though: while extremely flexible, it is notoriously slow, and when you have to use it literally hundreds of thousands of times, it really adds up. In one of our unoptimized testing cases it took over 80 seconds to load all prototypes, while the original game did it in 3. In the end, with some targeted result caching, I have been able to get it to a pretty reasonable time of about 12 seconds, which should be more than good enough for our current needs. There is always more room for more optimization, but that is going to come later on. It should also be noted that all of this is a one-time cost during server startup, and if you do not have prototype frontloading enabled, you are most likely not going to notice this at all.</p>

<p>Another big issue that has come up has been taking care of mixins. While most embedded prototypes can be handled with recursion, there are some very specific cases where you have so-called mixin prototypes that need to be deserialized as if they were a part of the prototype itself. Their field groups are mixed with regular field groups (which is where I am guessing the name is coming from), and there are cases where you have entire collections of mixin prototypes. There is a significant amount of extra code that handles mixins specifically, and they are used in literally only three prototypes classes (out of over a thousand) in the entire game: <code class="language-plaintext highlighter-rouge">LocomotorPrototype</code> and <code class="language-plaintext highlighter-rouge">PopulationInfoPrototype</code> in <code class="language-plaintext highlighter-rouge">AgentPrototype</code>, <code class="language-plaintext highlighter-rouge">ProductPrototype</code> in <code class="language-plaintext highlighter-rouge">ItemPrototype</code>, and lists of <code class="language-plaintext highlighter-rouge">ConditionPrototype</code> and <code class="language-plaintext highlighter-rouge">ConditionEffectPrototype</code> in <code class="language-plaintext highlighter-rouge">PowerPrototype</code>. So in the case of list mixins there is literally a single prototype class that this entire subsystem exists for.</p>

<p>While there has been very good progress, the work on CalligraphySerializer is still not done. It is now possible to access a lot of the game data from code and use it in features like region generation, but there are still some aspects of mixin fields that need to be finished, as well as the property system, which is tightly tangled with the entire game.</p>

<h2 id="pipeline-improvements">Pipeline Improvements</h2>

<p>Another thing I have been able to work on this month is some general improvements to our delivery pipeline.</p>

<p>First of all, MHServerEmu now clearly states its version, build time, and build configuration:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png" alt="MHServerEmu Versioning" /></a></p>

<p>This is a pretty minor change, but it is going to make it much easier to figure out and solve issues as they arise.</p>

<p>Also, we now have automated nightly builds powered by GitHub actions and <a href="https://nightly.link/">nightly.link</a>. Thanks to that, if you want to try MHServerEmu out, instead of building the source code yourself, you can just download the latest build <a href="https://nightly.link/Crypto137/MHServerEmu/workflows/nightly-release-windows-x64/master?preview">here</a>. Those builds are based on the the latest <code class="language-plaintext highlighter-rouge">master</code> branch code, and are in general a decent representation of our current progress.</p>

<p>These small steps bring us closer towards a big milestone, which would be our first official binary release, tentatively numbered 0.1.0. We are going to talk more about that in the future.</p>

<h2 id="here-comes-a-new-challenger">Here Comes a New Challenger!</h2>

<p>This month our development team has expanded by 50%: <strong>Kawaikikinou</strong> has joined me (Crypto137) and AlexBond in restoring Marvel Heroes back to its glory.</p>

<p>MHServerEmu is a very complex project that involves many moving parts, so some time had to be spent to bring our new team member up to speed with what we are working on, but there are already some results that can be seen. So far Kawaikikinou has been mostly helping AlexBond with ironing out issues with region generation (more on that later), as well as improving the reliability of our code by introducing unit testing.</p>

<p>Another thing I am personally very excited about is <a href="https://github.com/Kawaikikinou/MHLogHelper">the new region visualization tool</a> he developed. Knowing is half the battle, and getting a better visual idea of what exactly is going on on the backend is going to be very helpful in the long run.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png" alt="MHLogHelper Screenshot 1" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png" alt="MHLogHelper Screenshot 2" /></a></p>

<h2 id="the-joy-of-region-generation-with-alexbond">The Joy of Region Generation with AlexBond</h2>

<p>This time I am joined by a co-writer: in this section AlexBond is going to go in-depth on what is happening behind the scenes with region generation.</p>

<hr />

<p>Hello everyone. I am AlexBond, and I am working on reimplementing the region generation. We are lucky to have the region generation code ifself present in the client, but it is disabled. Most likely it was among common game files, which is why it ended up in the client, or maybe the developers had the option to enable it for testing. In any case, in two months I was able to reimplement the region generation in C#.</p>

<p>Of course, I am not without faults, so we ended up with a number of bugs. So this month me and <strong>Kawaikikinou</strong> have been testing this new code and fixing all the issues. As of the time of writing, we have tested regions up to chapter 3, and it is also possible to load into other chapters with some workarounds. Our goal is to get an exact copy of a region generated by the client when it has generation enabled. We do the comparisons using logs and the IDA debugger. Over the course of testing I was able to get a slightly better understanding of the generation process, I would like to share with you what I have discovered.</p>

<h3 id="region-prototype">Region Prototype</h3>

<p>A region prototype contains information about the type of generator a region uses. There are three region generators in total, but for now we are going to take a look at the most complicated and interesting one - <code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code>.</p>

<p><code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code> is a generator that describes a tree of <em>areas</em>, and this tree contains all possible variations with weights for each one. Branches of this tree contain area prototypes. Overall this can be represented as a kind of a chain sequence:</p>

<center>Area 1 - Area 2 - Area 3 - an so on</center>

<p>The <code class="language-plaintext highlighter-rouge">ProcessSequence()</code> function runs recursively through the tree of areas. During its run it uses a random seed to determine sequences (<code class="language-plaintext highlighter-rouge">PickSequence()</code>), areas (<code class="language-plaintext highlighter-rouge">PickArea()</code>), their positions and connections to other areas (<code class="language-plaintext highlighter-rouge">PickAreaPlacement()</code>), and in the end it runs the generator of the current area. This recursion goes through the entire tree from the end to the beginning.</p>

<p>For example, in Madripoor it goes like this:</p>

<center>LowTown -&gt; Cove -&gt; BambooForest -&gt; Beach</center>

<p>If an area generator runs into an error, all previous areas are destroyed and rebuilt until the error disappears. To prevent infinite rebuilds, there is a special parameter called <code class="language-plaintext highlighter-rouge">MaxGenerationTimeInSec</code>, but currently I am not using it (perhaps I should).</p>

<h3 id="area-prototype">Area Prototype</h3>

<p>An area prototype defines the type of generator and the cell generation rules. In total there are seven different area generators, but I would like to talk about the most commonly used ones - <code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> and <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> (<code class="language-plaintext highlighter-rouge">GridAreaGenerator</code>).</p>

<h4 id="cellgridgenerator">CellGridGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">CellGridGenerator</code> is a rectangle of cells, and the size of this rectangle is defined in the area prototype.</p>

<p>The generation process includes ten attempts of creating an arrangement of cells that adheres to certain requirements. Now I am going to describe creation functions.</p>

<p><code class="language-plaintext highlighter-rouge">InitializeContainer()</code> - creates a <code class="language-plaintext highlighter-rouge">CellContainer</code> with a size of <code class="language-plaintext highlighter-rouge">CellsX</code> by <code class="language-plaintext highlighter-rouge">CellsY</code>. This is just a rectangle for holding cells that are going to be added.</p>

<p><code class="language-plaintext highlighter-rouge">EstablishExternalConnections()</code> - defines which sides are going to have cells for connecting to adjacent areas.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRandomInstanceLinks()</code> - defines connections to various <code class="language-plaintext highlighter-rouge">RandomInstances</code> (not all regions contain those).</p>

<p><code class="language-plaintext highlighter-rouge">CreateRequiredCells()</code> - defines groups of cells to be placed:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredSuperCells</code> - places consisting of multiple cells (mostly 2x2), like the Fall Tribe village in Savage Land, or buildings.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredSuperCells</code> - this type is used only in the <code class="language-plaintext highlighter-rouge">MutateMarshArea</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RegionTransitionSpec</code> - these are mostly places for waypoints and entrances to various treasure rooms. These places are determined using teleports contained in <code class="language-plaintext highlighter-rouge">RegionConnectionNodePrototype</code> that exit to this region.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RandomInstances</code> - a list of random places, these are not in the game…</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredCells</code> - these are special places that must be present in an area, like shops or cafes (e.g. <code class="language-plaintext highlighter-rouge">Madripoor_Lower_BobaTeaPOI_A</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredPOICells</code> - cells from <code class="language-plaintext highlighter-rouge">POIGroups</code>, I cannot say for sure what they are (they appear in <code class="language-plaintext highlighter-rouge">Wakanda</code>, <code class="language-plaintext highlighter-rouge">DangerRooms</code>, <code class="language-plaintext highlighter-rouge">CowRegion</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredNormalCells</code> - another group of cells, used in <code class="language-plaintext highlighter-rouge">HellsKitchen</code> (<code class="language-plaintext highlighter-rouge">Brownstone_C_Barricade_ESW_A</code>).</p>
  </li>
</ul>

<p>Now we have a filled <code class="language-plaintext highlighter-rouge">CellContainer</code> with a number <code class="language-plaintext highlighter-rouge">CellRefs</code>, and if it is successful we can move onto destroying and adding cells to the current area.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousCells()</code> - this process uses <code class="language-plaintext highlighter-rouge">RoomKillChancePct</code> to determine the number of cells that need to be destroyed using the <code class="language-plaintext highlighter-rouge">RoomKillMethod</code>. There are three deletion methods - Random, Edge, and Corner. When deleting cells there are checks for paths between imporant points, and only the cells that can be safely removed without breaking those paths are removed.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousConnections()</code> - removes redundant connections between cells using <code class="language-plaintext highlighter-rouge">ConnectionKillChancePct</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> - the main function that randomly picks cells for creation. If a cell has not been previously defined, it is going to be picked from the appropriate <code class="language-plaintext highlighter-rouge">CellSet</code> based on cell type.</p>

<p>At this point <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> either succeeds or fails. If it fails, all areas are destroyed and regenerated.</p>

<h4 id="widegridareagenerator">WideGridAreaGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> differs by having <code class="language-plaintext highlighter-rouge">GenerateRoads()</code> and <code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code>, as well as a different implementation of <code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> that picks cells based not on their type, but <code class="language-plaintext highlighter-rouge">RequiredWalls</code>.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRoads()</code> - defined by the Roads prototype in the generator. This function uses the <code class="language-plaintext highlighter-rouge">DijkstraRoad()</code> method based on the <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> for finding the shortest path between nodes.</p>

<p><code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code> - if the <code class="language-plaintext highlighter-rouge">ProceduralSuperCells</code> field contains data, it creates a random set for a 2x2 square and rotates it randomly.</p>

<p>Here is an example of generation for <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaA</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 4<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Corner</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>X</td><td>X</td><td></td><td>X</td></tr><tr><td>B</td><td></td><td></td><td>A</td></tr></table></div>
</div>

<p>As we can see, in this case the path from A to B is preserved, and 60% of the cells were removed using the corner method.</p>

<p>This is what we get in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png" alt="Region Generation Example 1" /></a></p>

<p>Now let us take a look at the next area, <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaC</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 3<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Random</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td></td><td>B</td></tr><tr><td>C</td><td></td><td>X</td></tr><tr><td>X</td><td>X</td><td>X</td></tr></table></div>
</div>

<p>As we can see, in this case the path from B to C is preserved and 60% of the cells were removed using the random method.</p>

<p>And here is what it looks like in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png" alt="Region Generation Example 2" /></a></p>

<p>Hopefully now it should be more clear how all of this functions.</p>

<p>As for my work, recently I have merged the new prototype system written by Crypto137, and now the testing of generation is much faster, and it is going to be easier to merge with the main repository. But we still have a lot of tests to do, so please be patient.</p>

<hr />

<p>Back to Crypto to wrap things up. We are getting very close to finally reaping the fruits of our efforts over the past few months, and hopefully we will be able to deliver results that are more visible in-game soon enough. We are just as excited as you are to finally see some things come together. Until next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: December 2023</title><link href="https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: December 2023" /><published>2023-12-25T11:00:00+03:00</published><updated>2023-12-25T11:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2023-12/header.jpg" alt="MHServerEmu Progress Report - December 2023" /></p>

<p>Happy holidays everyone! This month and year are coming to an end, and it is time for another MHServerEmu progress report.</p>

<h2 id="game-database-update">Game Database Update</h2>

<p>In December there has been significant progress reimplementing the game database. If you have not yet read <a href="/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html">the last month’s report</a>, I suggest you go and do that right now, because what is coming is very much a continuation of that post.</p>

<p>The most significant milestone we have been able to achieve this month is restoring the original hierarchy of prototypes. This allows us to understand relationships between various pieces of data and make use of them.</p>

<p>For example, MHServerEmu has a command that allows you to look up costumes, <code class="language-plaintext highlighter-rouge">!lookup costume</code>. Previously it was implemented by iterating through all data files and checking every single file path for a certain pattern. This approach has always been a temporary solution: it is slow and it relies on files being consistently named (spoiler: they are not). What we can do instead now is just get a collection of all prototypes that reference the costume blueprint. This reduces pattern matching complexity and the number of iterations we have to do, and removes the reliance on naming. To put it in simpler terms, it is much faster and more convenient.</p>

<p>The prototype hierachy is also going to be essential for implementing the property system, which is the foundation of all game entities, such as player avatars and enemies. We are going to go into more detail on this topic in a future report, once it is actually up and running.</p>

<p>Another thing this development has allowed us to do is make some charts. Exciting, am I right?</p>

<p>First we have a chart of top 30 most used prototype classes. These use standard inheritance, so there is some overlap here (e.g. all world entity prototypes are also entity prototypes).</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/top-prototype-classes.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/top-prototype-classes.png" alt="Top 30 Most Used Prototype Classes" /></a></p>

<p>Next is top 30 most referenced blueprints. These function more like composition: entities at their core are collections of properties, such as their level or maximum health, and what properties an entity is supposed to have is defined by referencing individual property blueprints.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/top-blueprints.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/top-blueprints.png" alt="Top 30 Most Referenced Blueprints" /></a></p>

<p>However, while restoring the hierarchy is an important step, this is just one piece of the puzzle. Since there is a lot of interdependency between pieces of data, everything has to be loaded in the right order, or else things are going to get very messy very fast. So there has also been ongoing work on restoring various underlying systems that are going to allow us to do just that.</p>

<p>A good example of such system is on demand prototype loading. A naive approach that we used to take is to load all 93144 prototypes on startup in the order they are stored. Other than loading in the wrong order, this way we also load a lot of unnecessary data, including prototypes for cut and unfinished content, as well as debug prototypes that are disabled in shipping versions of the game. Although optimization is not really a high priority for us right now, it is still good to keep it in mind, especially when it comes as a side effect of doing something else.</p>

<p>So we have reverse engineered the solution Gazillion had: store all data in memory compressed using the <a href="https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)">LZ4</a> algorithm and decompress and deserialize only what is requested. By doing it this way we not only gain control over what is loaded and in what order, but also get some convenient savings on initial memory usage and initialization time. And this is despite the fact that we now spend additional memory and time on initializing and storing the hierarchy cache!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/memory-usage.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/memory-usage.png" alt="MHServerEmu Initial Memory Usage" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/game-database-initialization-time.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/game-database-initialization-time.png" alt="MHServerEmu Game Database Initialization Time" /></a></p>

<p>This is going to be especially useful for playing solo offline on lower end hardware. For potential larger scale servers this may cause hitching if too much new data is requested at once, and for that we have implemented an option to frontload all data in the correct order that is also present in the original game.</p>

<p>As we implement additional functionality, these numbers are going to gradually go back up. However, considering the amount of unused data I mentioned previously, even after loading all the relevant data it may end up using less memory than loading everything without storing a compressed copy.</p>

<p>Despite the great progress we have had with the game database this month, there is still work to be done. As I write this, we are approaching a point where we will be able to implement proper deserialization for Calligraphy prototypes, which is the biggest roadblock for working on game systems. When that happens, we are going see more things happening in-game.</p>

<h2 id="region-generation-update">Region Generation Update</h2>

<p>Meanwhile, as I have been working mostly on the game database, Alex continues his efforts on reimplementing the procedural region generation. If you have not yet, you can check his progress in the <a href="https://github.com/AlexBond2/MHServerEmu/tree/experimental">experimental branch</a>.</p>

<p>We are lucky to have most of the logic for procedural generation in the client. However, implementing it still proved to be a very laborious process due to how intricate and occasionally buggy the original code is. Once all the pieces are done and put together, this, along with the game database, is going to make all regions in the game explorable and, where applicable, randomly generated, as they should be.</p>

<p>To keep everything as authentic as possible and avoid future replication issues we try to stick to the disassembled original code as much as possible. This includes reimplementing even the basic building blocks that are usually already taken care of by various existing game engines these days.</p>

<p>One example of such building block are quadtrees, which is a data structure commonly used in video games for optimization. For instance, if you were to do collision detection without any tricks, you would have to check every single object against every other object, so the number of checks you would have to do would increase exponentially with the amount of objects in your game (which is the ultimate evil in computer science, also known as an O(n²) algorithm).</p>

<p>But when you think about it, it does not make any sense to check for collisions against far away objects. So it is common to divide space into sections, and do checks within each section separately. This is where quadtrees come in: they are used to divide objects into four sections (quads), but they are also trees, so each section can have subsections of its own. This may be a little difficult to grasp in writing, so here is a visualization of collision detection using quadtrees I found on YouTube:</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/TJzq_kjtGTc" frameborder="0" allowfullscreen=""></iframe></div>

<p>Although the Marvel Heroes game client is built using Unreal Engine 3, the game logic actually running everything is all custom Gazillion code. In a way this resembles the semi-recently released Diablo II Resurrected, where the original game is running underneath a new graphical engine. Except in the case of Marvel Heroes the “original game” does not have any graphics of its own.</p>

<p>So when we reimplement things such as quadtrees, we have to figure out and take into account all the original quirks. For example, the Marvel Heroes implementation of this data structure uses what is known as an intrusive circular linked list for storing its elements: each element is linked to elements before and after it, these links are stored within the element itself rather externally (which is why it is intrusive), and the link to the next element at the end of the list points back to the first element (circular).</p>

<p>This is just one example of the work that goes into restoring this system. The good news is, region generation is also steadily approaching testable state, and once everything is ready to combine it with the game database implementation, we are going to have a lot of fun.</p>

<h2 id="core-system-improvements">Core System Improvements</h2>

<p>In December I have also taken some time to do a pass on some of the foundational systems of MHServerEmu that could have used some extra work.</p>

<p>Previously we used a TCP server implementation ported from a Diablo III Beta server emulator that was in development in 2011-2012. This is the part of the server that handles client connections, as well as receiving and sending data. While this implementation does get the job done, it never got the chance to get polished, and it was built on an obsolete design pattern known as <a href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm">asynchronous programming model (APM)</a>. So this month I have written a new implementation based on the newer and hipper <a href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">task-based asynchronous pattern (TAP)</a>, which is hopefully going to be cleaner and more maintainable.</p>

<p>Another piece ported from the Diablo III server is our logging system. I was mostly happy with it, however one issue it had was the fact that it was synchronous, meaning that while something was being logged nothing else could be happening on the caller thread. This was an issue for logging large quantities of messages from the main game thread, which is supposed to update on a 50 millisecond cycle. And instead of the game running, everything had to wait until messages finished printing in the console window. This problem is gone: log messages are now enqueued synchronously allowing us to get accurate timestamps for each message, but the output happens asynchronously as a separate task. So now the impact of logging on game performance is just about as low as it can get without compromises.</p>

<p>Finally, as a test for doing Calligraphy prototype deserialization later on, I have improved our configuration system using the reflection capabilities of C#. This is not something that is going to affect the end user, but it has made adding and removing various server settings easier.</p>

<p>The end goal is to have not just something that is capable of running the game, but it also being maintainable and reasonably fast, so expect the work on this front to continue.</p>

<h2 id="miscellaneous-updates">Miscellaneous Updates</h2>

<p>Here are some additional points I would like to highlight without dedicating entire sections to them:</p>

<ul>
  <li>
    <p>We now have a tool for unpacking and packing <code class="language-plaintext highlighter-rouge">.sip</code> files. This is the first step for modding game data files. You can grab the source code for it <a href="https://github.com/Crypto137/MHServerEmu/tree/master/tools">here</a>.</p>
  </li>
  <li>
    <p>The work on documenting various versions of the game mentioned in the previous report continues. There is now <a href="https://github.com/Crypto137/MHProtobufs">a new repository</a> for documenting the evolution of the game’s network protocol.</p>
  </li>
</ul>

<hr />

<p>That’s it for today. A lot has happened this year, and even more exciting stuff awaits us in the next. See you next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: November 2023</title><link href="https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: November 2023" /><published>2023-11-28T03:00:00+03:00</published><updated>2023-11-28T03:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2023-11/header.jpg" alt="MHServerEmu Progress Report - November 2023" /></p>

<p>Hey everyone! Crypto here with the very first MHServerEmu progress report. I will try to do these semi-regularly to shine a light on all the latest things we are working on. Without further ado, let’s dive right in!</p>

<h2 id="game-database">Game Database</h2>

<p>While things have been on the quiet side this month, it doesn’t mean nothing is happening. Our biggest roadblock has been the game database, and its rebuilding will most likely remain our highest priority for the foreseeable future. So what is it and why does it take so long?</p>

<p>The thing is, Marvel Heroes is engineered in a way that’s somewhat unusual for an online RPG. Usually the client contains the bare minimum of information it needs to function, and one of the most time-consuming parts of reverse engineering a server for a game like this is collecting data and creating an approximation of things like where all the enemies should be, how much damage they should deal, what loot they should drop, their AI, scripting, and so on. This can be done using sophisticated tools that analyze packets received from the server, by watching what is happening in-game, or even by simply guessing in some cases. The problem is, the servers for Marvel Heroes are long gone, and it’s impossible to gather any new data, right? Not necessarily.</p>

<p>As we discovered doing our research, the game client actually contains a complete mirror of all the data used by the server. In a way, Marvel Heroes is built more like a single player game with an optional multiplayer mode, not unlike Diablo II, but where the single player functionality was stripped out at the last moment. So while the client lacks the “glue” that keeps everything together, all the individual pieces that make the game what it is, also known as prototypes, are completely preserved. But there’s a lot of pieces (there are 93114 prototypes in the version we are currently working with, and thousands more of auxiliary data files), and putting them together is tricky.</p>

<p>Gazillion developed their own custom framework for managing game data called <em>Calligraphy</em>. It appears most of the actual game was made with it, and it must have also included a set of custom tools reminiscent of programs like the Warcraft III World Editor:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/warcraft-3-trigger-editor.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/warcraft-3-trigger-editor.jpg" alt="Warcraft III Trigger Editor" /></a></p>

<p>In fact, this is a common way of developing video games, also known as data-driven design. Engineers develop a set of tools that expose various systems to game designers, who in turn define what the actual game is supposed to be through data, like what abilities should a hero have access to and how much damage should an enemy deal. These tools often contain some form of scripting functionality that allows designers to also define behaviours (like the trigger editor from Warcraft III shown on the screenshot above).</p>

<p>So while we do have all the original data for Marvel Heroes, to make use of it we also need to reverse engineer the framework it ran on. Calligraphy is a pretty powerful one: it features pretty advanced scripting capabilities and was used to define enemy AI, mission logic, damage formulas, and much more. And as we know, with great power comes great responsibility: there is a lot of moving parts, and just setting everything up requires a lot of steps.</p>

<p>A good example of this is the hierarchy of data:</p>

<ul>
  <li>
    <p>To interface with loaded data, there are over a thousand C++ classes that heavily rely on inheritance.</p>
  </li>
  <li>
    <p>Data is deserialized into these classes using a combination of blueprint and prototype files: blueprints contain field definitions, and prototypes contain the actual values.</p>
  </li>
  <li>
    <p>Each blueprint is paired with a default prototype that contains default values for a given blueprint. Most of the prototypes that are actually used in the game inherit from these default prototypes and override values as needed. For example, there is a blueprint / default prototype for an avatar, and prototypes for each playable hero override this default avatar prototype. This is a simple example, but there are often multiple levels of data inheritance here.</p>
  </li>
  <li>
    <p>Blueprints have their own inheritance that is really more like composition: each blueprint defines its own field group, but it can also reference other blueprints. And then a prototype gets its field groups from the blueprint it is directly bound to and all the other blueprints referenced in it.</p>
  </li>
  <li>
    <p>Some prototypes have “mix-in” prototypes that you are supposed to pass some of the field groups to.</p>
  </li>
  <li>
    <p>There are also resource prototypes that completely ignore everything mentioned above and use custom deserialization routines. However, they still fit into the same C++ class hierarchy.</p>
  </li>
</ul>

<p>As you can see, there’s a lot to unwrap here, and the devil is in the details. So figuring out all of this has been very time consuming, but progress is definitely being made. And once we get it all up and running, it’s going to open the way for implementing all sorts of in-game systems.</p>

<h2 id="mhdataparser">MHDataParser</h2>

<p>When we began investigating what data even was present in the client, we started by examining various file types on their own, and that led to the server emulator getting some data parsing and exporting functionality. As our understanding of the bigger picture grew, it became evident that rather than using the data structures present in the files as is, the game actually does a significant amount of post-processing during initialization. So it became harder and harder to maintain this functionality as our implementation of the game database matured.</p>

<p>However, there is a lot of value to having raw data parsed and represented as is in a more readable format. It’s more version-agnostic, it can be used for datamining, and eventually it can even be expanded for modding game data. So, to keep the main codebase clean while not losing anything, I separated raw data parsing into a separate tool called <a href="https://github.com/Crypto137/MHDataParser">MHDataParser</a>. I tested it with various builds of the game, and so far it seems to work on PC clients going as far back as June 2015, as well as console ports. It won’t work with 2013-2014 versions of the game due to data archive format differences, but implementing support for them is definitely possible in the future.</p>

<p>It’s essentially a piece cut from an older MHServerEmu version, so it works very similarly: you copy game data files to the tool’s subdirectory, run it, wait for it to initialize, and then enter commands to export the data you want to human-readable JSON/TSV files. However, all the file definitions are up to date with the latest versions of the server, and there’s even a little bit of extra functionality that allows you to parse and export locale and string files.</p>

<p>As I was working on this, I made a pretty hilarious discovery: in earlier versions of the game there is a hidden “Pig Latin” localization that was used for testing:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-login-screen.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-login-screen.jpg" alt="Pig Latin Login Screen" /></a></p>

<p>And with a little bit of file renaming, hex editing, and config adjustment I was able to get it running in version 1.52:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-mission-log.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-mission-log.jpg" alt="Pig Latin Mission Log" /></a></p>

<p>Not even S.H.I.E.L.D. Agent Stan Lee is safe from it (or should I say, Say.Hay.Iay.Eay.Lay.Day Agentay Anstay Eelay):</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-stan-lee.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-stan-lee.jpg" alt="Pig Latin Stan Lee" /></a></p>

<p>Having fun aside, this is actually a working proof-of-concept for translating the game into more languages. And way more ambitious mods may also be possible far in the future.</p>

<h2 id="region-generation">Region Generation</h2>

<p>Even though a lot of our efforts has gone into solving the game database conundrum, Alex has also been working very hard on reverse engineering procedural region generation. While it’s still very much work-in-progress. I will give you a brief overview of what it entails.</p>

<p>As you probably know, Marvel Heroes has a lot of Diablo DNA that brings with it heavy reliance on procedural generation, so every time you play the game you can explore slightly different zones, fight different enemies, and get random loot. The game world is actually structured like this:</p>

<ul>
  <li>
    <p>There is a number of <em>games</em> running on a server. Each game is very similar to games on Battle.net in Diablo II, but you transition in and out of them seamlessly.</p>
  </li>
  <li>
    <p>Each game hosts a number of <em>regions</em>, which are places like Avengers Tower, Midtown, and so on. As you transition between regions, you also often transfer between different games and even servers.</p>
  </li>
  <li>
    <p>Each region consists of <em>areas</em> that have their own names and other characteristics. You can go to different areas in a region without a loading screen by moving around. For example, in the Madripoor region the first area would be Buccaneer Beach, from which you can go to Bamboo Forest, and then eventually reach Lowtown.</p>
  </li>
  <li>
    <p>Each area is built from <em>cells</em>, which are basic building blocks of the game world.</p>
  </li>
</ul>

<p>The way Marvel Heroes approaches area generation is actually very similar to Diablo III, and I highly recommend watching <a href="https://www.youtube.com/watch?v=tUFvhDOPA_w">this talk on Diablo Dungeon Design</a> by Ed Hanes from Blizzard, where he goes quite in-depth and even demonstrates some of their internal tools. Unfortunately, the video is age-restricted, so I can’t embed it here, but I will add some of the slides relevant to Marvel Heroes.</p>

<p>Cells, just like tiles in Diablo, are classified by their cardinal directions:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-cardinal-directions.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-cardinal-directions.jpg" alt="Diablo III Tile Cardinal Directions" /></a></p>

<p>These cells are combined into areas according to sets of rules defined by game designers in development tools like these:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-procedural-layout.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-procedural-layout.jpg" alt="Diablo III Procedural Layout" /></a></p>

<p>Marvel Heroes uses a number of different region and area generators for various cases:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/region-generators.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/region-generators.png" alt="Diablo III Procedural Layout" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/area-generators.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/area-generators.png" alt="Diablo III Procedural Layout" /></a></p>

<p>Some regions are actually static and do not use procedural generation. But they still follow the same general rules and are built out of cells: regions like Avengers Tower can get away with using a single huge cell, while places like Midtown are collections of regular cells in a predefined layout, also known as a district.</p>

<p>Region generation heavily relies on data from the game database, so it won’t be out for a little while, but there may be something exciting happening in the experimental branch sooner.</p>

<h2 id="documentation">Documentation</h2>

<p>Another thing that happened this month is that I took some time to overhaul our <a href="https://github.com/Crypto137/MHServerEmu/blob/master/docs/Index.md">documentation</a>:</p>

<ul>
  <li>
    <p>All existing information was restructured and updated with latest discoveries.</p>
  </li>
  <li>
    <p>There are two new sections: <em>Networking</em> lays out some of our understanding of the client &lt;-&gt; server communication, while <em>Game Data</em> focuses on the intricacies of file formats, prototypes, and all the other game database related topics.</p>
  </li>
</ul>

<p>While it’s still nowhere near its final form, hopefully this will help potential developers get up to speed with what we’ve been doing. When I first started doing this, the lack of pretty much any publicly available technical information on Marvel Heroes was one of the hardest hurdles to overcome, especially when compared to many other well-documented online games.</p>

<p>If you have any suggestions for topics you would like to see covered, be sure to let us know!</p>

<h2 id="version-research">Version Research</h2>

<p>On a separate note, I’ve been doing some digging into the various versions of Marvel Heroes that we have access to. As you may know if you’ve read our documentation, there are almost 700 different client builds still available to download from Steam if you have ever played the game and still have a license on your account. So what I’ve been doing is downloading and documenting every single one of them. It’s a massive amount of data to go through, and you may wonder if it’s even worth doing. In my opinion, it is, for three reasons: preservation, getting additional data to reference, and finding internal builds.</p>

<p>Preservation should be pretty self-explanatory. As a live service game, Marvel Heroes went through a lot, and many of these moments were rather fleeting. Be it resource gathering to open the Bifrost for the very first time, some event you spent a few too many hours grinding through the night, or just a memorable login screen, to have definitive records of all of this we need old versions of the game.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/GZul9BIN4F0" frameborder="0" allowfullscreen=""></iframe></div>

<p>Another important result of this task is getting additional data to reference, which can be extremely useful for development. A very good example of this is version 1.25 released on July 31, 2014. The following was mentioned in the <a href="https://web.archive.org/web/20150101185936/http://forums.marvelheroes.com/discussion/118449/marvel-heroes-2015-1-1-patch-notes">patch notes</a> by the infamous master of spoilers Doomsaw himself:</p>

<blockquote>
  <p>This update features major changes to how the game processes certain aspects of data, including how data it transmitted to you and players around you.</p>

  <p>This will result in a decent improvement to server performance as well as client performance, depending on your exact system specs, CPU and GPU.</p>
</blockquote>

<p>To explain what it really means we need to go through some fundamental aspects of the game’s netcode. At the heart of it are Google’s Protocol Buffers (protobufs): in case you are unfamiliar with them, they are kind of like XML or JSON, but instead of human-readable text files your data is serialized into binary using a custom <em>wire format</em>. They are widely used in video games (for example, Blizzard does a lot of Battle.net communication with protobufs), however they are a general-purpose technology that can be sub-optimal in cases where you have thousands of messages to process, and every microsecond counts.</p>

<p>To work around this, Gazillion developed a custom archive system based on the protobuf wire format. Without going too in-depth here, what they essentially did is cut all the extra bells and whistles that make protobufs more flexible while keeping all the tricks that reduce message size and serialization time. And a significant part of the optimizations done in 1.25 is actually taking some of the “heavier” and frequently used protobuf messages (<code class="language-plaintext highlighter-rouge">NetMessageEntityCreate</code>, <code class="language-plaintext highlighter-rouge">NetMessageLocomotionStateUpdate</code>, <code class="language-plaintext highlighter-rouge">NetMessageActivatePower</code>, <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code>, and <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code>), and expanding the custom archive system to include them.</p>

<p>For example, let’s take a look at <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code> as it was in 1.24:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityEnterGameWorld</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">entityId</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">NetStructPoint3</span>    <span class="na">position</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructPoint3</span>    <span class="na">orientation</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">avatarWorldInstanceId</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructLocomotionState</span>    <span class="na">locomotionState</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">entityPrototypeId</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">isClientEntityHidden</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">newOnServer</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetStructLocomotionState</span> <span class="p">{</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">locomotionflags</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">method</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">movespeed</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">height</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">followentityid</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">followentityrange</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">bool</span>    <span class="na">updatepathnodes</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="n">NetStructLocomotionPathNode</span>    <span class="na">pathnodes</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">pathgoalnodeindex</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetStructLocomotionPathNode</span> <span class="p">{</span>
    <span class="k">required</span> <span class="n">NetStructPoint3</span>    <span class="na">vertex</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">int32</span>    <span class="na">vertexSideRadius</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here is <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code> in 1.25+:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityEnterGameWorld</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, a side effect of this optimization is that some messages became a lot less verbose, and therefore less readable. Although it is possible to figure out the overall structure by decompiling and examining the deserialization routine, it takes more time to do blindly, and you have to guess most of the field names. So in some cases looking at older versions of the game can provide invaluable insight for reverse engineering the more recent builds.</p>

<p>Finally, not all builds are made equal. Most publicly available game clients are compiled using the <code class="language-plaintext highlighter-rouge">Shipping</code> configuration that automatically removes all the spicy stuff, such as the developer console and cheats. On the other hand, <code class="language-plaintext highlighter-rouge">Internal</code> builds contain everything but the kitchen sink (and even that after Deadpool’s level 52 review). For instance, MichaelMayhem and Ryolnir demonstrated some of their dev might during the <a href="https://www.youtube.com/watch?v=MekhABg5gCo">Rogue preview livestream</a> in August 2014:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/internal-cheats.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/internal-cheats.jpg" alt="MichaelMayhem and Ryolnir using cheats" /></a></p>

<p>Turns out, there was a number of slip-ups, and some of these internal builds actually ended up being uploaded to Steam. So far I’ve found five of them, with the earliest one being <code class="language-plaintext highlighter-rouge">1.10.0.69</code> from late May 2013, and the newest so far is <code class="language-plaintext highlighter-rouge">1.0.4932.0</code> from June 2015. While we have no way of getting them up and running right now, eventually it’s going to be possible, and we may end up being able to access forbidden powers reserved only for the few. Exciting!</p>

<hr />

<p>And this wraps it up for today. Thanks for reading (or scrolling) all the way to the end, and I hope to see you all again next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry></feed>