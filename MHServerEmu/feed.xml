<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://crypto137.github.io/MHServerEmu/feed.xml" rel="self" type="application/atom+xml" /><link href="https://crypto137.github.io/MHServerEmu/" rel="alternate" type="text/html" /><updated>2024-07-31T23:41:29+03:00</updated><id>https://crypto137.github.io/MHServerEmu/feed.xml</id><title type="html">MHServerEmu Blog</title><subtitle>A volunteer-driven research project aimed at reverse engineering the technology developed by Gazillion Entertainment.</subtitle><entry><title type="html">MHServerEmu Progress Report: July 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: July 2024" /><published>2024-07-31T22:30:00+03:00</published><updated>2024-07-31T22:30:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html"><![CDATA[<p><img src="/MHServerEmu/assets/blog/progress-report/2024-07/header.jpg" alt="MHServerEmu Progress Report - July 2024" /></p>

<p>We have a lot of exciting updates to share. It has been one year since this project started, and this month <em>combat</em> has returned to Marvel Heroes, which I would dare to call our biggest leap forward since we first got in-game in July 2023.</p>

<h2 id="you-got-the-power">You Got the Power</h2>

<p>We have laid the foundation for one of the most important and complex systems of Marvel Heroes - <em>powers</em>. From a certain perspective, it would not be an exaggeration to call it <em>the</em> most complex system in the entire game because of its deep interconnection with other systems and just the sheer amount of stuff it involves. Covering all of it is outside the scope of a single report, but I will give a brief overview of the work that has been done so far and what is left to do.</p>

<p>One important thing to note is that prior to this month we barely had any power-related functionality implemented server-side. The fact that you could “use” a lot of powers before was just the magic of client-side prediction, and the server was almost completely unaware of what was actually happening.</p>

<p>So where do we even begin? First of all, there are many different kinds of powers. Powers are classified by categories: <code class="language-plaintext highlighter-rouge">NormalPower</code>, <code class="language-plaintext highlighter-rouge">ComboEffect</code>, <code class="language-plaintext highlighter-rouge">EmotePower</code>, <code class="language-plaintext highlighter-rouge">GameFunctionPower</code>, <code class="language-plaintext highlighter-rouge">HiddenPassivePower</code>, <code class="language-plaintext highlighter-rouge">HotspotEffect</code>, <code class="language-plaintext highlighter-rouge">ItemPower</code>, <code class="language-plaintext highlighter-rouge">MissileEffect</code>, <code class="language-plaintext highlighter-rouge">ProcEffect</code>, <code class="language-plaintext highlighter-rouge">ThrowablePower</code>, and <code class="language-plaintext highlighter-rouge">ThrowableCancelPower</code>. Powers can have various targeting shapes: <code class="language-plaintext highlighter-rouge">ArcArea</code>, <code class="language-plaintext highlighter-rouge">BeamSweep</code>, <code class="language-plaintext highlighter-rouge">CapsuleArea</code>, <code class="language-plaintext highlighter-rouge">CircleArea</code>, <code class="language-plaintext highlighter-rouge">RingArea</code>, <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">TeamUp</code>, <code class="language-plaintext highlighter-rouge">SingleTarget</code>, <code class="language-plaintext highlighter-rouge">SingleTargetOwner</code>, <code class="language-plaintext highlighter-rouge">SingleTargetRandom</code>, <code class="language-plaintext highlighter-rouge">SkillShot</code>, <code class="language-plaintext highlighter-rouge">SkillShotAlongGround</code>, or <code class="language-plaintext highlighter-rouge">Wedge</code>. A power’s targeting style can have various flags applied to it, such as <code class="language-plaintext highlighter-rouge">AOESelfCentered</code>, <code class="language-plaintext highlighter-rouge">NeedsTarget</code>, <code class="language-plaintext highlighter-rouge">TurnsToFaceTarget</code>, <code class="language-plaintext highlighter-rouge">AlwaysTargetMousePos</code>, and more. This list can continue on and on, but the point is that there is <em>a lot</em> of factors to consider here, which is why our reimplementation of the <code class="language-plaintext highlighter-rouge">Power</code> class is already at over 6000 lines of code, and it continues to grow.</p>

<p>But all of that is just static data defined by game designers, and powers are dynamic beasts that live in runtime. Before a power can be used it needs to be <em>assigned</em> to a world entity’s <code class="language-plaintext highlighter-rouge">PowerCollection</code>. The assignment process includes the creation of an instance of the <code class="language-plaintext highlighter-rouge">Power</code> class that is in many ways not unlike an entity: it has its own <code class="language-plaintext highlighter-rouge">PropertyCollection</code>, as well as various other pieces of state. When a power is assigned it gets passed a set of information used for scaling referred to as <em>power index properties</em>: power rank, character level, combat level, item level, and item variation. This is one of the places where we can see that BUE was not as thorough as it may appear: although the update “removed” power ranks, they still exist internally, with most powers instead being set to rank 0 or 1 and rebalanced accordingly.</p>

<p>With the power assigned and initialized it can now be used. Every time you use a power it goes through a pipeline consisting of four main stages:</p>

<ul>
  <li>
    <p><strong>Activation</strong>: this is when the game checks if you can use the power (you have enough resources, your target is valid if the power needs one, etc.), starts the animation, and schedules a <em>power application</em> for when the contact frame is supposed to happen. Although the server does not actually play animations, it still needs to know how long they are, taking into account variables such as attack speed modifiers. In many cases it is possible to cancel activation before the animation reaches its contact frame.</p>
  </li>
  <li>
    <p><strong>Power Application</strong>: at the contact frame of the animation we reach the point of no return, which is when the power can actually begin doing something. At this moment the properties of the power and its owner are snapshotted and recorded into an instance of the <code class="language-plaintext highlighter-rouge">PowerPayload</code> class. Depending on the power, this payload may either get processed as soon as it is created, or it can be scheduled to be processed later. At the time of writing we do not have delayed processing implemented yet, which is why, for example, throwable objects deal damage instantly rather than when they actually reach their target destination. The correct way of doing this involves calculating the time the throwable object is going to spend in the air and delaying the processing of the payload by that time.</p>
  </li>
  <li>
    <p><strong>Payload Processing</strong>: this is where the fun begins. The snapshot of the power and its owner recorded in the payload is processed, and the <em>results</em> are calculated, which include damage, healing, and conditions (buffs and/or debuffs) that need to be applied to the target. Depending on the calculations, various result flags may be set, such as critical strike and dodge.</p>
  </li>
  <li>
    <p><strong>Application of Results</strong>: the results of the payload calculations are applied to the target. This involves adjusting the health of the target, potentially killing it, and applying conditions to it. Clients also get sent a copy of the results to display damage numbers and additional hit visual effects.</p>
  </li>
</ul>

<p>At various points in this process additional <em>power events</em> may get triggered. In total there are 30 event types that can trigger 36 types of actions. Some of these actions are very specific, like <code class="language-plaintext highlighter-rouge">BodySlide</code>, <code class="language-plaintext highlighter-rouge">SwitchAvatar</code>, and <code class="language-plaintext highlighter-rouge">PetItemDonate</code>, but others are more general purpose, such as <code class="language-plaintext highlighter-rouge">UsePower</code>, <code class="language-plaintext highlighter-rouge">EndPower</code>, and <code class="language-plaintext highlighter-rouge">CooldownStart</code>. One of the most common use cases for power events is the activation of <em>combo powers</em>: when a power needs to do more than one thing, like moving your character and dealing AoE damage around your destination, this is usually achieved by having two different powers, with one triggering the other as a combo.</p>

<p>While all kinds of entities can use powers, avatars are a very special case, because they are controlled by players connected remotely. One example of special treatment in this regard is the concept of <em>continuous powers</em>. You may recall how in our earlier iteration of “combat” that you can still see in stable builds most powers would deal damage only on the initial activation, with no effect if you held the button down or pressed it frequently enough. The reason for this is that the game classifies a lot of powers as continuous based on various criteria, such as animation length, category, override flags, and more. If a power is continuous, activations after the initial one are not communicated between the client and server: the server just assumes the client is still holding the button down and continuously reactivates it until it receives a cancellation message. This requires the server to be able to run the entire power activation process on its own in parallel to the client, which was not possible previously with hacks, but can now be done.</p>

<p>Another example of avatar-specific behavior is the priority queue system. The basic idea of it is that if a player input cannot be acted on immediately because another power is already being used, this input is put into a very small queue with a size of one or two commands. If there is a new command that is different from the rest of commands that have been issued recently, such as when you try to activate a defensive power inbetween spamming regular attacks, this different command takes priority so it doesn’t get lost. This system works almost exactly the same as, for example, Diablo III, and if you are interested in this topic I strongly recommend watching the talk <a href="https://gdcvault.com/play/1017794/Through-the-Grinder-Refining-Diablo">Through the Grinder: Refining Diablo III’s Game Systems by Wyatt Cheng</a>. Not only will you learn interesting stuff, you will also discover Wyatt’s origin story before he became infamously known as the “do you guys not have phones” guy. Currently we do not have command queueing implemented server side, which is why some of your inputs may occasionally get lost in the heat of battle, especially with higher latency.</p>

<p>So far we have implemented a lot of the foundation, which allows most powers that deal direct damage to enemies to function, but there is still a lot of work left to do, including:</p>

<ul>
  <li>
    <p>Various additional aspects of payload processing, including taking the target’s defensive properties into account, paying resource costs, and more. The current implementation is a very simplified one based on formulas the client uses to calculate tooltip damage.</p>
  </li>
  <li>
    <p>Hidden damage scaling mechanics: dynamic combat level (DCL) and scaling player damage output based on the total number of players in proximity.</p>
  </li>
  <li>
    <p>Implementations for the rest of power event triggers and actions.</p>
  </li>
  <li>
    <p>Avatar power activation priority queue.</p>
  </li>
  <li>
    <p>Condition (buff and debuff) application and removal, including those that deal damage over time (DoTs).</p>
  </li>
  <li>
    <p>Hotspot powers. Hotspots are zones that apply certain effects when entities stand in them, such as fire that deals damage when you stand in it.</p>
  </li>
  <li>
    <p>Procs.</p>
  </li>
  <li>
    <p>Summon powers.</p>
  </li>
</ul>

<p>For now though we have enough of this system working to have the game feel like a real game again, especially when combined with the AI implementation by AlexBond.</p>

<h2 id="loot-tables-for-dummies">Loot Tables for Dummies</h2>

<p>While it is nice to be able to smash things and beat bad guys, the core thing that makes you do it again and again in games like these is the loot. Although we did have a placeholder system put in place last month, I felt this aspect started falling behind, especially with how authentic the rest of the game is now looking.</p>

<p>We are extremely lucky to have all the original loot tables in the client. The underlying loot system is very complex, but this month I have made significant progress in untangling it. Although items still lack affixes and stats, their rarities and base types should now be accurate, making the lootsplosions from defeating bosses way more satisfying. So how does it all work?</p>

<p>Although they are called loot “tables”, they are actually tree structures consisting of <code class="language-plaintext highlighter-rouge">LootNodePrototype</code> instances. Each node can be either a <code class="language-plaintext highlighter-rouge">LootTablePrototype</code> or a <code class="language-plaintext highlighter-rouge">LootDropPrototype</code>. Here is what a typical “loot table” looks like:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/loot-table.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/loot-table.png" alt="Loot Tables" /></a></p>

<p>When you want to use a loot table, you recursively iterate through the nodes of this tree, with each “table” representing a branch and “drops” representing end points that get recorded (more on that later). Visiting a node is referred to as <em>selecting</em> it, and activating the node is called <em>rolling</em>.</p>

<p>When you select a loot table node, it gets rolled one or more times, with each roll determining branches to go down to. When rolling loot tables the game uses the concept of <em>nodrop</em> similar to <em>Diablo II</em>: rather than specifying the drop chance of something, instead each table node has a <em>nodrop chance</em> defined that determines whether or not the table will be skipped entirely. So a 1% drop chance is represented as a 99% nodrop chance. If the roll passes this nodrop chance check, branches of the table are picked using one of three methods:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickWeight</code>: picks one of the branch nodes randomly based on their defined weight.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickWeightTryAll</code>: excludes branch nodes randomly based on their weight until only one remains, which gets picked.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickAll</code>: picks all branch nodes.</p>
  </li>
</ul>

<p>Picked nodes are selected and rolled, and this process continues recursively until it reaches a loot drop node.</p>

<p>In total there are 17 different types of loot drop nodes representing various things that can “drop”. The most obvious and widely-used one is <code class="language-plaintext highlighter-rouge">LootDropItemPrototype</code> that represents an item dropping. There is also <code class="language-plaintext highlighter-rouge">LootDropAgentPrototype</code> used for spawning entities, like health and experience orbs, that are actually implemented as AI-controlled agent entities rather than items. But just like it was with inventories, the definition of a “drop” is quite broad here: there are drop nodes such as <code class="language-plaintext highlighter-rouge">LootDropPlayVisualEffectPrototype</code>, <code class="language-plaintext highlighter-rouge">LootDropChatMessagePrototype</code>, and <code class="language-plaintext highlighter-rouge">LootDropBannerMessagePrototype</code> that are more like actions triggered by rolling rather than representations of physical things that you can pick up.</p>

<p>As you navigate a loot tree and reach various drop nodes, you need to record your journey to make use of it later. For this the game uses an abstract <code class="language-plaintext highlighter-rouge">IItemResolver</code> interface class the gets implemented by various systems that need to interact with loot tables. Successfully rolled drop nodes are “pushed” onto the resolver, and the accumulated data from the resolver is then used to spawn rolled items in the world, add them to an inventory, or just output the results as text for testing.</p>

<p>One last essential piece of the loot table puzzle are <em>loot roll modifiers</em>. When you interact with a loot table tree you also pass to it an instance of <code class="language-plaintext highlighter-rouge">LootRollSettings</code> that contains the context, from obvious things, such as level and difficulty tier, to more esoteric factors, such as the current day of the week. Each node in the tree can then have modifiers that process and/or override these settings. One of the simplest examples would be filtering drops based on level range. But you can also, for instance, override the current avatar and always drop items for somebody else. Or you could have the rare item find stat apply to an arbitrary selection of items. When modifiers are applied to a drop node they affect only that drop node, but when they are applied to a table node, the affect all branches of that table. This is how, for example, eternity splinters drops are controlled: splinters have their own branches in common loot tables with applied modifiers.</p>

<p>And with all of that we have basic loot table rolling working. We still have work to do, including implementing all the special drop types, additional modifiers, and some more drop processing, such as taking item quality bonuses into account and applying affixes to items, but the foundation is now in place. If only we could have our loot persist when we transfer between regions and log out…</p>

<h2 id="the-barrel-made-me-do-it">The Barrel Made Me Do It</h2>

<p><em>AlexBond is back yet again this month to talk about AI profile overriding.</em></p>

<hr />

<p>Hey everyone, this is AlexBond. Let the combat begin! In this report I would like to share how I enabled AI and brought all the enemies in the game to life.</p>

<p>This month there were a lot of major updates: enemies and bosses now attack and deal damage, and the game is really starting to come to live. But let’s talk about how it all works.</p>

<p>Enemy movement uses the <code class="language-plaintext highlighter-rouge">AIController</code> class that I already covered in previous reports. This time I would I would like to talk about <code class="language-plaintext highlighter-rouge">AIOverride</code> and how it is used.</p>

<h3 id="ai-override">AI Override</h3>

<p>An agent’s prototype generally specifies its AI profile that defines its behavior. All attack-based AI profiles (<code class="language-plaintext highlighter-rouge">ProceduralProfileWithAttackPrototype</code>) function in two modes:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DefaultSensory</code> - scanning mode (based on <code class="language-plaintext highlighter-rouge">BehaviorSensorySystem</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">HandleContext</code> - action mode</p>
  </li>
</ul>

<p>Scanning involves searching for a target. If no target is found using <code class="language-plaintext highlighter-rouge">SelectTargetEntity()</code>, the AI profile is overriden with a <code class="language-plaintext highlighter-rouge">NoTargetOverrideProfile</code>. Usually it is <code class="language-plaintext highlighter-rouge">ProceduralProfileDefaultActiveOverridePrototype</code> that makes the agent wander around (<code class="language-plaintext highlighter-rouge">WanderInPlace</code>) or return to its spawn location (<code class="language-plaintext highlighter-rouge">Wander</code>). While doing so it continues scanning its surroundings, and if it finds an enemy, it switches to the attack profile.</p>

<p>But it gets more complicated. Enemies created via a <code class="language-plaintext highlighter-rouge">PopulationObject</code> contain an <code class="language-plaintext highlighter-rouge">EntitySelector</code>, which has another AI override called <code class="language-plaintext highlighter-rouge">DefaultBrainOnSimulated</code> that uses <code class="language-plaintext highlighter-rouge">ProceduralProfileSenseOnly</code></p>

<p>The basic idea of this profile is that instead of wandering or attacking, it simply plays an idle animation (such as NPCs talking to each other), and when a player enters its scanning radius, it switches to one of the talking profiles. Generally it picks a random profile from the <code class="language-plaintext highlighter-rouge">AIOverrides</code> list:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-1.png" alt="AI 1" style="max-height: 400px;" /></a>
</center>

<p>All of these switches are controlled by the <code class="language-plaintext highlighter-rouge">ProcessEntityAction()</code> function.</p>

<p>So when you see an NPC talking or calling you, this happens via complex AI profile switching.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-2.jpg" alt="AI 2" style="max-height: 400px;" /></a>
</center>

<p>This is how previously silent NPCs learned how to speak.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-3.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-3.jpg" alt="AI 3" /></a></p>

<p>As for combat, Crypto did a lot of work here by implementing the power system. I assisted with implementing <code class="language-plaintext highlighter-rouge">MissilePower</code>, since it involves AI, and I am quite familiar with this topic.</p>

<p>This game has so many AI profiles, and it is hard to see them at first glance. For example, drops lying on the ground, such as orbs, are not pulled by some kind of magnetic force. Instead, they all have follow target AI profiles, with your avatar being that target. Every moving entity in the game is “alive”. This includes projectiles, such as Captain America’s shield, Thor’s hammer, or Iron Man’s micro-missiles - all of them are moved using AI profiles. But it gets more interesting!</p>

<p>You may remember bosses or other powerful enemies picking objects up and throwing them at you. You think this is because the boss’s AI is so smart? Wrong answer! Actually, throwable objects themselves have brains!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-4.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-4.jpg" alt="AI 4" /></a></p>

<p>Yes, I am not joking, every single one of Mr. Hyde’s barrels has its own brain!</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-5.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-5.png" alt="AI 5" style="max-height: 400px;" /></a>
</center>

<p>Every 10 seconds the barrel, just like Emma Frost, attempts to take control of its owner, Mr. Hyde, and override his AI behavior profile. And the boss takes orders from this barrel, picks it up, and throws it at the avatar. Entities that act like this have their own class - <code class="language-plaintext highlighter-rouge">ThrowableSmartProp</code>.</p>

<p>There are not too many of them in the game, and they still do not function completely right, but now you know that when the Hulk boss in Holo-Sim picks up a car, he was forced to do so by the car itself!</p>

<p>Overriding AI profiles is a complicated process, and I am still working on it. For instance, timing the activation of the appropriate AI profile when an entity enters the world and/or starts being simulated still has a lot issues, which is why some of the idle animations got replaced with wandering. In the future we will come back and fix these issues. For now I am working on missions, which also involves some AI overriding and idle animation playaback via <code class="language-plaintext highlighter-rouge">MissionActionEntityPerformPower()</code>, but this is a story for another report. That’s it for now, have fun playing, and until the next report!</p>

<hr />

<p>Back to work now. See you in August!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: June 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: June 2024" /><published>2024-06-30T04:20:00+03:00</published><updated>2024-06-30T04:20:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-06/header.jpg" alt="MHServerEmu Progress Report - June 2024" /></p>

<p>June has been jam-packed full of developments, and we have a lot to cover.</p>

<h2 id="mhserveremu-2-electric-boogaloo">MHServerEmu 2: Electric Boogaloo</h2>

<p>This month we released the second stable release of MHServerEmu - <a href="https://github.com/Crypto137/MHServerEmu/releases/tag/0.2.0">version 0.2.0</a>. This release contains all the backend work we had been working on since <a href="/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html">March</a>, including, but not limited to:</p>

<ul>
  <li>
    <p>General server architecture improvements.</p>
  </li>
  <li>
    <p>An overhaul of the serialization system.</p>
  </li>
  <li>
    <p>An implementation of navi, locomotion, and physics systems.</p>
  </li>
  <li>
    <p>An overhaul of the entity management system.</p>
  </li>
  <li>
    <p>An implementation of the inventory system.</p>
  </li>
  <li>
    <p>An implementation of the game event system.</p>
  </li>
  <li>
    <p>A significantly upgraded version of the area of interest system.</p>
  </li>
  <li>
    <p>Most of the backend for the AI system.</p>
  </li>
</ul>

<p>We have barely scratched the surface of what is now possible. One significant improvement that happened almost as a side effect of all of this is that now you can see and interact with other players in the game world.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/multiplayer.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/multiplayer.jpg" alt="Multiplayer" /></a></p>

<p>And in just a few days we were able to build a very rough early iteration of the loot system (<em>disclaimer: quantity exaggerated for dramatic purposes, may not match what you see in the final product</em>):</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/loot.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/loot.jpg" alt="Loot" /></a></p>

<p>As soon as 0.2.0 was out, we started work on version 0.3.0. Our current tentative target for its release is September 2024, but you can check out all the latest features we are working on early via <a href="https://nightly.link/Crypto137/MHServerEmu/workflows/nightly-release-windows-x64/master?preview">nightly builds</a> or by building the source code yourself. Now that a significant bulk of the backend work is out of the way, we can focus more on aspects you can actually see in the game. One good example of this you can check out yourself right now in nightly 0.3.0 builds is an early iteration of pets and team-ups that rely on navi, locomotion and AI systems for pathfinding, physically moving around, and being aware that they need to follow their owner respectively.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pets.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pets.jpg" alt="Pets" /></a></p>

<h2 id="i-am-running-out-of-interesting-puns">I Am Running Out of Interesting Puns</h2>

<p>This month our implementation of the area of interest (AOI) system received a major upgrade, which literally made visible the results of our work on other systems. Now that it is mostly working, we can dive deeper into the specifics.</p>

<p>First, a quick recap. Marvel Heroes is a server-authoritative game, meaning the entire game simulation (where everything is, what powers everyone is using, how much health everyone has, and so on) runs on the server. The server is the ultimate dungeon master, aware of everything happening to everyone. The client program you are using to play the game also has a simulation of its own that runs in parallel based on the data it receives from the server. However, the data clients receive is just a small slice of the overall server pie, and each client’s slice if referred to as its area of interest.</p>

<p>Putting it into more concrete terms, the <code class="language-plaintext highlighter-rouge">AreaOfInterest</code> class in the server code determines what data needs to go to the client it is bound to and keeps track of things the client is already aware of. The data managed by AOI can be separated into two categories: environment (a region with its areas and cells) and entities (game objects that populate the region).</p>

<p>Everything starts with entities. When a client logs into a game server, a <code class="language-plaintext highlighter-rouge">Player</code> entity is created for it that gets bound to an <code class="language-plaintext highlighter-rouge">AreaOfInterest</code> instance. This entity does not physically exist in the game world and is used to represent the player’s account: what heroes are unlocked, how much of each currency there is, when was the last time this player logged in, and so on. Hero and team-up unlocks are internally represented as “items” held in various hidden inventories, such as <code class="language-plaintext highlighter-rouge">PlayerAvatarLibrary</code> and <code class="language-plaintext highlighter-rouge">PlayerTeamUpLibrary</code> (see <a href="/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html">the previous report</a> for more on that).</p>

<p>This player entity is automatically <em>considered</em> by the area of interest it is bound to. Consideration is a process of determining what (if any) <em>interest policies</em> (also referred to as <em>replication channels</em>) a specific entity has in relation to an area of interest. If an area of interest determines that an entity matches one or more interest policies, it starts tracking the entity and notifies the client by sending network messages containing information about this entity. The client uses this information to create a copy of this entity in its local simulation. When an entity loses all of its replication policies, it is removed from the AOI and the client simulation. In addition to player entity creation, consideration can be triggered by other events, such moving around the game world, but more on that later.</p>

<p>In total there are five possible replication policies: <code class="language-plaintext highlighter-rouge">Owner</code>, <code class="language-plaintext highlighter-rouge">Proximity</code>, <code class="language-plaintext highlighter-rouge">Discovery</code>, <code class="language-plaintext highlighter-rouge">Party</code>, and <code class="language-plaintext highlighter-rouge">Trader</code>. When the player entity is considered by its AOI, it always enters it with the <code class="language-plaintext highlighter-rouge">Owner</code> policy. Then, the AOI recursively considers all entities stored in the player’s various inventories, which is how avatars and team-ups owned by the player with all of their equipment enter the AOI. Entities that enter the AOI by being present in the player entity’s inventories also have the <code class="language-plaintext highlighter-rouge">Owner</code> interest policy.</p>

<p>With this initialization step done, the server proceeds to put one of the player’s avatars at a specific <code class="language-plaintext highlighter-rouge">RegionLocation</code>, which includes a region instance id, coordinates within this region instance, and the initial orientation of the avatar. The AOI scans the environment within a certain radius around this location to determine what cells the client needs to load. The server then sends a message packet that instructs the client to put up a loading screen and load all determined cells. For every loaded cell the client sends a notification message to the server. The server tracks these notifications, and when all requested cells are loaded, it instructs the client to remove the loading screen, and player’s selected avatar enters the world at the required region location.</p>

<p>When the avatar enters world, it and everything within a certain radius is considered for a <code class="language-plaintext highlighter-rouge">Proximity</code> policy. Some entities do not get the <code class="language-plaintext highlighter-rouge">Proximity</code> policy despite being physically near the player’s avatar in the game world. One good example of this is loot, which is restricted to the player it dropped for until it is picked up. As the player’s avatar moves around the game world, the AOI periodically scans the proximity to determine cells and entities that need to be added or removed.</p>

<p>Here is what it looks like if we artificially reduce the proximity radius:</p>

<div><video controls="" width="100%" /><source src="/MHServerEmu/assets/blog/progress-report/2024-06/proximity.webm" type="video/webm" /></div>

<p>When entities in proximity are considered, the contents of their inventories are considered in a similar fashion to the player, and there is a set of conditions that determines when an entity stored in an inventory can enter an area of interest. This is what ultimately allows you to see items equipped on nearby players, such as their costumes and artifacts with fancy visual effects, while avoiding the necessity of loading items stored in their stashes like a certain other game.</p>

<p>In some cases when an entity enters proximity and/or satisfies some other condition, it also gains a <code class="language-plaintext highlighter-rouge">Discovery</code> policy, which allows it to remain in the client’s simulation even after it leaves proximity. For example, this is how the client can draw map icons for NPCs and waypoints even when they are no longer in proximity.</p>

<p>There are two special cases that have their own replication policies: <code class="language-plaintext highlighter-rouge">Party</code> and <code class="language-plaintext highlighter-rouge">Trade</code>. What makes them different from the other three is that they are the only cases when player entities belonging to other clients can enter your area of interest. We are still investigating the specifics of them, and we will talk more about this in a future report when we get to work on various social features.</p>

<p>Interest policies play an important role in the serialization process. For example, world entity power collections are omitted unless they have the <code class="language-plaintext highlighter-rouge">Proximity</code> policy, and some properties are added or removed based on changing policies. The latter one was the cause of one of the issues we had to solve when implementing team-up spawning. For some reason, the client failed to recognize team-ups as belonging to the current avatar and did not display a green circle indicator under them that should look like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/teamup.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/teamup.jpg" alt="Team-Up" /></a></p>

<p>As it turned out, the issue was that the property that the client uses to determine this ownership relation, <code class="language-plaintext highlighter-rouge">PowerUserOverrideID</code>, is compatible only with <code class="language-plaintext highlighter-rouge">Proximity</code> and <code class="language-plaintext highlighter-rouge">Trader</code> policies, and it is filtered out in other cases. Because team-ups are initially added to the AOI and serialized to the client with just the <code class="language-plaintext highlighter-rouge">Owner</code> policy during initial loading, this property was not included. The solution was to implement handling for the interest policy change event on the server to automatically send newly revealed properties to the client when existing entities in its AOI gain new interest policies.</p>

<p>While there is still some work to do on this system, at this stage it is already capable of performing its most essential operations that allows it to act as a window to what is happening on the server for the client.</p>

<h2 id="time-is-of-the-essence">Time is of the Essence</h2>

<p>Another important area where we have recently had significant advancements is game simulation timing and event scheduling. We first started seriously considering this <a href="/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html">back in April</a>, and are now at a point where we are approaching client-accuracy.</p>

<p>As we were researching this, we discovered an intricate system of numerous clocks that would fit right in at Dr. Emmett Brown’s lab.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/3isQI0nXQRE" frameborder="0" allowfullscreen=""></iframe></div>

<p>In total there are five clocks that are actively used, and we had to add a sixth one to the mix for compatibility with .NET.</p>

<ul>
  <li>
    <p><strong>.NET DateTime</strong> - a point in time from <code class="language-plaintext highlighter-rouge">January 1, 1</code> to <code class="language-plaintext highlighter-rouge">December 31, 9999</code>. This is the default date time format used by C# that you get from <code class="language-plaintext highlighter-rouge">DateTime.Now</code> and <code class="language-plaintext highlighter-rouge">DateTime.UtcNow</code>.</p>
  </li>
  <li>
    <p><strong>DateTime</strong> - the number of microseconds since <code class="language-plaintext highlighter-rouge">January 1, 1970</code>. Also known as Unix time.</p>
  </li>
  <li>
    <p><strong>CoreGameTime</strong> - the number of microseconds since <code class="language-plaintext highlighter-rouge">September 22, 2012 09:31:18 GMT+0000</code>. This epoch is not arbitrary: the game’s closed beta began on <code class="language-plaintext highlighter-rouge">October 1, 2012</code>, and this point in time must have been when the development team was making final preparations. In a way, this is the game’s true birthday.</p>
  </li>
  <li>
    <p><strong>RealGameTime</strong> - the number of microseconds in full fixed time frames since <code class="language-plaintext highlighter-rouge">September 22, 2012</code>. More on that later.</p>
  </li>
  <li>
    <p><strong>Game.CurrentTime</strong> - the current time step of the game simulation.</p>
  </li>
  <li>
    <p><strong>GameEventScheduler.CurrentTime</strong> - the current game simulation time adjusted for the currently executing scheduled event. This is the clock used by most of the gameplay logic. If <code class="language-plaintext highlighter-rouge">GameEventScheduler</code> is not available, it falls back to <code class="language-plaintext highlighter-rouge">Game.CurrentTime</code>.</p>
  </li>
</ul>

<p>Let’s unwrap what is happening here step by step.</p>

<p>During server initialization we query system time with <code class="language-plaintext highlighter-rouge">DateTime.UtcNow</code> to get a timestamp of the initialization time. For performance and accuracy reasons, rather than querying system time each time the game wants to know what time it is, we create and start a <code class="language-plaintext highlighter-rouge">Stopwatch</code> class instance when we query the initialization timestamp. When time is requested, we add elapsed time from the stopwatch to our timestamp and convert it to <code class="language-plaintext highlighter-rouge">DateTime</code> or <code class="language-plaintext highlighter-rouge">CoreGameTime</code>. With that we have half of our required clocks taken care of.</p>

<p><code class="language-plaintext highlighter-rouge">RealGameTime</code> is represented using a class called <code class="language-plaintext highlighter-rouge">FixedQuantumGameTime</code>. Behind this sci-fi sounding name we have basically a less accurate version of <code class="language-plaintext highlighter-rouge">CoreGameTime</code> that advances in fixed intervals, which in our case are 50 ms.</p>

<p>When the game does the <code class="language-plaintext highlighter-rouge">UpdateFixedTime()</code> stage of the update loop, which handles time-sensitive processing such as physics and timers, it synchronizes the value of <code class="language-plaintext highlighter-rouge">RealGameTime</code> by calling the <code class="language-plaintext highlighter-rouge">FixedQuantumGameTime.UpdateToNow()</code> method that does something along these lines:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get current CoreGameTime and time step length.</span>
<span class="n">TimeSpan</span> <span class="n">gameTime</span> <span class="p">=</span> <span class="n">Clock</span><span class="p">.</span><span class="n">GameTime</span><span class="p">;</span>
<span class="n">TimeSpan</span> <span class="n">quantumSize</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="m">50</span><span class="p">);</span>

<span class="c1">// Calculate the total number of steps.</span>
<span class="c1">// Because Ticks are integers, we lose the remainder</span>
<span class="c1">// of the division and get a nice round number.</span>
<span class="kt">long</span> <span class="n">numTimeQuantums</span> <span class="p">=</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">Ticks</span> <span class="p">/</span> <span class="n">quantumSize</span><span class="p">.</span><span class="n">Ticks</span><span class="p">;</span>

<span class="c1">// Get a new TimeSpan representing the number of full steps.</span>
<span class="n">TimeSpan</span> <span class="n">realGameTime</span> <span class="p">=</span> <span class="n">quantumSize</span> <span class="p">*</span> <span class="n">numTimeQuantums</span>
</code></pre></div></div>

<p>The game then advances its <code class="language-plaintext highlighter-rouge">CurrentTime</code> in 50 ms intervals until it catches up to <code class="language-plaintext highlighter-rouge">RealGameTime</code>. For every time its clock advances, the game calls <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code> once. When everything is going smoothly and there are no time-consuming tasks running, like region generation, an <code class="language-plaintext highlighter-rouge">UpdateFixedTime()</code> call should do only a single <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code>. To keep the simulation from being stuck in an endless loop in situations where it for some reason cannot keep up, there is an additional check that breaks the loop when it exceeds the expected frame time of 50 ms.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// _gameTimer is a Stopwatch instance that starts with the game.</span>
<span class="n">TimeSpan</span> <span class="n">updateStartTime</span> <span class="p">=</span> <span class="n">_gameTimer</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">_currentGameTime</span> <span class="p">+</span> <span class="n">FixedTimeBetweenUpdates</span> <span class="p">&lt;=</span> <span class="n">RealGameTime</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_currentGameTime</span> <span class="p">+=</span> <span class="n">FixedTimeBetweenUpdates</span><span class="p">;</span>

    <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>

    <span class="c1">// Bail out if we have exceeded the frame budget</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_gameTimer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">-</span> <span class="n">updateStartTime</span> <span class="p">&gt;</span> <span class="n">FixedTimeBetweenUpdates</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything up until this point has been relatively straightforward, but now the real time shenanigans begin. During <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code> the reins are partially handed over to the <code class="language-plaintext highlighter-rouge">GameEventScheduler</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">DoFixedTimeUpdate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Current simulation time is passed as an argument</span>
    <span class="n">GameEventScheduler</span><span class="p">.</span><span class="nf">TriggerEvents</span><span class="p">(</span><span class="n">_currentGameTime</span><span class="p">);</span>
    <span class="c1">// Everything else</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In fact, <code class="language-plaintext highlighter-rouge">GameEventScheduler</code>’s clock has priority over the game’s when current time is requested by various systems:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">CurrentTime</span> <span class="p">{</span> <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">GameEventScheduler</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">?</span> <span class="n">GameEventScheduler</span><span class="p">.</span><span class="n">CurrentTime</span> <span class="p">:</span> <span class="n">_currentGameTime</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>So what does <code class="language-plaintext highlighter-rouge">EventScheduler</code> do? Essentially, it allows the game to set up timers and trigger actions when they expire. You provide it with with a <code class="language-plaintext highlighter-rouge">TimeSpan</code> representing a delay before something should happen and an object representing the callback that needs to be executed, and it does everything else.</p>

<p>Believe it or not, this system appears to be an evolution of a similar system from <em>Diablo II</em>. Take a look at this code snippet from the <a href="https://github.com/ThePhrozenKeep/D2MOO">D2MOO</a> decompilation project:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AI think delay setup</span>
<span class="kt">int32_t</span> <span class="n">nAiDelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pGame</span><span class="o">-&gt;</span><span class="n">nGameType</span> <span class="o">||</span> <span class="n">pGame</span><span class="o">-&gt;</span><span class="n">dwGameType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get delay for the current difficulty from MonStats.txt</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="n">pMonStatsTxtRecord</span><span class="o">-&gt;</span><span class="n">nAIdel</span><span class="p">[</span><span class="n">pGame</span><span class="o">-&gt;</span><span class="n">nDifficulty</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// Fall back to normal difficulty</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="n">pMonStatsTxtRecord</span><span class="o">-&gt;</span><span class="n">nAIdel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Fall back to the default delay value</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nAiDelay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Schedule the next think event</span>
<span class="n">EVENT_SetEvent</span><span class="p">(</span><span class="n">pGame</span><span class="p">,</span> <span class="n">pModeChange</span><span class="o">-&gt;</span><span class="n">pUnit</span><span class="p">,</span> <span class="n">UNITEVENTCALLBACK_AITHINK</span><span class="p">,</span> <span class="n">nAiDelay</span> <span class="o">+</span> <span class="n">pGame</span><span class="o">-&gt;</span><span class="n">dwGameFrame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Diablo II’s timing is completely frame-based with the game running at a constant framerate of 25 Hz. The code in this example retrieves the monster AI think delay value from a data file (<code class="language-plaintext highlighter-rouge">MonStats.txt</code>) and schedules a think event. At 25 FPS each frame is going to take <code class="language-plaintext highlighter-rouge">1000 / 25 = 40 ms</code>, meaning this delay will take <code class="language-plaintext highlighter-rouge">15 * 40 = 600 ms</code>. At Nightmare and Hell difficulty modes this delay is <code class="language-plaintext highlighter-rouge">14 * 40 = 560 ms</code> and <code class="language-plaintext highlighter-rouge">13 * 40 = 520 ms</code> respectively.</p>

<p>And here is reverse engineered code that does the equivalent in Marvel Heroes:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">Think</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">float</span> <span class="n">thinkTime</span> <span class="p">=</span> <span class="m">500</span><span class="p">;</span> <span class="c1">// slow think </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TargetEntity</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">||</span> <span class="n">AssistedEntity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">thinkTime</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span> <span class="c1">// fast think</span>
    <span class="nf">ScheduleAIThinkEvent</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="n">thinkTime</span><span class="p">)</span> <span class="p">*</span> <span class="n">Game</span><span class="p">.</span><span class="n">Random</span><span class="p">.</span><span class="nf">NextFloat</span><span class="p">(</span><span class="m">0.9f</span><span class="p">,</span> <span class="m">1.1f</span><span class="p">));</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">ScheduleAIThinkEvent</span><span class="p">(</span><span class="n">TimeSpan</span> <span class="n">timeOffset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Various checks and additional variation</span>
    <span class="c1">// for the offset happening here are omitted.</span>

    <span class="n">eventScheduler</span><span class="p">.</span><span class="nf">ScheduleEvent</span><span class="p">(</span><span class="n">_thinkEvent</span><span class="p">,</span> <span class="n">nextThinkTimeOffset</span><span class="p">,</span> <span class="n">_pendingEvents</span><span class="p">);</span>
    <span class="n">_thinkEvent</span><span class="p">.</span><span class="nf">Get</span><span class="p">().</span><span class="n">OwnerController</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Diablo II’s units are now called entities, Excel .txt files became prototypes, and instead of the number of frames we provide a <code class="language-plaintext highlighter-rouge">TimeSpan</code> as an argument for scheduling an event. The “slow thinking mode” is pretty much equivalent to the thinking rate from Diablo II. And this is not where similarities end: internally, <code class="language-plaintext highlighter-rouge">EventScheduler</code> still operates based on frames, just like Diablo II.</p>

<p>All scheduled events are grouped by “buckets”, with each bucket representing a frame. When an event is scheduled, it is put into a bucket based on the current time and requested delay, and its precise fire time is recorded.</p>

<p>When the <code class="language-plaintext highlighter-rouge">TriggerEvents()</code> method is called from <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code>, the event scheduler advances its clock in fixed time steps until it catches up to the <code class="language-plaintext highlighter-rouge">_currentGameTime</code> that was passed as an argument, and each time it advances it executes all events in the bucket corresponding to the frame. Here is what a simplified version of this code looks like:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Determine time window</span>
<span class="kt">long</span> <span class="n">startFrame</span> <span class="p">=</span> <span class="n">CurrentTime</span><span class="p">.</span><span class="nf">CalcNumTimeQuantums</span><span class="p">(</span><span class="n">_quantumSize</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">endFrame</span> <span class="p">=</span> <span class="n">updateEndTime</span><span class="p">.</span><span class="nf">CalcNumTimeQuantums</span><span class="p">(</span><span class="n">_quantumSize</span><span class="p">);</span>

<span class="c1">// Process all frames that are within our time window</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="p">=</span> <span class="n">startFrame</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">endFrame</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">ScheduledEvent</span> <span class="n">@event</span> <span class="k">in</span> <span class="n">_buckets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="c1">// Set event scheduler's time to the precise event fire time</span>
        <span class="n">CurrentTime</span> <span class="p">=</span> <span class="n">@event</span><span class="p">.</span><span class="n">FireTime</span><span class="p">;</span>

        <span class="c1">// Invalidate event</span>
        <span class="n">_scheduledEvents</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">@event</span><span class="p">);</span>
        <span class="n">@event</span><span class="p">.</span><span class="n">EventGroupNode</span><span class="p">?.</span><span class="nf">Remove</span><span class="p">();</span>
        <span class="n">@event</span><span class="p">.</span><span class="nf">InvalidatePointers</span><span class="p">();</span>

        <span class="c1">// Run event callback</span>
        <span class="n">@event</span><span class="p">.</span><span class="nf">OnTriggered</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Synchronize time with the game</span>
<span class="n">CurrentTime</span> <span class="p">=</span> <span class="n">currentGameTime</span><span class="p">;</span>
</code></pre></div></div>

<p>Before the event scheduler triggers an event, it sets its clock to the precise time when the event is supposed to be fired. And because <code class="language-plaintext highlighter-rouge">Game.CurrentTime</code> returns the value of <code class="language-plaintext highlighter-rouge">GameEventScheduler.CurrentTime</code>, any game logic that runs as a result of the event callback is going to have precise time despite the simulation advancing in 50 ms steps.</p>

<p>But here is the crazy thing: as far as I can tell, events within their frame buckets are not sorted by fire time. Therefore, it is possible for the time to go <em>backwards</em>, although only within the confines of a single frame. Which in a way makes sense: events happening within the same frame are batched together and happen “simultaneously”, so the execution order here is not critical. The main potential problem would be inconsistent timing due to an event callback potentially scheduling another event, but because time is always set to the precise fire time, it’s going to remain consistent.</p>

<p>RIght now we have most of this system working, with the exception of the bucket management system. As a temporary solution we are storing all events in a single collection that we iterate to determine the events that would go in the bucket we would be processing, which is not ideal for performance, but it does the job well enough for now. The API for the system is pretty much done, and we can worry about optimizing internal implementation later.</p>

<p>And this is how time in Marvel Heroes works.</p>

<h2 id="finding-a-path-forward">Finding a Path Forward</h2>

<p><em>AlexBond is back again this month to talk about his work on pathfinding and AI.</em></p>

<hr />

<p>Hello, it’s AlexBond again. In this report I would like to talk about how AI works and the <code class="language-plaintext highlighter-rouge">NaviPath</code> generation process.</p>

<h3 id="aicontroller">AIController</h3>

<p>For an agent’s AI to work, the agent needs to enter the simulation using <code class="language-plaintext highlighter-rouge">SetSimulated()</code>, and its AI controller needs to be activated. (<em>Editor’s note: “agent” is the term the game uses to refer to world entities that can interact with the game world, such as avatars, enemies, team-ups, and so on</em>).</p>

<p>AI controller activation happens when an agent enters the game world, in the <code class="language-plaintext highlighter-rouge">OnEnteredWorld()</code> function: if the agent has a defined <code class="language-plaintext highlighter-rouge">BehaviorProfile</code>, an <code class="language-plaintext highlighter-rouge">AIController</code> instance is created. <code class="language-plaintext highlighter-rouge">AIController</code> consists of three main parts:</p>

<ul>
  <li>
    <p><strong>Brain</strong> - a behavior profile for the <code class="language-plaintext highlighter-rouge">ProceduralAI</code> system.</p>
  </li>
  <li>
    <p><strong>Senses</strong> - a class for determining potential allies and enemies that scans everyone every second in the defined <code class="language-plaintext highlighter-rouge">AggroRange</code>.</p>
  </li>
  <li>
    <p><strong>Blackboard</strong> - AI’s memory where temporary state is stored in the form of a <code class="language-plaintext highlighter-rouge">PropertyCollection</code>, as well as various vectors.</p>
  </li>
</ul>

<p>The main function of a controller is <code class="language-plaintext highlighter-rouge">Think()</code>. To keep server load in check, this function runs via a scheduled event every 90-110 ms in the “fast” thinking mode and every 450-500 ms in the “slow” thinking mode. When it runs, it activates the <code class="language-plaintext highlighter-rouge">Brain</code> and runs commands defined in the AI profile. AI profiles include some state logic and defines behavior templates for each state.</p>

<p>Let’s take a look at a concrete example - the think function for <code class="language-plaintext highlighter-rouge">ProceduralProfileVanityPetPrototype</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Think</span><span class="p">(</span><span class="n">AIController</span> <span class="n">ownerController</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Guard checks omitted</span>
    <span class="n">ProceduralAI</span> <span class="n">proceduralAI</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Brain</span><span class="p">;</span>
    <span class="n">Agent</span> <span class="n">agent</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Agent</span><span class="p">;</span>
    <span class="n">WorldEntity</span> <span class="n">master</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">AssistedEntity</span><span class="p">;</span>
    <span class="n">Game</span> <span class="n">game</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">Game</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">master</span><span class="p">.</span><span class="n">IsInWorld</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">distanceToMasterSq</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">DistanceSquared2D</span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">master</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distanceToMasterSq</span> <span class="p">&gt;</span> <span class="n">MaxDistToMasterBeforeTeleportSq</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Teleport to master</span>
            <span class="nf">HandleContext</span><span class="p">(</span><span class="n">proceduralAI</span><span class="p">,</span> <span class="n">ownerController</span><span class="p">,</span> <span class="n">TeleportToMasterIfTooFarAway</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Move normally</span>
    <span class="nf">HandleMovementContext</span><span class="p">(</span><span class="n">proceduralAI</span><span class="p">,</span> <span class="n">ownerController</span><span class="p">,</span> <span class="n">agent</span><span class="p">.</span><span class="n">Locomotor</span><span class="p">,</span> <span class="n">PetFollow</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First, the pet determines its <em>master</em> (<code class="language-plaintext highlighter-rouge">AssistedEntity</code>) and the distance between them. If this distance exceeds the defined value, the pet teleports using <code class="language-plaintext highlighter-rouge">HandleContext()</code>. Then movement is initiated using <code class="language-plaintext highlighter-rouge">HandleMovementContext()</code>.</p>

<p><code class="language-plaintext highlighter-rouge">HandleMovementContext()</code> sets the state to <code class="language-plaintext highlighter-rouge">MoveTo</code>, which consists of four stages:</p>

<ul>
  <li>
    <p>Validate</p>
  </li>
  <li>
    <p>Start</p>
  </li>
  <li>
    <p>Update</p>
  </li>
  <li>
    <p>End</p>
  </li>
</ul>

<p>The agent then receives a command based on the settings defined in the <code class="language-plaintext highlighter-rouge">ContextPrototype</code>. In our vanity pet example this command is simply generating a path to <code class="language-plaintext highlighter-rouge">AssistedEntity</code>.</p>

<h3 id="generatepath">GeneratePath</h3>

<p>Path generation begins inside the <code class="language-plaintext highlighter-rouge">Locomotor</code> class. First, it disables <em>influence points</em> for <em>owner</em> (the pet) and <em>other</em> (the avatar) by calling the <code class="language-plaintext highlighter-rouge">DisableNavigationInfluence()</code> method. It then proceeds to the generation process itself - <code class="language-plaintext highlighter-rouge">GeneratePathInternal()</code>.</p>

<p>This process consists of three main steps:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">GeneratePathStep()</code> - we scan all <code class="language-plaintext highlighter-rouge">NaviTriangle</code> instances near the <em>startTriangle</em> until we find our destination - <em>goalTriangle</em>. All steps are recorded in <em>genPathState</em>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FunnelStep()</code> - a hard to understand algorithm, the goal of which is to remove unnecessary <code class="language-plaintext highlighter-rouge">NaviPoint</code> instances and determine <code class="language-plaintext highlighter-rouge">NaviSide</code> - the side to steer to avoid collision with an object (either left or right). The radius of the node to steer around is determined by summing the radiuses of the owner (the pet) and the <em>influenceRadius</em> - the radius of the object bound to the <code class="language-plaintext highlighter-rouge">NaviPoint</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CalcAccurateDistance()</code> - now that we have a path, we calculate its actual length taking into account all necessary steering and picking the shortest sides.</p>
  </li>
</ul>

<p>To illustrate this process, I have prepared two examples of path generation:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-1.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-1.jpg" alt="Pathfinding Example 1" /></a></p>

<p>As you an see, there are two entities between the pet and the avatar: S.T.A.S.H. and Maria Hill.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-1.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-1.gif" alt="Pathfinding Animation 1" style="max-height: 400px;" /></a>
</center>

<p>Now let’s take a look at a more involved example:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-2.jpg" alt="Pathfinding Example 2" /></a></p>

<p>In this case we have obstacles in the form of walls. The radiuses of nodes to steer around will be equal to the pet’s. Three paths are generated, and the shortest one is picked.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-2.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-2.gif" alt="Pathfinding Animation 2" style="max-height: 400px;" /></a>
</center>

<p>Finding and fixing bugs in implementations of these algorithms took me a week. I even had to implement SVG export for the navi system to visualize what was happening. In the end, all issues were solved, and now we have pets and team-ups working in the server emulator.</p>

<p>As you run around with them, keep in mind that every 200 ms they perform complex calculations to find their path to you. In addition to that, <code class="language-plaintext highlighter-rouge">Locomotor</code> has a <em>repath</em> feature that checks and potentially rebuilds the path every 250 ms in case new objects appear in the way.</p>

<p>Now you should have a better understanding of how AI works. Although team-ups currently do not attack, they scan for targets every second, and when we enable these targets, combat will begin!</p>

<hr />

<p>It is time for us to get back to coding. We hope you all are going to join us again in July for a special one year anniversary report!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: May 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: May 2024" /><published>2024-05-31T19:00:00+03:00</published><updated>2024-05-31T19:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-05/header.jpg" alt="MHServerEmu Progress Report - May 2024" /></p>

<p>Dread it, run from it, MHServerEmu Progress Report arrives all the same.</p>

<h2 id="back-in-time">Back in Time</h2>

<p>This month there has been an unexpected breakthrough. As I was finishing combing through the client’s serialization routines we talked about in the <a href="/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html">previous report</a>, I came to a realization just how little is actually needed to get in-game in some form. So I had an idea: what if we had a heavily stripped down version of the server, a minimum viable product with as much version-specific functionality removed as possible? In theory, this would allow us to get in-game using pretty much any version of the game client, which could be useful for various reasons. I decided to test this idea in practice by taking a build of version 1.10, dating back to the game’s original launch in June 2013,  and seeing if this turns out as simple as I thought. If I could get 1.10 running, any version from that all the way to 1.53 would be feasible.</p>

<p>I started by taking just the <code class="language-plaintext highlighter-rouge">MHServerEmu.Core</code> library, which handles aspects such as low level serialization and networking, and did a new lightweight server implementation with it. To my surprise, after just a couple hours of work on a single evening, I was in-game.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-absolute-win.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-absolute-win.jpg" alt="I see this as an absolute win." /></a>
<p style="font-style: italic;">I see this as an absolute win.</p>
</center>

<p>My hypothesis turned out to be correct: not only all post-launch versions of the game are fundamentally very similar, but there is only one thing that can cause the process of putting a player into a game to fail - not having a valid name specified for the player. The only other little thing that needed fixing was the fact that older versions of the game do not allow entities with zero health to move around, but with just a little bit of extra work I was able to solve this.</p>

<p>One thing that is now possible is making use of some of the internal builds we were able to recover from Steam. These builds have all console commands unlocked, some of which can be used to get a better understanding of how the game works under the hood. For example, there is a number of visualization features for various aspects of the navi system, including mesh triangulation, pathfinding, entity bounds, and much more. Here is Avengers Tower with debug visualization for navimesh, collision shapes, physics sweeps, and pathfinding.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-navi-debug.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-navi-debug.jpg" alt="Navi Debug Mode" /></a></p>

<p>In addition to that, we can now explore some of the content that was never finished and later ended up being removed from the client. Two major examples of such content are the Savage Land patrol zone, also referred to as United Tribes in the game files, and the Thanos raid that was going to be centered around Knowhere. Both of them were <a href="https://www.ign.com/articles/2015/10/12/marvel-heroes-2016-announced-secret-invasion-story-coming">mentioned by Gazillion when promoting the Marvel Heroes 2016 rebrand</a>, and early versions of them are present in version 1.48, also known as the last pre-BUE version. The screenshots below represent this content the way it was in December 2016, a little less than a year before the game’s shutdown.</p>

<p>Savage Land Siege Patrol / United Tribes is the one closer to being finished. Although it is referred to as a “patrol zone”, apparently it was going to be more of its own thing, featuring some form of tower defense gameplay. The region layout present in the client resembles three-lane MOBA level design, but with additional twists and turns reminiscent of tower defense games.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-map.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-map.jpg" alt="United Tribes Map" /></a></p>

<p>Players start at the base where they can go down one of three lanes.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-base.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-base.jpg" alt="United Tribes Base" /></a></p>

<p>Here is what the middle of the map looks like.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-mid.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-mid.jpg" alt="United Tribes Mid" /></a></p>

<p>And on the opposite side of the map there is what appears to be an unfinished boss arena that uses the Red Onslaught’s model from the Axis raid as a placeholder.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-boss.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-boss.jpg" alt="United Tribes Boss" /></a></p>

<p>On the cosmic side of things we have the Thanos raid. As far as we can tell, it was going to feature Knowhere as a new hub region, similar to Genosha that accompanied the Axis raid, and this same hub was going to be the starting area of the raid itself. This hub features special camera settings, making it rotate around the center as you move on the outer ring.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-knowhere.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-knowhere.jpg" alt="Knowhere Hub" /></a></p>

<p>The raid itself was planned to include eight areas (the descriptions are mostly speculations based on file names and layouts):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ThanosRaidPart1Area</code>, containing four subareas - <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_A</code>, <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_B</code>, <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_C</code>, and <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_D</code>. <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_A</code> is the only section of the raid that features mostly completed environment artwork. All other areas have only greyboxed layouts that occasionally reuse existing assets.</li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-raid-spoke-a.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-raid-spoke-a.jpg" alt="Thanos Raid Spoke A" /></a></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart3AreaBlackDwarf</code> (also referred to as <code class="language-plaintext highlighter-rouge">Knowhere_Hub_Part2_BlackDwarf</code> in the cell names), which appears to be an arena where players would have fought Black Dwarf.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart4AreaTransportBay</code> (<code class="language-plaintext highlighter-rouge">Knowhere_Transport_Bay_A</code>) looks like a section where players were supposed to fight their way through to a spaceship.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart5AreaShipCombat</code> is some kind of encounter where players were supposed to defend their spaceship acquired in the previous area.</p>
  </li>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">ThanosRaidPart6AreaSupergiant</code> player would board Thanos’ flagship, Sanctuary II, and fight Supergiant. In the beginning of this area there is what looks like the debris of the ship players acquired and defended in previous areas.</p>
  </li>
  <li>
    <p>The next area is called <code class="language-plaintext highlighter-rouge">ThanosRaidPart7AreaGauntlet</code>, and it appears to be an encounter where the raid would split into two teams and fight their way through Sanctuary II in series of three rooms for each team.</p>
  </li>
  <li>
    <p>It is followed by <code class="language-plaintext highlighter-rouge">ThanosRaidPart8AreaCorvusProxima</code> , the bridge of Sanctuary II, where players would have fought Corvus Glaive and Proxima Midnight.</p>
  </li>
  <li>
    <p>The same layout is reused for <code class="language-plaintext highlighter-rouge">ThanosRaidPart9AreaThanos</code>, and supposedly this is where the fight with Thanos himself was going to happen.</p>
  </li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-arena.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-arena.jpg" alt="Thanos Raid Thanos Arena" /></a></p>

<p>One other version we are now able to examine is 1.53, which is the version of the game that was on the test center when the game was shut down. It features:</p>

<ul>
  <li>
    <p>The costume closet system, which would turn costumes into options you could unlock and select in a separate panel, rather than equippable items.</p>
  </li>
  <li>
    <p>Playable Spider-Woman.</p>
  </li>
  <li>
    <p>An unfinished version of the playable Gladiator Thor. I mean Unworthy Thor. Actually, he is also referred to as just “Odinson”. Whatever his name was going to be, this was going to be an alternative, distinctly Mjolnir-less, version of Thor as a completely separate hero.</p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=Jop6iN1bO1Q">Apocalypse terminal from the console version of the game.</a></p>
  </li>
  <li>
    <p>Omega items, which were going to be some form of equipment set system with bonuses for equipping multiple items from the same set.</p>
  </li>
  <li>
    <p>A number of costumes for various heroes, including Apocalypse-themed costumes for Psylocke, Magik, Jean Grey, and Storm, costumes based on the Thor Ragnarok film for Thor, Loki, and Hulk, and other costumes not directly related to a specific event.</p>
  </li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-unworthy-thor.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-unworthy-thor.jpg" alt="Unworthy Gladiator Thor Odinson" /></a></p>

<p>One issue with this version is that its newest build, <code class="language-plaintext highlighter-rouge">1.53.0.203</code> from November 8th 2017, does not contain the assets for all the new content, such as new costumes. If you want to get the most content, you have to go back to at least <code class="language-plaintext highlighter-rouge">1.53.0.62</code> from two weeks prior to that, with all the extra bugs that entails. Even the earlier build though lacks the assets for some of the new regions, such as a new event terminal referred to as Hel Unleashed / Hela Palace, as well as a five-man version of the Muspelheim raid, both of which appear to had been planned as Thor Ragnarok tie-ins. While we do still plan to support version 1.53, as it is technically very similar to 1.52 we are currently focusing on right now, the definitive post-BUE version of Marvel Heroes is most likely going to be some kind of modded amalgamation of multiple versions.</p>

<p>The biggest takeaway from this development though is that it has definitively proven the viability of restoring pretty much any version of the game we have the client for. Just booting any version of the game now takes literally minutes (except for beta builds that have some additional jank that still needs to be figured out). It would require some effort to go as far back as 1.10, but adapting our 1.52 work for both 1.48 and 1.53 is most likely going to be significantly less difficult than we expected. As for the mini-emulator we have been using, we plan to share its source code relatively soon, once it is in a slightly more polished and user-friendly state.</p>

<h2 id="the-road-to-area-of-interest">The Road to Area of Interest</h2>

<p>Back in the realm of version 1.52 some significant backend progress has been achieved this month. The next major obstacle we need to overcome to get the game to a more playable state is implementing a proper area of interest system, and for that we had some cleaning up to do.</p>

<p>An area of interest is a server-side representation of what a particular client is aware of. When something changes in the game state (for example, your health goes up or down), only the clients that are interested in the affected entities should be notified. To find the interested clients, we need to be able to iterate connected players and check each of their individual areas of interest. However, in our previous temporary implementation of handling asynchronous network events a player could join or leave the game at arbitrary times, causing the iteration process to fail.</p>

<p>So one aspect that needed to be fixed is putting aside a specific point in the main game loop when new players could be added and removed. Whenever asynchronous events would happen, they would simply enqueue players to be added or removed during the next update. There is code for such behavior in the client, and we modeled our implementation after it. Same as Gazillion, we use a double buffer style approach: we have two instances of each queue, and when it is time to process joining / leaving players, the only thing we do in a lock is swap pointers to these two instances. While we process players in the instance we got, the other instance continues being filled asynchronously with players we are going to process in the next update. In the end this protects the game thread from asynchronous multithreaded weirdness and allows us to safely iterate players within the main loop.</p>

<p>One unfortunate side effect of this implementation was that it broke persistent player data saving. To understand how this happened we need to look at the bigger picture. Here is a rough overview of the server achitecture the game expects based on our observations:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/player-manager.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/player-manager.png" alt="Player Manager" /></a></p>

<p>The client connects directly only to the frontend server (FES). FES then relays client messages to the player manager, which distributes players across various game instances hosted by game instance servers (GIS). Because the player manager is aware where each player is, it can relay messages received from the frontend further down to the game instance where they belong. The player manager is the ultimate overseer of the entire game, and it would make sense for it to be the one interacting with the database. For those familiar with Diablo and other Blizzard games, the role of the player manager there would be handled by Battle.net.</p>

<p>We currently follow this structure pretty closely, but with some deviations. We have only a single server, and game instances are managed directly by the player manager without a separate GIS, but the overall flow is the same. So when a player disconnects, it raises an asynchronous event on the frontend server, that is then relayed to the player manager and handled by it. This handling includes removing the disconnected player from the game instance they were in and saving their data. However, now that the processing of joining and leaving players is deferred to a specific point in time, if you save player data to the database straight away, you are going to save an outdated copy of it, because the game instance most likely will have to wait until the next game frame to update the database model that is written. To fix this, we had to come up with a mechanism that also defers database writes until the game instance finishes processing leaving player. Added to the mix is also a possible case of multiple clients attempting to use the same account. Multithreading is fun!</p>

<p>With that out of the way, the next thing that needed to be done was cleaning up our entity management system and implementing inventories. One issue we had still hanging from the days of working with hardcoded packets was that player and avatar entities existed outside of the entity manager, which made it impossible for them to interact with other systems, such as areas of interest that we need to implement. However, if we were to just mix players and avatars with all the crates, cars and Maggia goons spawning all over the world, it would make it somewhat difficult to clean up when a player leaves a game. This is where inventories come in.</p>

<p>When most people think of an inventory, they probably imagine a grid full of epic loot. Marvel Heroes takes a more generalized approch: any entity can be in an inventory of any other entity. So all of your inactive avatars actually exist in the <code class="language-plaintext highlighter-rouge">PlayerAvatarLibrary</code> inventory. The avatar you are currently playing as gets put in the <code class="language-plaintext highlighter-rouge">PlayerAvatarInPlay</code> inventory. All of your team-ups exist in the <code class="language-plaintext highlighter-rouge">PlayerTeamUpLibrary</code> inventory. Same goes for summons that are contained in the <code class="language-plaintext highlighter-rouge">AgentSummonedEntities</code> inventory. Things you would expect to be stored in an inventory, such as equipment, is also included. To summarize, the inventory system in the game actually represents ownership relations between entities.</p>

<p>So by implementing the inventory system we could solve the problem of cleaning up all the various entities related to a player simply by recursively iterating all of their owned entities. And this is exactly what I did: we now have all the basic logic needed for adding, moving, and removing entities within inventories, as well as a lot of validation code mirroring the client implementation of the system. There is still some work to do before items you all know and love begin showing up in various inventory grids in the UI, but the implemented functionality is enough to take care of avatars, as well as  team-ups, who now show up as unlocked in latest nightly builds.</p>

<p>With all of this cleanup and refactoring we now reach a point where we can work on properly implementing the area of interest system, which is going to be the foundation of all client-server communication going forward. Once that is done, we are most likely going to enter another period of explosive progress, similar to the one we had in March when we got the game database fully working.</p>

<h2 id="behaviorism-and-us">Behaviorism and Us</h2>

<p>Before we wrap things up, here is also a quick update on what AlexBond has been up to. While I have been focusing on the more foundational aspects of the server, he has been digging into a system that is going to become rather important later on - behavior, also known as AI.</p>

<p>We are most likely going to go into more details on this in a future report, but here is an overview of what it looks like. Behavior affects anything that can do anything on its own: one obvious example of this is enemies, but there are also team-ups, pets, projectiles, and even orbs and boons that drop from various sources. It is implemented as a finite state machine with fourteen possible states: <code class="language-plaintext highlighter-rouge">Delay</code>, <code class="language-plaintext highlighter-rouge">Despawn</code>, <code class="language-plaintext highlighter-rouge">Flank</code>, <code class="language-plaintext highlighter-rouge">Flee</code>, <code class="language-plaintext highlighter-rouge">Flock</code>, <code class="language-plaintext highlighter-rouge">Interact</code>, <code class="language-plaintext highlighter-rouge">MoveTo</code>, <code class="language-plaintext highlighter-rouge">Orbit</code>, <code class="language-plaintext highlighter-rouge">Rotate</code>, <code class="language-plaintext highlighter-rouge">SelectEntity</code>, <code class="language-plaintext highlighter-rouge">Teleport</code>, <code class="language-plaintext highlighter-rouge">TriggerSpawners</code>, <code class="language-plaintext highlighter-rouge">UseAffixPower</code>, <code class="language-plaintext highlighter-rouge">UsePower</code>, and <code class="language-plaintext highlighter-rouge">Wander</code>. Transitions between these states are controlled by various <em>procedural profiles</em>, of which there are over a hundred in version 1.52. Some profiles are more generic, such as <code class="language-plaintext highlighter-rouge">ProceduralProfileBasicMeleePrototype</code>, while others are very specific, like <code class="language-plaintext highlighter-rouge">ProceduralProfileDrDoomPhase2Prototype</code>. The data for procedural profiles, such as what powers to use and how often, is defined in prototypes contained in the game database.</p>

<p>Surprisingly enough, the client contains not only all of the data, but also the vast majority of the code for procedural profiles. As far as we can tell, the main reason for this is that the AI system was also utilized by bots designed to stress-test servers with artificial load. While the full functionality for this feature is removed in shipping builds, there are enough traces of it for us to reverse engineer.</p>

<p>Over the course of May Alex has reimplemented 114 procedural profiles, and is now working on states. Once some more of the foundational systems are working, such as areas of interest and locomotion, this should bring some more life back to the game. It is not going to be “playable”, because we are most likely not going to have a working power system implementation for quite some time, but it should in theory make things like having a team-up or pet follow you in the game possible.</p>

<hr />

<p>And with that the third and final progress report of this spring is over. See you in the summer!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: April 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: April 2024" /><published>2024-04-30T19:00:00+03:00</published><updated>2024-04-30T19:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-04/header.jpg" alt="MHServerEmu Progress Report - April 2024" /></p>

<p>Another month has passed, and we have some more updates to share regarding the development of MHServerEmu.</p>

<h2 id="i-serialize">I, Serialize</h2>

<p>Communication is key in relationships, and the one between the client and the server is no exception. A very important aspect of computer communication is the process of serialization - describing a data structure or an object so that it can be restored at another time and/or place. Serialization is commonplace in games: every time you save or load, you are serializing or deserializing the state of the game. Refactoring and improving our server’s serialization capabilities is something I have spent the better part of April working on. Before we dive into the specifics of what exactly Gazillion concocted, let us take a look at the bigger picture first. Some of this has already been mentioned in previous reports, but this time we are diving deeper than ever before.</p>

<p>One of the most popular serialization formats these days is JSON: it represents data as plain text, which makes it easily readable and convenient to edit, but also highly inefficient both in terms of bandwidth and serialization time. As mentioned in previous reports, the core technology that Marvel Heroes relies on for serialization is Google’s <a href="https://protobuf.dev/">Protocol Buffers</a> (protobufs). Here is how it works: first, you define a structure using its language:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetStructItemSpec</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">itemProtoRef</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint32</span>    <span class="na">itemLevel</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">rarityProtoRef</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint32</span>    <span class="na">seed</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">creditsAmount</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="n">NetStructAffixSpec</span>    <span class="na">affixSpecs</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">equippableBy</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, you run the structures you defined through a code generator that produces highly efficient, but also very repetitive and barely readable code in your desired programming language. You can add this code to your program as a library, and then call it when you need something serialized. An important aspect of the code produced this way is that it includes the so-called “descriptors” that contain real-time type information (RTTI) and can be parsed by special tools, such as <a href="https://github.com/dennwc/protod">protod</a>, to restore the original definitions. This is exactly what we did: we reconstructed the original protobuf structures from the compiled C++ client code, which we then used to generate a C# library that serializes data in a way the client can understand. Such language interoperability is one of the key features of protobufs.</p>

<p>One way Gazillion uses protobufs is to implement a system that resembles the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>, and is the foundation of all network messages: requests are represented as objects that are serialized using protobufs, and then sent over a network. Here is an example of a server to client message that includes the <code class="language-plaintext highlighter-rouge">NetStructItemSpec</code> structure from the previous example, and is used to broadcast chat messages when players find rare items:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageBroadcastRareItem</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">string</span>    <span class="na">playerName</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">NetStructItemSpec</span>    <span class="na">item</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">ChatRoomTypes</span>    <span class="na">roomType</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And this is where the intended use of protobufs ends and we get into the hackery territory. As you look through the defined messages, you begin to see things like this pop up:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityCreate</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">baseData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessageLocomotionStateUpdate</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessageActivatePower</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessagePowerResult</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/hell.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/hell.jpg" alt="Gazillion Hackery" /></a></p>

<p>To make sense of this, first, we need to understand how protobufs work under the hood. <em>Note: We are going to assume little-endian byte order unless noted otherwise.</em></p>

<p>At the heart of protobufs lies the so-called <a href="https://protobuf.dev/programming-guides/encoding/">wire format</a>, which is used to encode your defined structures as binary data. The basic unit of information in protobufs is called a varint, which stands for <strong>var</strong>iable-width <strong>int</strong>eger. Typically, when you want to store a value, you use a data type with a certain amount of memory allocated to it, which dictates its bounds: a classic example of this is a signed 32-bit integer, which can store values from <code class="language-plaintext highlighter-rouge">-2147483648</code> to <code class="language-plaintext highlighter-rouge">2147483647</code>. When you store smaller values, you may need just one or two bytes, but a 32-bit signed integer is still going to use all four of them, even though most of the bits are going to be left unset. Protobufs solve this problem in two steps. First, when varints are encoded, the most significant bit in each byte is reserved as the “continuation bit” that determines whether there are more  bytes that follow it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10010110 00000001
^ MSB    ^ MSB
</code></pre></div></div>

<p>When decoding, we continue to read bytes until we get to the one where the most significant bit is not set. This way we can encode a value equivalent to a 64-bit unsigned integer, and it is going to take from one to ten bytes, with smaller values using fewer bytes.</p>

<p>If you were to use this approach to encode a signed integer though, you would run into an issue: since the most significant bit of an unencoded signed integer is used to determine whether it is negative or not, you are going to have go through a bunch of mostly useless zeroes to get to it, and you will end up using all ten bytes even for a value as small as <code class="language-plaintext highlighter-rouge">-1</code>. This is where the second part of the protobuf magic comes in: zig-zag encoding. The idea is that you mix positive and negative values together in a “zig-zag” pattern, with even numbers representing positive values, and odd numbers representing negative values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Encoded      Decoded
0            0
1              -1
2            1
3              -2
4            2
</code></pre></div></div>

<p>One last piece of the original protobuf puzzle we need to understand is how floating point values are encoded. Here a simple pointer hack is used: we just reinterpret the same four bytes used to store a 32-bit float as an unsigned 32-bit integer, and then we encode it using the method above.</p>

<p>Now that we have experienced the tragic backstory flashback, we can take a look at Gazillion’s secret serialization sauce. It seems they were unhappy with how protobufs performed out of the box, so they created their own custom abstraction layer on top of the base protobuf wire format - <em>archives</em>. An archive is an object that combines a memory buffer with functionality for four modes of serialization:</p>

<ul>
  <li>
    <p><strong>Migration</strong>: for server &lt;-&gt; server serialization.</p>
  </li>
  <li>
    <p><strong>Database</strong>: for server &lt;-&gt; database serialization.</p>
  </li>
  <li>
    <p><strong>Replication</strong>: for server &lt;-&gt; client serialization.</p>
  </li>
  <li>
    <p><strong>Disk</strong>: for server &lt;-&gt; file serialization.</p>
  </li>
</ul>

<p>Each mode can be used both for packing and unpacking, so in total we actually have eight different modes. To interact with an archive, we use the <code class="language-plaintext highlighter-rouge">Transfer()</code> method that has overloads for most common primitive types, such as <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, and so on, but also structures like <code class="language-plaintext highlighter-rouge">Vector3</code>, collections, and objects that implement the <code class="language-plaintext highlighter-rouge">ISerialize</code> interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">ISerialize</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Most <code class="language-plaintext highlighter-rouge">Transfer()</code> overloads act as wrappers than convert the passed value to or from an unsigned integer, and serialize it as a varint using the internal <code class="language-plaintext highlighter-rouge">Transfer_()</code> method:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">ioData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Convert int to uint and write it</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="n">CodedOutputStream</span><span class="p">.</span><span class="nf">EncodeZigZag32</span><span class="p">(</span><span class="n">ioData</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Read a uint and convert it back to int</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
        <span class="n">ioData</span> <span class="p">=</span> <span class="n">CodedInputStream</span><span class="p">.</span><span class="nf">DecodeZigZag32</span><span class="p">(</span><span class="n">encodedData</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In addition to the protobuf wire format, Gazillion brought some of their own tricks to the table. For instance, along with the standard protobuf way of encoding floating point values, archives support another, more efficient, but less precise way:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">TransferFloatFixed</span><span class="p">(</span><span class="k">ref</span> <span class="kt">float</span> <span class="n">ioData</span><span class="p">,</span> <span class="kt">int</span> <span class="n">precision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">precision</span> <span class="p">=</span> <span class="n">precision</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">precision</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="n">CodedOutputStream</span><span class="p">.</span><span class="nf">EncodeZigZag32</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">ioData</span> <span class="p">*</span> <span class="n">precision</span><span class="p">));</span>
        <span class="k">return</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
        <span class="n">ioData</span> <span class="p">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">CodedInputStream</span><span class="p">.</span><span class="nf">DecodeZigZag32</span><span class="p">(</span><span class="n">encodedData</span><span class="p">))</span> <span class="p">/</span> <span class="n">precision</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A precision argument is passed, which represents the power of 2 by which the value is multiplied. The fractional part is then discarded, and the value is encoded as a regular signed integer using the zig-zag method. The process is reversed to get an approximation of the original value with the given precision. Here is an example of a real value being encoded:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Encode</span>
<span class="kt">float</span> <span class="k">value</span> <span class="p">=</span> <span class="m">12.3689f</span><span class="p">;</span>
<span class="k">value</span> <span class="p">=</span> <span class="k">value</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="m">3</span><span class="p">);</span>                  <span class="c1">// 12.3689 * 8 = 98.9512</span>
<span class="kt">uint</span> <span class="n">encodedValue</span> <span class="p">=</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>           <span class="c1">// 98</span>

<span class="c1">// Decode</span>
<span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">encodedValue</span> <span class="p">/</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="m">3</span><span class="p">);</span>    <span class="c1">// 98 / 8 = 12.250</span>
</code></pre></div></div>

<p>So we end up with a value of <code class="language-plaintext highlighter-rouge">12.250</code>, which is an approximation of the original <code class="language-plaintext highlighter-rouge">12.3689</code>. The main use case for this kind of encoding is efficiently packing <code class="language-plaintext highlighter-rouge">Vector3</code> and <code class="language-plaintext highlighter-rouge">Orientation</code> structures, which consist of multiple <code class="language-plaintext highlighter-rouge">float</code> values, and reducing the amount of network traffic used by systems like locomotion.</p>

<p>The final boss of these encoding strategies is the way <code class="language-plaintext highlighter-rouge">bool</code> values are encoded. This caused us a lot of headaches when we first started the development of this project. The boolean data type represents a binary value that can be either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. However, since the smallest addressable unit of memory in many computer architectures is a byte, which consists of eight bits, a <code class="language-plaintext highlighter-rouge">bool</code> value typically occupies eight times more memory than it actually needs.</p>

<p>To deal with this inefficiency, Gazillion implemented a custom format for packing multiple boolean values into a single byte. When you first attempt to write a <code class="language-plaintext highlighter-rouge">bool</code> to an archive, it writes a byte and remembers the offset at which it was written. If the value is true, it writes <code class="language-plaintext highlighter-rouge">0x81</code>, otherwise <code class="language-plaintext highlighter-rouge">0x1</code>. The next time you try to write a <code class="language-plaintext highlighter-rouge">bool</code>, the archive goes back to the offset of the previously written bool byte, and packs the additional value into it. This continues until the archive packs up to five values to that byte, after which it writes a new byte and updates the offset. The end result you end up with is what we used to call “phantom bools”: when you read encoded data back, each boolean-packed byte contains up to four extra values in addition to the one that was being transfered in that <code class="language-plaintext highlighter-rouge">Transfer()</code> call. Here is how it ends up being structured:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bits  | Num Encoded | Hex  | Values
10000 | 001         | 0x81 | true
00000 | 001         | 0x1  | false
11000 | 010         | 0xC2 | true, true
01000 | 010         | 0x42 | false, true
00000 | 011         | 0x3  | false, false, false
10100 | 011         | 0xA3 | true, false, true
11111 | 101         | 0xFD | true, true, true, true, true
</code></pre></div></div>

<p>Each primitive data type may also use alternative encoding methods depending on the mode of serialization. The examples above are all for the replication mode, which we have to reimplement as accurately as possible, because it is the mode used to communicate with the client. Since we have the full control of the backend, for other modes, such as database, we can either reuse replication encoding, or come up with some kind of custom solution.</p>

<p>With the theory out of the way, we arrive at the practical application of archives. This is done via the previously mentioned <code class="language-plaintext highlighter-rouge">ISerialize</code> interface. It is implemented by objects that need to be serialized to archives, and when the stars align it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_currentCount</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_totalCount</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timeStart</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timeEnd</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timePaused</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code handles both serialization and deserialization in all modes, it is easy to read and maintain, and in general it looks like a good time. However, the saying “no plan survives contact with the enemy” is very true here. A lot of <code class="language-plaintext highlighter-rouge">ISerialize</code> implementations in the game look a lot more like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

    <span class="kt">uint</span> <span class="n">numElements</span> <span class="p">=</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">_myList</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
    <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">numElements</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPersistent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; database serialization</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsReplication</span> <span class="p">&amp;&amp;</span> <span class="n">archive</span><span class="p">.</span><span class="n">ReplicationPolicy</span><span class="p">.</span><span class="nf">HasFlag</span><span class="p">(</span><span class="n">AOINetworkPolicyValues</span><span class="p">.</span><span class="n">ReplicateToProximity</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; client serialization</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPersistent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// database -&gt; server deserialization</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsReplication</span> <span class="p">&amp;&amp;</span> <span class="n">archive</span><span class="p">.</span><span class="n">ReplicationPolicy</span><span class="p">.</span><span class="nf">HasFlag</span><span class="p">(</span><span class="n">AOINetworkPolicyValues</span><span class="p">.</span><span class="n">ReplicateToProximity</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; client deserialization</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything ends up being completely mixed up and coupled together, which makes it the opposite of a good time. However, these messy implementations provide us with a valuable insight into how the backend of the game, including database persistence, worked. Essentially, your account data, heroes, items, and so on would be serialized to an archive in the database mode to get what was pretty much a save file. This save file would then be saved to the database as a <a href="https://en.wikipedia.org/wiki/Object_storage">blob data type</a>.</p>

<p>All the necessary migration between versions would be handled by the same <code class="language-plaintext highlighter-rouge">Serialize()</code> method during unpacking, meaning that implementations <em>also</em> had to include additional complexity overhead of all the patches ever released so that someone who played for a week in 2013 could still log in again in 2017, with all their progress preserved and migrated on login. Thankfully, we do not have any old saved data to account for, and even when we do implement the support for more versions of the game, we can handle this conversion with an external tool of some kind if the need arises.</p>

<p><code class="language-plaintext highlighter-rouge">archiveData</code> byte arrays mentioned when I was talking about protobuf network messages are actually these same “save files”, but serialized in replication mode, which includes additional runtime information that is generally omitted from persistent storage, as well as some other differences. Some of these messages were actually standard protobuf structures prior to version 1.25, in which the developers did an optimization pass of their network protocol that included the conversion of some of the standard protobuf messages to archives.  Good examples of this are <code class="language-plaintext highlighter-rouge">NetMessageLocomotionStateUpdate</code> and <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code>: rather than representing an object, they are used as a more efficient way of packing runtime information. Here is an example of what <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code> looked like in version 1.24:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessagePowerResult</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">powerPrototypeId</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">targetEntityId</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">flags</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">isSelfTarget</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">powerOwnerEntityId</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">ultimateOwnerEntityId</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">combinedOwnerEntityId</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damagePhysical</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damageEnergy</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damageMental</span>    <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">healing</span>    <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructPoint3</span>    <span class="na">powerOwnerPosition</span>    <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int64</span>    <span class="na">powerAssetRefOverride</span>    <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">transferToEntityId</span>    <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So what I have been spending most of April doing is painstakingly going through all classes the implement the <code class="language-plaintext highlighter-rouge">ISerialize</code> interface, untangling the mess, and making adjustments to structures of serializable objects as needed. All of this is a necessary step for implementing the area of interest (AOI) system that handles replication of the server-side simulation to clients, but this is a story for another time.</p>

<h2 id="time-is-a-flat-circle">Time is a Flat Circle</h2>

<p>Serialization is not the only issue I have been tackling lately. As we get more and more fundamental systems working, we get closer to the real meat of this project - the real-time simulation of the game world, and the “real-time” aspect of it is quite tricky.</p>

<p>Probably the most ubiquitous programming pattern you can see in video games is the <a href="https://gameprogrammingpatterns.com/game-loop.html">game loop</a>. In its most simplest form it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">ProcessInput</span><span class="p">();</span>    <span class="c1">// Get input from keyboard / mouse / controllers</span>
    <span class="nf">Update</span><span class="p">();</span>          <span class="c1">// Update the simulation accordingly</span>
    <span class="nf">Render</span><span class="p">();</span>          <span class="c1">// Render the new state of the simulation</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we are dealing with a server, there are some I/O differences, but the general idea is the same:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">ProcessClientMessages</span><span class="p">();</span>    <span class="c1">// Player input is serialized and sent over a network</span>
    <span class="nf">Update</span><span class="p">();</span>                   <span class="c1">// Update the simulation accordingly</span>
    <span class="nf">SendUpdatesToClients</span><span class="p">();</span>     <span class="c1">// "Render" the new simulation state to clients</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We still process player input, even though we receive it with a delay, we update the simulation accordingly, and then we “render” the results, but instead of outputting a frame buffer to a screen we send message packets over a network. Therefore, most common wisdom regarding game loops is applicable to our case as well.</p>

<p>The big problem with this simple loop is that it runs as fast as your computer can run it. Therefore, the game is going to slow down or speed up depending on the processing power of the computer running it. It is not 1990 anymore, and our computers generally no longer have turbo buttons to account for this, so we have to deal with it in software.</p>

<p>One common way of solving this is to introduce the so-called delta time - the time difference in seconds between the previous update and the current one:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">_lastFrameStartTime</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="c1">// Divide to convert milliseconds to seconds</span>
    <span class="kt">float</span> <span class="n">delta</span> <span class="p">=</span> <span class="p">(</span><span class="n">currentTime</span> <span class="p">-</span> <span class="n">_lastFrameStartTime</span><span class="p">)</span> <span class="p">/</span> <span class="m">1000f</span><span class="p">;</span>
    <span class="n">_lastFrameStartTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="nf">ProcessInput</span><span class="p">();</span>
    <span class="nf">Update</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="nf">Render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then when we update something, we multiply our time-sensitive values by <code class="language-plaintext highlighter-rouge">delta</code> to account for how much time has passed:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">_position</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_speed</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_position</span> <span class="p">+=</span> <span class="n">_speed</span> <span class="p">*</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So the less time has passed since the last update, the less distance we are going to cover in this update. This works great if the game is running locally, and it is the approach you are most likely familiar with if you have ever worked with popular game engines. However, it is not a one-size-fits-all solution. One issue with it is that most video games rely on single-precision floating-point numbers (floats) for a lot of their calculations, which are fast, but also subject to rounding errors. The faster your computer runs, the more updates that involve float calculations it does, and the more float calculations it does, the more its rounding error builds up. In online multiplayer games this leads to clients getting desynchronized from the server, which is something that should be minimized.</p>

<p>To avoid this issue, a fixed update interval is used, commonly referred to as a “tick rate”. This is especially a hot topic in competitive shooters, where the tick rate can get as high as 120+ Hz (so 8.33 ms or less per simulation update). The rendering frequency in this case is generally decoupled from the main simulation, so it is possible to render the game at hundreds of frames per second even with a modest tick rate. The smoothness in this case is achieved by a combination of interpolation and independent simulation of systems that do not have synchronized, such as particle effects. A good example of this is <em>Overwatch</em>, which at launch ran at a modest (by competitive shooter standards) tick rate of around 21 Hz, and eventually it got upgraded to approximately 63 Hz in a later patch. The biggest downside of a low tickrate is that it “batches” events together, causing some things that occured separately to be processed simultaneously, such as you and your opponent shooting and killing each other.</p>

<p>Marvel Heroes also uses this approach: internally it refers to its ticks as “frames”, and by default it runs at the “framerate” of exactly 20 Hz (50 ms per frame). The code that runs the simulation is shared by both the server and the client: the server runs it as a standalone thing, while in the client it is integrated into Unreal Engine, so essentially you have a mini-engine running inside Unreal. To keep the gameplay smooth and responsive, the client runs its own instance of the simulation and corrects it using the information that the server “renders” to it.</p>

<p>So what do you do after you finish your fixed-time update? You wait until it is time for another update. The naive way to approach it is this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">float</span> <span class="n">TargetFrameTime</span> <span class="p">=</span> <span class="m">50.0f</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">_previousTime</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_accumulatedTime</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_accumulatedTime</span> <span class="p">-=</span> <span class="n">TargetFrameTime</span><span class="p">;</span>
        <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>    <span class="c1">// Process input, update state, send updates</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While precise, doing it this way keeps the thread constantly busy, wasting power doing pretty much nothing. Thankfully, there is a handy tool provided to us by the operating system - sleep, which is a feature that lets the OS know that we are not currently doing anything, and the CPU can be used for something else, or it can stay idle if nothing else is going on. This provides us with a much more efficient, but still rather naive way of implementing this, which we previously used for MHServerEmu:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&lt;</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">sleepTime</span> <span class="p">=</span> <span class="n">TargetFrameTime</span> <span class="p">-</span> <span class="n">_accumulatedTime</span><span class="p">;</span>
        <span class="c1">// Sleep() takes an integer number of milliseconds as its argument</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">sleepTime</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Do the update if enough time has passed</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So what is so naive about this? The fact that the thread scheduler treats what you tell it to do like the pirate code: it is more like guidelines than actual rules. The time you specify is actually the minimum amount of time the thread is going to sleep, and how much it overshoots this target depends on: your operating system and its version, your hardware, whether a high precision timer is enabled, ambient entropy levels, the state of Schrödinger’s cat, and who knows what else.</p>

<p>This is a problem we are still working on solving, but the solution we are trying out at the time of writing is one of multiple used by the <a href="https://monogame.net/">MonoGame framework</a> (a modern offshoot of Microsoft’s XNA), which involves sleeping in smaller intervals with checks inbetween:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&lt;</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">TargetFrameTime</span> <span class="p">-</span> <span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="m">2.0</span><span class="p">)</span>
            <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wrap this in while loop to catch up if we missed some frames</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_accumulatedTime</span> <span class="p">-=</span> <span class="n">TargetFrameTime</span><span class="p">;</span>
        <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The results we have seen with this implementation range from “good enough” to “pretty great”. When testing on a virtual machine running Kubuntu, the overshoot was generally within our leeway of 2 ms, while on Windows 10 our measured sleep times seemed to be around 15 ms (given the requested 1 ms of sleep), which appears to match the default Windows timer resolution. For measuring this we have used the <code class="language-plaintext highlighter-rouge">Stopwatch</code> class provided by .NET. For now this seems to be accurate enough for our 50 ms window, but for potentially running a more precise simulation we are going to need a better solution.</p>

<p>There are still some tricks we can try out, including those employed by MonoGame and its cousin <a href="https://fna-xna.github.io/">FNA</a>, such as importing and calling native Windows API functions related to timer resolutions, making use of <code class="language-plaintext highlighter-rouge">Thread.SpinWait()</code>, and others. As more gameplay systems become functional, we are also going to have to improve our catchup system: fixed-time update systems are prone to so-called “death spirals”, where your computer is unable to update the simulation fast enough, which leaves more work to do for the next update, and eventually it ends up getting completely stuck. There are strategies to mitigate and potentially recover from these, and it is something we are going to dive deeper in the future.</p>

<h2 id="navi-population-and-physics">Navi, Population, and Physics</h2>

<p><em>AlexBond is back yet again to discuss how things have been going on his front. Please see the <a href="/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html">March report</a> for more context on the work he has been doing lately.</em></p>

<hr />

<p>Hey everyone, it’s AlexBond. This month has ended up being rather fruitful, although it may not seem this way at first. Let’s take a look.</p>

<p>Here are the main things I have been working on:</p>

<ul>
  <li>
    <p>Finishing up the NaviSystem</p>
  </li>
  <li>
    <p>BlackOutZone</p>
  </li>
  <li>
    <p>PropSets</p>
  </li>
  <li>
    <p>AreaPopulation</p>
  </li>
  <li>
    <p>SpawnSpec</p>
  </li>
  <li>
    <p>PlayKismetSeq</p>
  </li>
  <li>
    <p>EntityFilter Evaluate</p>
  </li>
  <li>
    <p>PhysicsManager and NaviSweep</p>
  </li>
</ul>

<p><strong>NaviSystem</strong> has been improved: all issues have been fixed, and we now have the <code class="language-plaintext highlighter-rouge">NaviMesh.Contains()</code> function that we can use to determine whether an object is contained within the playable area or not. One of the issues that has been fixed is the spawning of NPCs outside of the playable area. In addition, this has laid the foundation for processing game physics interactions.</p>

<p>A <strong>BlackOutZone</strong> is a marker with a radius that defines a zone where enemy spawning is restricted. This information is contained within Cell markers. Some blackout zones are defined in missions or spawners, and NPCs can spawn only if the required mission is in the correct state. When all markers are placed via <code class="language-plaintext highlighter-rouge">SpawnBlackOutZone()</code>, we get another tool to detect intersections with a zone - <code class="language-plaintext highlighter-rouge">InBlackOutZone()</code>. This adds another check when spawning <em>ClusterEntities</em>.</p>

<p><strong>PropSets</strong> are sets of random destructible objects that appear in an area, such as boxes and cars. Markers are picked using <code class="language-plaintext highlighter-rouge">GetRandomPropMarkerOfType()</code> from <code class="language-plaintext highlighter-rouge">PropShapeLists</code>, and then placed in the world. We now have even more cars and trash!</p>

<p><strong>AreaPopulation</strong> is another way of spawning enemies in the game world, but in this case instead of markers we have groups and their weights. Each <em>area</em> has an <code class="language-plaintext highlighter-rouge">AreaPrototype.Population</code> field that contains <code class="language-plaintext highlighter-rouge">Themes.Enemies</code>, as well as population density parameters. We calculate the density of enemies that are already present in an area, and then we determine how many additional enemies we need to add to get to the defined threshold. To get a more accurate density value we use <code class="language-plaintext highlighter-rouge">CalcSpawnableArea()</code> via <code class="language-plaintext highlighter-rouge">NaviMesh</code> while taking into account space not occupied by blackout zones. This way enemies are distributed randomly and evenly along appropriate cells using <code class="language-plaintext highlighter-rouge">SpawnInCell()</code>. Examples of regions that rely on this spawning method include Training Camp, Daily Bugle, Classified Bovine Sector, almost all terminals, as well as other regions that previously seemed rather deserted.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-cows.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-cows.jpg" alt="An Amoosing Sight" /></a></p>

<p>Fun fact: the terminal version of Sinister Lab has a population override that prevents dinosaur enemies from spawning there, even though they are present in the story mode version of this region. Some players didn’t seem to remember this.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser.png" alt="Population Override" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-dinos.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-dinos.jpg" alt="Life Finds a Way" /></a></p>

<p><strong>SpawnSpec</strong> is a class responsible for spawning all groups of enemies, including regular NPCs that are typically tied to missions or their own spawners. By merging the spawning system into the SpawnSpec class we have finally been able to get rid of issues with objects hovering in the air and getting stuck in the ground. One remaining problem is that because many destructible props currently spawn after enemies, the system is unable to properly detect collisions, which leads to enemies getting stuck in cars and barrels. This is going to be resolved on its own once spawners get their own timers and events for doing their work.</p>

<p><strong>PlayKismetSeq</strong> is a command that can be sent as a message to the client to start a scripted Unreal Engine cutscene. For example, I have added a trigger for such sequence to the Raft, and now you can see the Quinjet landing when you load into the region. This also includes an animation of Juggernaut running away.</p>

<p><em>Editor’s Note:  Kismet is the name of the visual scripting language that was available in Unreal Engine 3. Those of you who have experience with versions 4 and 5 are most likely familiar with Blueprints: Kismet is an earlier iteration of the same concept. For more information on Kismet see the <a href="https://docs.unrealengine.com/udk/Three/KismetHome.html">official documentation</a>. And now, back to our regularly scheduled programming.</em></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-kismet.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-kismet.jpg" alt="Reporting for Duty!" /></a></p>

<p>After that I started investigating what triggers these sequences, and that led me to <em>hotspots</em> and <em>MissionConditionPrototype</em>.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser-2.png" alt="Population Override" /></a></p>

<p>Everything turned out to be more complicated than I expected, and I ended up working on implementing mission logic and game physics…</p>

<p><strong>EntityFilters</strong> are sets of conditions for triggering mission events. To get the result of a condition it has to be determined using the <code class="language-plaintext highlighter-rouge">Evaluate()</code> function, as well as a cached <code class="language-plaintext highlighter-rouge">EntityTrackingContextMap</code> in the <strong>InteractionManager</strong>. This function is coupled with lots of various systems: regions, areas, entities, missions. I have implemented all the base logic, and this foundation is going to come in handy in the future.</p>

<p>The <strong>PhysicsManager</strong> calculates displacements and collisions. The server runs <code class="language-plaintext highlighter-rouge">PhysicsResolveEntities()</code> every frame and checks all active entities for collisions. Internally displacements are called <em>sweeps</em>, and they are handled by the <em>NaviSweep</em> class. NaviSweep consists of numerous real time calculations. After studying some of them, we were able to figure out the source of inspiration for many of them: the book <a href="https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323">Real-Time Collision Detection by Christer Ericson</a>. Many of the functions used in the game are taken from this book word for word, and it has helped us to make sense of everything. Below is a figure from the book that explains how the <code class="language-plaintext highlighter-rouge">Sphere.Sweep(Aabb)</code> function works.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-rtcd.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-rtcd.png" alt="Real-Time Collision Detection by Christer Ericson" /></a></p>

<p><em>PhysicsManager</em> and <em>NaviSweep</em> do a lot of projection and collision detection, but the end result of all these calculations is the triggering of these three events:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnCollide()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnOverlapBegin()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnOverlapEnd()</code></p>
  </li>
</ul>

<p>We now have triggers, we can check conditions with <code class="language-plaintext highlighter-rouge">Evaluate()</code>, but we still don’t have an <em>avatar</em> that is going to interact with all of these.</p>

<p>For an avatar (a playable character) to be able to enter the physical world and interact with it, it requires a working <em>Locomotor</em> system.</p>

<p>The server runs <code class="language-plaintext highlighter-rouge">LocomoteEntities()</code> every frame to calculate all types of movements in the game. The Locomotor system is responsible for things such as: moving enemies with <code class="language-plaintext highlighter-rouge">MoveTo()</code>, finding their paths with <code class="language-plaintext highlighter-rouge">GeneratePath()</code>, rotating them with <code class="language-plaintext highlighter-rouge">LookAt()</code>, processing flight, various restrictions, velocity, synchronizing these movements between the server and the client with <code class="language-plaintext highlighter-rouge">SetSyncState()</code>, as well as interacting with the <strong>NaviPath</strong> system. And this is what I am going to be working on next month!</p>

<hr />

<p>We hope you enjoyed this report, see you again next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: March 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: March 2024" /><published>2024-03-31T19:50:00+03:00</published><updated>2024-03-31T19:50:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-03/header.jpg" alt="MHServerEmu Progress Report - March 2024" /></p>

<p>Spring has come to the Northern Hemisphere, and the development of MHServerEmu is blooming.</p>

<h2 id="010-release">0.1.0 Release</h2>

<p>This month we have reached an important milestone: our first “official” binary release. Version 0.1.0 represents the progress we were able to achieve in the first 8 months of this project, including all the work on the game database, properties, and region generation we have been talking about in these reports. In addition to that, we have implemented enough fundamental systems to remove the last remaining hardcoded data packets, which allows us to fully control the data that is serialized to the client and no longer be bound to a specific version of the game.</p>

<p>If you have been following the development and tried out the nightly snapshot builds, most of what is contained in this release should be familiar to you. However, there are a few extras we included.</p>

<p>0.1.0 comes with the new Setup Sorcerer Supreme tool, which is our flavored spin on the setup wizard idea that is common in software. Here is what it currently does:</p>

<ul>
  <li>
    <p>Verifies the game client version by finding the main executable, hashing it, and comparing the hash to the expected one.</p>
  </li>
  <li>
    <p>Copies the <code class="language-plaintext highlighter-rouge">.sip</code> files required to run the server to the MHServerEmu data directory.</p>
  </li>
  <li>
    <p>Creates a <code class="language-plaintext highlighter-rouge">StartClient.bat</code> file that launches the client configured to connect to a local server.</p>
  </li>
  <li>
    <p>Creates a <code class="language-plaintext highlighter-rouge">StartClientAutoLogin.bat</code> file that launches the client configured to connect to a local server with automatic login using pre-defined credentials.</p>
  </li>
</ul>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-03/setup-sorcerer-supreme.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/setup-sorcerer-supreme.png" alt="Setup Sorcerer Supreme" /></a>
</center>

<p>This release also comes bundled with the Apache web server and web assets for the in-game store and news panels. These assets are also available separately in the new <a href="https://github.com/Crypto137/MHServerEmuWebAssets">MHServerEmuWebAssets</a> repository.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/news.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/news.jpg" alt="New Web Assets - News Panel" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/store.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/store.jpg" alt="New Web Assets - Store Panel" /></a></p>

<p>As soon as 0.1.0 was released, we started working on version 0.2.0. Currently we do not have any estimates for when it is going to be out, but like always you can follow the progress on <a href="https://github.com/Crypto137/MHServerEmu/network">GitHub</a> and via nightly builds.</p>

<h2 id="game-database-browser">Game Database Browser</h2>

<p>Kawaikikinou has finished the work on a new game database browser tool that allows you to easily browse all the static game data we have been decoding over the past few months. Now you can relatively easily find out, for instance, what was the <em>actual</em> drop rate of the infamous Gem of the Kursed.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/game-database-browser.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/game-database-browser.jpg" alt="Game Database Browser" /></a></p>

<p>The browser works by plugging in existing server code into a WPF-based GUI. This is more of a development tool rather than something that is intended to be used by end users, but it has already proven to be extremely helpful in getting a better understanding of how everything fits together. The source code is available on <a href="https://github.com/Kawaikikinou/MHServerEmu/tree/game-database-browser">GitHub</a>.</p>

<h2 id="server-architecture-improvements">Server Architecture Improvements</h2>

<p>One of the first things I wanted to do in 0.2.0 was to make improvements to the overall server achitecture and how data flows around. Here is an overview of what has been done so far.</p>

<p>Major parts of the server (game, player management, billing, and so on) have been decoupled from each other and split into separate library projects. This allows us to potentially remove or substitute certain service implementations. For example, the database access layer can now be more easily modified to use various persistent storage solutions, such as a fully featured database management system. Also this allows us to reuse game code for tools, like the previously mentioned game database browser.</p>

<p>Duplicate login handling has been improved. Previously, the player manager would refuse connections for any players that are trying to log in using an account that is already logged in. This could cause potential issues if for some reason a player remained logged in due to an unexpected crash or some other problem. Now it works like most online games: when a duplicate login is detected, the already logged in player is disconnected, their data is saved, and then reassigned to the new session.</p>

<p>Our continuous integration pipeline that is used for nightly builds now has an additional step - running automated tests. As the server codebase grows, it becomes harder and harder to keep track of all the potential things that could break, especially because there are certain parts that have to be 100% in sync with the client. With daily automated testing hopefully we will be able to discover and fix any potential issues with existing code as soon as they come up.</p>

<p>The network message flow has been overhauled. Messages are now deserialized asynchronously before they reach game simulations, which frees up valuable frame time. The way messages are batched together and sent to the clients has also been redone, and is now closer to the client implementation. Connected players are now represented in the game they are in by <code class="language-plaintext highlighter-rouge">PlayerConnection</code> instances, which allowed us to clean up message handling and improve individual player state tracking.</p>

<p>The work on this front continues, and some more progress has been made with properly reimplementing the custom Gazillion serialization archive system, which we are going to talk more about in the next report.</p>

<h2 id="steam-deck-support">Steam Deck Support</h2>

<p>Thanks to the efforts of <strong>FF_Lowthor</strong> from our Discord server we have been able to get the game running on Linux (and Steam Deck).</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/steam-deck.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/steam-deck.jpg" alt="Marvel Heroes Steam Deck" /></a></p>

<p>The game client has a rather peculiar compatibility issue when running under Proton. During the authentication process the client receives a session token and a 256-bit AES encryption key from the auth server. It then generates an initialization vector (IV) that it mixes with the encryption key to encrypt the token it received, which is then used to authenticate with the frontend server. Something goes wrong somewhere in this token encryption process under Proton, which causes the authentication to fail.</p>

<p>FF_Lowthor has made a patch that allows the client to ignore this error and proceed with the login without a properly encrypted token. You can apply this patch by changing <code class="language-plaintext highlighter-rouge">75</code> to <code class="language-plaintext highlighter-rouge">EB</code> at <code class="language-plaintext highlighter-rouge">0x019B317E</code> in the Win64 version of <code class="language-plaintext highlighter-rouge">MarvelHeroesOmega.exe</code> either manually with a hex editor, or using our <a href="https://github.com/Crypto137/MHPatcher">MHPatcher</a> tool.</p>

<p>Server-side you also have to enable <code class="language-plaintext highlighter-rouge">BypassAuth</code> in <code class="language-plaintext highlighter-rouge">Config.ini</code> to allow clients to log in without valid session tokens. As quality of life feature, the server now also saves data for the default account used when BypassAuth is enabled in a JSON file.</p>

<h2 id="entity-spawning-and-navi">Entity Spawning and Navi</h2>

<p>This month AlexBond is back to talk about world entity spawning and the NaviSystem. If you have not already, be sure to check out his explanation of the procedural region generation from the <a href="/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html">January report</a>.</p>

<hr />

<p>Hey everyone, it’s AlexBond. In this report I would like to talk about the enemy spawning process and a little bit about NaviMesh generation.</p>

<h3 id="clusterobject">ClusterObject</h3>

<p><code class="language-plaintext highlighter-rouge">ClusterObject</code> is the foundation of all spawners in the game, from idle NPCs standing around and chatting with each other, to armies of enemies in a formation with their leaders and henchmen.</p>

<p>At the heart of these objects lies data from <code class="language-plaintext highlighter-rouge">PopulationObjectPrototype</code> instances. They describe the number of regulars enemies (called <em>riders</em>), their <em>formation</em>, and a bunch of other settings. This prototype class has various derived classes that define whether a group has a <em>leader</em>, how many <em>henchmen</em> it contains, and many other specifics. ClusterObjects also belong to a <code class="language-plaintext highlighter-rouge">ClusterGroup</code>, and there is a derived <code class="language-plaintext highlighter-rouge">ClusterEntity</code> class that is responsible for spawning specific enemies.</p>

<h3 id="populationmarker-spawning">PopulationMarker Spawning</h3>

<p>Cell prototypes contain <code class="language-plaintext highlighter-rouge">SpawnMarkerPrototype</code> instances. When we load region missions, we look for the <code class="language-plaintext highlighter-rouge">PopulationSpawns</code> field that describes the amount of enemies on the map and the name of the spawn marker. We assemble all of this information into the <code class="language-plaintext highlighter-rouge">PopulationMarkers</code> array, and in the <code class="language-plaintext highlighter-rouge">Cell.PostGenerate()</code> method we add enemies to their places.</p>

<p>For random placements we have the <code class="language-plaintext highlighter-rouge">SpawnMarkerRegistry</code> class that uses <code class="language-plaintext highlighter-rouge">SpawnReservation</code> to randomly pick free markers that are appropriate for specific enemies.</p>

<p>After determining the required marker coordinates, we place the enemy group using the assigned formation method. There are four kinds of formations:</p>

<ul>
  <li>
    <p>BoxFormation - grid-type formation that uses rows and columns.</p>
  </li>
  <li>
    <p>LineFormation - formation along a line.</p>
  </li>
  <li>
    <p>ArcFormation - formation along an arc.</p>
  </li>
  <li>
    <p>FixedFormation - formation that uses fixed coordinates (FormationSlot).</p>
  </li>
</ul>

<p>Other than formations, there is also placement using coordinates defined in <code class="language-plaintext highlighter-rouge">EncounterResourcePrototype</code>. For example, Jessica Jones and Ben Urich in the Avengers Tower are placed this way.</p>

<h3 id="spawner">Spawner</h3>

<p>A <em>spawner</em> is a special entity type that contains information about the number of enemies, their spawn timers, the uniqueness of their spawn distance, and many other parameters. Since spawners are derived from entities, they can be a part of a ClusterObject.</p>

<p>Currently we do not take spawn timers into account, so all enemies spawn at the same time (which occasionally looks overly populated).</p>

<p>One important distinction of spawners is that they place enemies randomly using the <code class="language-plaintext highlighter-rouge">PickPositionInSector()</code> method. To better illustrate how this works, let’s imagine a game of darts:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/darts.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/darts.png" alt="Spawner Darts" /></a></p>

<p>We divide the space in a radius around an object into equal sections, and then we randomly determine the slot we are going to use for spawning. Then we check for collisions with other objects, and if this check fails we randomly pick another spawning point. Currently we do not have any Navi checks, so many enemies spawn in the air or inside walls.</p>

<p>In addition to spawners described in missions and cells, there are also spawners defined in MetaState prototypes.</p>

<h3 id="metastate-spawning">MetaState Spawning</h3>

<p>All region prototypes have a <code class="language-plaintext highlighter-rouge">MetaGame</code> field. We can get MetaState by going through the following sequence:</p>

<center>
Region – MetaGames – GameModes – ApplyStates
</center>

<p>For wave-based regions, such as the S.H.I.E.L.D. Holo-Sim, the path is slightly different:</p>

<center>
Region – MetaGames – GameModes – States
</center>

<p>There are different varieties of MetaStates:</p>

<ul>
  <li>
    <p>MetaStateMissionProgressionPrototype</p>
  </li>
  <li>
    <p>MetaStateMissionActivatePrototype</p>
  </li>
  <li>
    <p>MetaStateMissionSequencerPrototype</p>
  </li>
  <li>
    <p>MetaStateWaveInstancePrototype</p>
  </li>
  <li>
    <p>MetaStatePopulationMaintainPrototype</p>
  </li>
</ul>

<p>Right now we don’t have properly working events in the game, so we just get population objects from the <code class="language-plaintext highlighter-rouge">PopulationRequiredObjectPrototype</code>, and then we retrieve PopulationMarkers, which we then proceed to use as described above.</p>

<p>There is one more type of enemy placements defined in <code class="language-plaintext highlighter-rouge">PopulationThemePrototype</code> instances. Instead of markers, it uses <code class="language-plaintext highlighter-rouge">BlackOutZonePrototype</code> instances and weights. However, we cannot implement this method of spawning without the NaviSystem.</p>

<h3 id="navisystem">NaviSystem</h3>

<p>Over the last month I have been working on reimplementing the NaviSystem, and I have already achieved some results. Essentially, the NaviSystem is a <code class="language-plaintext highlighter-rouge">NaviMesh</code>, which is a set of <code class="language-plaintext highlighter-rouge">NaviTriangles</code> consisting of three <code class="language-plaintext highlighter-rouge">NaviEdges</code> built from two <code class="language-plaintext highlighter-rouge">NaviPoints</code>. The generation process happens in the <code class="language-plaintext highlighter-rouge">NaviCDT</code> class (CDT stands for Constrained Delaunay Triangulation). <a href="https://gwlucastrig.github.io/TinfourDocs/DelaunayIntroCDT/index.html">Here is an article</a> about this technique in case you are interested to learn more.</p>

<p>When we initialize a game region, we create a region-sized rectangle consisting of two triangles. Then we add cell information to <code class="language-plaintext highlighter-rouge">ModifyMeshPatch</code> using <code class="language-plaintext highlighter-rouge">AddNavigationDataToRegion()</code>, which we then use to add points to our NaviMesh by breaking our triangles into smaller <code class="language-plaintext highlighter-rouge">SplitTriangles</code>. Afterwards these points are connected by an edge that splits other edges through <code class="language-plaintext highlighter-rouge">SplitEdge()</code>. After adding all edges, we mark triangles with <code class="language-plaintext highlighter-rouge">MarkupMesh()</code>. We then apply the following <code class="language-plaintext highlighter-rouge">PathFlags</code> as necessary:</p>

<ul>
  <li>
    <p>Walk</p>
  </li>
  <li>
    <p>Fly</p>
  </li>
  <li>
    <p>Power</p>
  </li>
  <li>
    <p>Sight</p>
  </li>
  <li>
    <p>TallWalk</p>
  </li>
</ul>

<p>By knowing the coordinates of a point we can determine what triangle it is in, and this way the game understands whether you can walk, fly, use abilities, or aim in this point.</p>

<p>Here is an animation of how triangles are broken down for the <code class="language-plaintext highlighter-rouge">NPEAvengersTowerHUBRegion</code>:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-03/triangulate.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/triangulate.gif" alt="NaviMesh Generation" /></a>
<p>(Note: P=100 means that 100 NaviPoints were added to the NaviMesh.)</p>
</center>

<p>If we filter the triangles and show only those that contain the Walk PathFlag, we get an outline of the Avengers Tower:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/navimesh.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/navimesh.png" alt="Walkable Triangles" /></a></p>

<p>There is still a work to do with the NaviSystem. For example, it took me three days to find the cause of one of the issues. The system is complex, but it is the foundation of all physics in the game.</p>

<hr />

<p>This is all we have for you today. See you in a month!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: February 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: February 2024" /><published>2024-02-28T15:00:00+03:00</published><updated>2024-02-28T15:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-02/header.jpg" alt="MHServerEmu Progress Report - February 2024" /></p>

<p>February may be the shortest month, but we are definitely not short on progress this time.</p>

<h2 id="the-merging-is-complete">The Merging is Complete</h2>

<p>The biggest news of the month is without doubt that the changes that AlexBond and Kawaikikinou have been implementing and testing on the experimental branch over the past few months have been merged with the master branch. The highlights of these changes include:</p>

<ul>
  <li>
    <p>Fully-featured implementation of DRAG (Dynamic Random Area Generator), which makes all regions not only explorable, but also different between visits. The current system refreshes regions every five minutes as long as there are no players in them, but this is something we will continue to iterate on.</p>
  </li>
  <li>
    <p>Early implementation of the population system, which handles the spawning of entities, including enemies, NPCs, and interactable objects, across the entire game. There is still a lot of work to be done here, including dynamic enemy spawning, but the regions now feel a lot less lonely.</p>
  </li>
  <li>
    <p>Early experiment that allows to deal damage to enemies. This is more of a quick hack than a real implementation, but it does make exploration way more fun.</p>
  </li>
</ul>

<p>This is an important milestone that brings us closer towards our first official “release”, 0.1.0, that we currently expect to happen in March. In addition to what you can see in the current nightly build, it is also going to have some more additional polish, including a streamlined setup process that would not require you to manually configure a web server.</p>

<p>Once that is out, the current plan is to shift our focus back towards fundamentals, including overhauling our entity management and replication systems.</p>

<p>With the important news out of the way, let us take a closer look at some of the more technical happenings of February.</p>

<h2 id="a-song-of-bits-and-bytes">A Song of Bits and Bytes</h2>

<p>What I have personally spent the most of my time working on this month is finally implementing one of the core systems of Marvel Heroes - properties.</p>

<p>All dynamic objects in the game are called <em>entities</em>. This includes player characters (internally called <em>avatars</em>), NPCs, enemies, projectiles, interactable objects, items, and so on. Entities are essentially collections of properties that define their state: what level they are, how much health they have, whether they are visible or not, and so on. Because of their integral role in pretty much all gameplay interactions, everything related to properties is very highly optimized, which makes it very difficult to untangle. If you include all the research and the foundational systems that had to be done beforehand, you could say that implementing properties actually took six months.</p>

<p>A property is a pair of two 64-bit values: a <em>PropertyId</em> and a <em>PropertyValue</em>. As you can probably guess from their names, one identifies a property, and the other contains its actual value.</p>

<p>The simplest form of a PropertyId looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png" alt="Property Id - Combat Level" /></a></p>

<p>The game initializes the so-called property info table and enumerates all property types during startup. Most of the properties are defined in code and are sorted alphabetically by their name. However, there are some additional data-only properties that are sorted by their blueprint id and appended at the end of the enumeration. Overall in version 1.52.0.1700 there are 1030 properties, of which 29 are data-only.</p>

<p>11 of the 64 bits in a PropertyId are allocated to the enum value, so the maximum possible number of property types is <code class="language-plaintext highlighter-rouge">1 &lt;&lt; 11 = 2048</code>. The remaining 53 bits are distributed amongst 0-4 <em>parameters</em>. For example, this PropertyId for a <code class="language-plaintext highlighter-rouge">Waypoint</code> property contains a single parameter that specifies which waypoint this property unlocks:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png" alt="Property Id - Waypoint" /></a></p>

<p>There are three supported types of parameters: integers, prototype ids, and asset ids. However, there is a problem: prototype and asset ids are actually 64-bit hashes, so how are we supposed to fit multiple 64-bit values in the 53 bits we have for parameters? This is where trickery comes in.</p>

<p>During game database initialization the game sorts all 64-bit prototype ids it contains, and then divides them into two types of buckets: by C++ class they bind to, and by Calligraphy blueprint they use. So you end up with arrays of sorted ids for each prototype class and blueprint. And by knowing which array to look in and where, you can retrieve the full id. A similar process happens for assets, so by knowing the asset type and its index you can get the id.</p>

<p>The game databases server-side and client-side are in sync, and the game makes heavy use of this in network communication to reduce the amount of data that needs to be sent back and forth. Instead of sending a number like <code class="language-plaintext highlighter-rouge">421791326977791218</code>, which is the prototype id of the playable Iron Man avatar, you can send just <code class="language-plaintext highlighter-rouge">3</code>, which is the index in the array of prototypes that use the avatar blueprint.</p>

<p>Property types have corresponding prototypes that contain additional metadata, including the types and subtypes (prototype blueprint or asset type) of all parameters. During property info table initialization the game processes all property prototypes and allocates the 53-bit param budget to defined parameters. First, it allocates the amount of bits needed to store the maximum index value for all prototype and asset parameters, and then it splits the remaining bits amongst any integer parameters, up to 31 bits (so only positive integers with a value up of up to <code class="language-plaintext highlighter-rouge">2147483647</code>). For example, here is a PropertyId for an <code class="language-plaintext highlighter-rouge">AvatarLibraryLevel</code> property that defines the displayed level in the hero roster for Iron Man:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png" alt="Property Id - Avatar Library Level" /></a></p>

<p>7 bits are allocated to hold the maximum value of the avatar prototype index, and then 31 of the remaining 46 bits are taken by an integer value. 15 bits in this case are left unused.</p>

<p>Finally, here is an example of a <code class="language-plaintext highlighter-rouge">Proc</code> property that has four parameters:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png" alt="Property Id - Proc" /></a></p>

<p>Param0 is the asset value that defines the proc trigger type, Param1 is the power prototype of the power triggered by this proc, and the remaining params are additional integer values. First <code class="language-plaintext highlighter-rouge">7 + 15 = 22</code> bits are allocated to asset and prototype params, and then the remaining bits are split evenly between integer params, <code class="language-plaintext highlighter-rouge">31 / 2 = 15</code> bits per parameter.</p>

<p>This is not where trickery ends however. Marvel Heroes makes heavy use of the encoding format developed by Google for their <a href="https://protobuf.dev/programming-guides/encoding/">Protocol Buffers</a> technology, and the way it works is that values can take anywhere from one to ten bytes depending on how high they are, with higher values taking more bytes. The number you end up with for a PropertyId often has a lot of zeroes at the end, so you waste a lot of network traffic if you send it as is. To circumvent this, the order of bytes is reversed before serialization: so <code class="language-plaintext highlighter-rouge">0x18E0000000000000</code> from the first example becomes <code class="language-plaintext highlighter-rouge">0x00000000000018E0</code>, or just <code class="language-plaintext highlighter-rouge">0x18E0</code>. However, there is an annoying inconsistency: when serializing a single property instead of a whole property collection, the game reverses the order of individual <em>bits</em> rather than <em>bytes</em>. So <code class="language-plaintext highlighter-rouge">0001 1000 1110 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code> becomes <code class="language-plaintext highlighter-rouge">0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 0001 1000</code>, or just <code class="language-plaintext highlighter-rouge">111 0001 1000</code>, which is equivalent to a hex value of <code class="language-plaintext highlighter-rouge">0x718</code>.</p>

<p>And then we have PropertyValue. Thankfully, this one is not nearly as complicated. There are eleven data types that can be stored in a property value, most of them are simple 64-bit integer or 32-bit floating point values. But there are two funny ones: <em>Curve</em> and <em>Int21Vector3</em>.</p>

<p>With a curve property rather than assigning it a value, you assign it an index property and a curve. And then the value of the curve property gets automatically updated from the curve, using the value of the index property as the curve index. For example, all heroes have a <code class="language-plaintext highlighter-rouge">HealthBase</code> property that uses <code class="language-plaintext highlighter-rouge">CombatLevel</code> as its index. So the value of <code class="language-plaintext highlighter-rouge">HealthBase</code> automatically changes whenever <code class="language-plaintext highlighter-rouge">CombatLevel</code> is updated (i.e. you level up). The default curve used by playable characters, <code class="language-plaintext highlighter-rouge">CharacterHealthMAX.curve</code>, actually goes all the way to level 101 and looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png" alt="HealthBase Curve Property" /></a></p>

<p>With an Int21Vector3 we have a Vector3 to store, which consists of three 32-bit floating point values (X, Y, and Z coordinates), but we only have 64 bits. In this case the compression is lossy: individual values are rounded and cast to integers. The 64 bits are split into <code class="language-plaintext highlighter-rouge">64 / 3 = 21</code> bits per value. The values remain signed, so we end up with 20 magnitude bits + 1 sign bit, which gives us a range from <code class="language-plaintext highlighter-rouge">-1048576</code> to <code class="language-plaintext highlighter-rouge">1048575</code> for each coordinate.</p>

<p>One challenge with implementing PropertyValue has been adapting the original C++ API to C#. Property collections in the client use templates for property getters and setters that look something along these lines:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="o">=</span> <span class="n">properties</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>
</code></pre></div></div>

<p>For the C# API we ended up with a combination of indexers and implicit casting that looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="p">=</span> <span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">];</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">]</span> <span class="p">=</span> <span class="m">60</span><span class="p">;</span>
</code></pre></div></div>

<p>The final piece of the property puzzle is aggregation. A property collection can be attached as a child to another property collection, and the values of the parent are going to be aggregated with the child. Each property collection actually contains two lists of properties: one for base values held in this particular collection, and one for values aggregated with all of its children. This system is what enables, for example, equipping and unequipping items that affect your character’s stats, or applying buffs and debuffs (internally called <em>conditions</em>). There is not too much interesting to say about aggregation, it is just a lot of mundane work to make sure that all values are updated properly.</p>

<p>And with all of that we now have a working property system. We have already started making use of it to replace some of the hardcoded data from captured packets we had to rely on, as well as doing little experiments, like the recently implemented damage dealing hack. One remaining aspect that we are going to have to tackle on in the future is the eval system, which allows properties to be used as variables in scripted formulas (for example, for calculating maximum health taking into account all bonuses and penalties). But that is going to be a whole massive endeavor of its own.</p>

<h2 id="an-interesting-development">An Interesting Development</h2>

<p>As Alex was implemeting region generation and entity spawning, an issue immerged. Turns out loading an entire region worth of environments and entities puts a significant amount of strain on the client, especially if you are running on lower-end hardware. So we needed to come up with a solution, at least a temporary one.</p>

<p>The way this is supposed to be handled is through a process called replication. The server is the “dungeon master”, it is aware of everything happening to everyone, but each client should only be aware of what is relevant to them. Not only does it reduce the amount of data that needs to be exchanged and improve performance, it also helps prevent some forms of cheating, such as map hacking. If the client literally has no information on what lies ahead, it is much harder to peek beyond what should be observable (<del>there is actually a potential way around this, but I am not going to disclose it here</del>).</p>

<p>Internally the game calls the data that needs to be sent to clients their <em>interest</em>, with each client having their own <em>areas of interest</em> (AOI). There are at least five area of interest channels that we are currently aware of:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToProximity</code>: the client needs to know what is happening around its physical location in the game world.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToParty</code>: the client needs to be informed of its party members even if they are not in proximity.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>: some entities should be replicated only to their owners. For example, this is not Diablo II, so only you should be able to see the loot you get from defeating enemies.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToDiscovered</code>: when the client finds an NPC or a transition to another region, the client should still be somewhat aware of the entity, even if they are no longer in proximity with one another (a bit like fog of war in RTS games).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToTrader</code>: when trading items the clients should be aware of what is being traded.</p>
  </li>
</ul>

<p>These channels can be mixed together, like <code class="language-plaintext highlighter-rouge">ReplicateToProximity</code> and <code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>, so the client is aware only of the loot that belongs to it and is in proximity. We are still investigating how this system works, so some of these examples may not be completely accurate.</p>

<p>In the current version of MHServerEmu we now have an early implementation of proximity-based area of interest. This allows us to send cell and entity data as you move in the game world, reducing load times significantly. We also have some additional functionality not present in the original game for players running on ultrawide monitors and/or with a custom camera maximum distance: by typing <code class="language-plaintext highlighter-rouge">!player AOIVolume value</code> in chat you can customize the “draw distance” of entities that are considered to be in proximity.</p>

<p>Replication is a core part of any online game, because it is what keeps all clients synchronized with the game state happening on the server. We will most likely go more in-depth on this in future reports, once it is closer to being finished.</p>

<h2 id="live-tuning">Live Tuning</h2>

<p>One fun thing we were able to do this month is get the live tuning system up and running. This is a system that allowed the developers to do quick hotfixes without patching the game. While somewhat limited compared to changing game data directly, there are some interesting things you can do with it.</p>

<p>For instance, regions have the following live tuning “knobs” available to them:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">RegionTuningVar</span> <span class="p">{</span>
    <span class="na">eRTV_PlayerLimit</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">eRTV_Enabled</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">eRT_BonusXPPct</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">eRT_XPBuffDisplay</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">eRT_BonusItemFindMultiplier</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="na">eRTV_NumRegionTuningVars</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eRTV_Enabled</code> allows the server to disable individual regions. This is how, for example, the Mystic Mayhem in Limbo event is implemented: Limbo is a regular region that is disabled with live tuning unless the event is running. So by turning off this setting we can make Limbo accessible in-game.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg" alt="Live Tuning - Limbo Waypoint" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg" alt="Live Tuning - Limbo" /></a></p>

<p>Or we can go in the opposite direction and disable everything <em>but</em> Limbo. Feels like 2013 again!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg" alt="Live Tuning - Disable Regions" /></a></p>

<p>Another group of tuning parameters affects avatar entities:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">AvatarEntityTuningVar</span> <span class="p">{</span>
	<span class="na">eAETV_BonusXPPct</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="na">eAETV_XPBuffDisplay</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="na">eAETV_EternitySplinterPrice</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="na">eAETV_Enabled</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="na">eAETV_NumAvatarEntityTuningVars</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eAETV_Enabled</code> here works similarly to regions, allowing us to disable individual heroes. One possible use for this feature could be implementing an Infinity War themed event where half of the playable heroes would be picked randomly and disabled for the duration of the event.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg" alt="Live Tuning - Disable Avatars" /></a></p>

<p>All the tuning parameters are defined in the protocol and can be found <a href="https://github.com/Crypto137/MHServerEmu/blob/master/proto/CommonMessages.proto#L42">here</a>. You can experiment with them yourself by editing <code class="language-plaintext highlighter-rouge">LiveTuningData.json</code> located in <code class="language-plaintext highlighter-rouge">MHServerEmu\Data\Game\</code>.</p>

<hr />

<p>This is all we have to share today. Thank you very much for following the development of MHServerEmu. See you next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: January 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: January 2024" /><published>2024-01-30T03:06:40+03:00</published><updated>2024-01-30T03:06:40+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-01/header.jpg" alt="MHServerEmu Progress Report - January 2024" /></p>

<p>Hello there! The first month of 2024 is now almost behind us, and we have been hard at work on all things Marvel Heroes. Let us dive right in!</p>

<h2 id="calligraphyserializer-is-a-lie">CalligraphySerializer is a Lie</h2>

<p>Before continuing I strongly suggest you read the reports from <a href="/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html">November 2023</a> and <a href="/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html">December 2023</a> if you have not done so already. You have been warned.</p>

<p>Most of my time in January has been spent untangling the web that is the <code class="language-plaintext highlighter-rouge">CalligraphySerializer</code> class. And the fun begins right from the name: despite being called a “serializer”, it literally cannot serialize any data. It is used strictly for deserialization of Calligraphy prototypes. You literally cannot trust things to do what they say they do.</p>

<p>What it actually does can be summarized like this:</p>

<ol>
  <li>
    <p>It takes a blank prototype instance of a certain type as input.</p>
  </li>
  <li>
    <p>If the prototype references a parent prototype, the parent data is copied to the child. If the parent has not yet been loaded, it goes through the deserialization process itself, and this continues until all parents are loaded.</p>
  </li>
  <li>
    <p>All serialized Calligraphy field groups are processed. Regular field group have their fields matched to fields defined in the prototype class, its parents, and mixin fields, and then deserialized using the appropriate parser method. Property field groups represent individual properties and are used to reconstruct property collections.</p>
  </li>
  <li>
    <p>A prototype can have embedded prototypes, so this whole process is recursive.</p>
  </li>
</ol>

<p>As of right now, we have most of the regular field group processing working, but we still need to implement property collection reconstruction, as well as some small things here and there. Our overall current implementation progress is represented in the following diagram:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png" alt="CalligraphySerializer WIP" /></a></p>

<p>One of the biggest challenges I have had to deal with implementing this has been matching serialized fields to appropriate class fields. The client uses a custom <a href="https://en.wikipedia.org/wiki/Run-time_type_information">run-time type information</a> system for this called GRTTI. While it should be technically possible to reimplement GRTTI, it would also be somewhat like reinventing the wheel when our server emulator is written in C#, which already has very strong reflection capabilities that can be used to get a very similar result.</p>

<p>C# reflection has its drawbacks though: while extremely flexible, it is notoriously slow, and when you have to use it literally hundreds of thousands of times, it really adds up. In one of our unoptimized testing cases it took over 80 seconds to load all prototypes, while the original game did it in 3. In the end, with some targeted result caching, I have been able to get it to a pretty reasonable time of about 12 seconds, which should be more than good enough for our current needs. There is always more room for more optimization, but that is going to come later on. It should also be noted that all of this is a one-time cost during server startup, and if you do not have prototype frontloading enabled, you are most likely not going to notice this at all.</p>

<p>Another big issue that has come up has been taking care of mixins. While most embedded prototypes can be handled with recursion, there are some very specific cases where you have so-called mixin prototypes that need to be deserialized as if they were a part of the prototype itself. Their field groups are mixed with regular field groups (which is where I am guessing the name is coming from), and there are cases where you have entire collections of mixin prototypes. There is a significant amount of extra code that handles mixins specifically, and they are used in literally only three prototypes classes (out of over a thousand) in the entire game: <code class="language-plaintext highlighter-rouge">LocomotorPrototype</code> and <code class="language-plaintext highlighter-rouge">PopulationInfoPrototype</code> in <code class="language-plaintext highlighter-rouge">AgentPrototype</code>, <code class="language-plaintext highlighter-rouge">ProductPrototype</code> in <code class="language-plaintext highlighter-rouge">ItemPrototype</code>, and lists of <code class="language-plaintext highlighter-rouge">ConditionPrototype</code> and <code class="language-plaintext highlighter-rouge">ConditionEffectPrototype</code> in <code class="language-plaintext highlighter-rouge">PowerPrototype</code>. So in the case of list mixins there is literally a single prototype class that this entire subsystem exists for.</p>

<p>While there has been very good progress, the work on CalligraphySerializer is still not done. It is now possible to access a lot of the game data from code and use it in features like region generation, but there are still some aspects of mixin fields that need to be finished, as well as the property system, which is tightly tangled with the entire game.</p>

<h2 id="pipeline-improvements">Pipeline Improvements</h2>

<p>Another thing I have been able to work on this month is some general improvements to our delivery pipeline.</p>

<p>First of all, MHServerEmu now clearly states its version, build time, and build configuration:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png" alt="MHServerEmu Versioning" /></a></p>

<p>This is a pretty minor change, but it is going to make it much easier to figure out and solve issues as they arise.</p>

<p>Also, we now have automated nightly builds powered by GitHub actions and <a href="https://nightly.link/">nightly.link</a>. Thanks to that, if you want to try MHServerEmu out, instead of building the source code yourself, you can just download the latest build <a href="https://nightly.link/Crypto137/MHServerEmu/workflows/nightly-release-windows-x64/master?preview">here</a>. Those builds are based on the the latest <code class="language-plaintext highlighter-rouge">master</code> branch code, and are in general a decent representation of our current progress.</p>

<p>These small steps bring us closer towards a big milestone, which would be our first official binary release, tentatively numbered 0.1.0. We are going to talk more about that in the future.</p>

<h2 id="here-comes-a-new-challenger">Here Comes a New Challenger!</h2>

<p>This month our development team has expanded by 50%: <strong>Kawaikikinou</strong> has joined me (Crypto137) and AlexBond in restoring Marvel Heroes back to its glory.</p>

<p>MHServerEmu is a very complex project that involves many moving parts, so some time had to be spent to bring our new team member up to speed with what we are working on, but there are already some results that can be seen. So far Kawaikikinou has been mostly helping AlexBond with ironing out issues with region generation (more on that later), as well as improving the reliability of our code by introducing unit testing.</p>

<p>Another thing I am personally very excited about is <a href="https://github.com/Kawaikikinou/MHLogHelper">the new region visualization tool</a> he developed. Knowing is half the battle, and getting a better visual idea of what exactly is going on on the backend is going to be very helpful in the long run.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png" alt="MHLogHelper Screenshot 1" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png" alt="MHLogHelper Screenshot 2" /></a></p>

<h2 id="the-joy-of-region-generation-with-alexbond">The Joy of Region Generation with AlexBond</h2>

<p>This time I am joined by a co-writer: in this section AlexBond is going to go in-depth on what is happening behind the scenes with region generation.</p>

<hr />

<p>Hello everyone. I am AlexBond, and I am working on reimplementing the region generation. We are lucky to have the region generation code ifself present in the client, but it is disabled. Most likely it was among common game files, which is why it ended up in the client, or maybe the developers had the option to enable it for testing. In any case, in two months I was able to reimplement the region generation in C#.</p>

<p>Of course, I am not without faults, so we ended up with a number of bugs. So this month me and <strong>Kawaikikinou</strong> have been testing this new code and fixing all the issues. As of the time of writing, we have tested regions up to chapter 3, and it is also possible to load into other chapters with some workarounds. Our goal is to get an exact copy of a region generated by the client when it has generation enabled. We do the comparisons using logs and the IDA debugger. Over the course of testing I was able to get a slightly better understanding of the generation process, I would like to share with you what I have discovered.</p>

<h3 id="region-prototype">Region Prototype</h3>

<p>A region prototype contains information about the type of generator a region uses. There are three region generators in total, but for now we are going to take a look at the most complicated and interesting one - <code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code>.</p>

<p><code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code> is a generator that describes a tree of <em>areas</em>, and this tree contains all possible variations with weights for each one. Branches of this tree contain area prototypes. Overall this can be represented as a kind of a chain sequence:</p>

<center>Area 1 - Area 2 - Area 3 - an so on</center>

<p>The <code class="language-plaintext highlighter-rouge">ProcessSequence()</code> function runs recursively through the tree of areas. During its run it uses a random seed to determine sequences (<code class="language-plaintext highlighter-rouge">PickSequence()</code>), areas (<code class="language-plaintext highlighter-rouge">PickArea()</code>), their positions and connections to other areas (<code class="language-plaintext highlighter-rouge">PickAreaPlacement()</code>), and in the end it runs the generator of the current area. This recursion goes through the entire tree from the end to the beginning.</p>

<p>For example, in Madripoor it goes like this:</p>

<center>LowTown -&gt; Cove -&gt; BambooForest -&gt; Beach</center>

<p>If an area generator runs into an error, all previous areas are destroyed and rebuilt until the error disappears. To prevent infinite rebuilds, there is a special parameter called <code class="language-plaintext highlighter-rouge">MaxGenerationTimeInSec</code>, but currently I am not using it (perhaps I should).</p>

<h3 id="area-prototype">Area Prototype</h3>

<p>An area prototype defines the type of generator and the cell generation rules. In total there are seven different area generators, but I would like to talk about the most commonly used ones - <code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> and <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> (<code class="language-plaintext highlighter-rouge">GridAreaGenerator</code>).</p>

<h4 id="cellgridgenerator">CellGridGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">CellGridGenerator</code> is a rectangle of cells, and the size of this rectangle is defined in the area prototype.</p>

<p>The generation process includes ten attempts of creating an arrangement of cells that adheres to certain requirements. Now I am going to describe creation functions.</p>

<p><code class="language-plaintext highlighter-rouge">InitializeContainer()</code> - creates a <code class="language-plaintext highlighter-rouge">CellContainer</code> with a size of <code class="language-plaintext highlighter-rouge">CellsX</code> by <code class="language-plaintext highlighter-rouge">CellsY</code>. This is just a rectangle for holding cells that are going to be added.</p>

<p><code class="language-plaintext highlighter-rouge">EstablishExternalConnections()</code> - defines which sides are going to have cells for connecting to adjacent areas.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRandomInstanceLinks()</code> - defines connections to various <code class="language-plaintext highlighter-rouge">RandomInstances</code> (not all regions contain those).</p>

<p><code class="language-plaintext highlighter-rouge">CreateRequiredCells()</code> - defines groups of cells to be placed:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredSuperCells</code> - places consisting of multiple cells (mostly 2x2), like the Fall Tribe village in Savage Land, or buildings.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredSuperCells</code> - this type is used only in the <code class="language-plaintext highlighter-rouge">MutateMarshArea</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RegionTransitionSpec</code> - these are mostly places for waypoints and entrances to various treasure rooms. These places are determined using teleports contained in <code class="language-plaintext highlighter-rouge">RegionConnectionNodePrototype</code> that exit to this region.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RandomInstances</code> - a list of random places, these are not in the game…</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredCells</code> - these are special places that must be present in an area, like shops or cafes (e.g. <code class="language-plaintext highlighter-rouge">Madripoor_Lower_BobaTeaPOI_A</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredPOICells</code> - cells from <code class="language-plaintext highlighter-rouge">POIGroups</code>, I cannot say for sure what they are (they appear in <code class="language-plaintext highlighter-rouge">Wakanda</code>, <code class="language-plaintext highlighter-rouge">DangerRooms</code>, <code class="language-plaintext highlighter-rouge">CowRegion</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredNormalCells</code> - another group of cells, used in <code class="language-plaintext highlighter-rouge">HellsKitchen</code> (<code class="language-plaintext highlighter-rouge">Brownstone_C_Barricade_ESW_A</code>).</p>
  </li>
</ul>

<p>Now we have a filled <code class="language-plaintext highlighter-rouge">CellContainer</code> with a number <code class="language-plaintext highlighter-rouge">CellRefs</code>, and if it is successful we can move onto destroying and adding cells to the current area.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousCells()</code> - this process uses <code class="language-plaintext highlighter-rouge">RoomKillChancePct</code> to determine the number of cells that need to be destroyed using the <code class="language-plaintext highlighter-rouge">RoomKillMethod</code>. There are three deletion methods - Random, Edge, and Corner. When deleting cells there are checks for paths between imporant points, and only the cells that can be safely removed without breaking those paths are removed.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousConnections()</code> - removes redundant connections between cells using <code class="language-plaintext highlighter-rouge">ConnectionKillChancePct</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> - the main function that randomly picks cells for creation. If a cell has not been previously defined, it is going to be picked from the appropriate <code class="language-plaintext highlighter-rouge">CellSet</code> based on cell type.</p>

<p>At this point <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> either succeeds or fails. If it fails, all areas are destroyed and regenerated.</p>

<h4 id="widegridareagenerator">WideGridAreaGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> differs by having <code class="language-plaintext highlighter-rouge">GenerateRoads()</code> and <code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code>, as well as a different implementation of <code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> that picks cells based not on their type, but <code class="language-plaintext highlighter-rouge">RequiredWalls</code>.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRoads()</code> - defined by the Roads prototype in the generator. This function uses the <code class="language-plaintext highlighter-rouge">DijkstraRoad()</code> method based on the <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> for finding the shortest path between nodes.</p>

<p><code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code> - if the <code class="language-plaintext highlighter-rouge">ProceduralSuperCells</code> field contains data, it creates a random set for a 2x2 square and rotates it randomly.</p>

<p>Here is an example of generation for <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaA</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 4<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Corner</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>X</td><td>X</td><td></td><td>X</td></tr><tr><td>B</td><td></td><td></td><td>A</td></tr></table></div>
</div>

<p>As we can see, in this case the path from A to B is preserved, and 60% of the cells were removed using the corner method.</p>

<p>This is what we get in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png" alt="Region Generation Example 1" /></a></p>

<p>Now let us take a look at the next area, <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaC</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 3<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Random</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td></td><td>B</td></tr><tr><td>C</td><td></td><td>X</td></tr><tr><td>X</td><td>X</td><td>X</td></tr></table></div>
</div>

<p>As we can see, in this case the path from B to C is preserved and 60% of the cells were removed using the random method.</p>

<p>And here is what it looks like in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png" alt="Region Generation Example 2" /></a></p>

<p>Hopefully now it should be more clear how all of this functions.</p>

<p>As for my work, recently I have merged the new prototype system written by Crypto137, and now the testing of generation is much faster, and it is going to be easier to merge with the main repository. But we still have a lot of tests to do, so please be patient.</p>

<hr />

<p>Back to Crypto to wrap things up. We are getting very close to finally reaping the fruits of our efforts over the past few months, and hopefully we will be able to deliver results that are more visible in-game soon enough. We are just as excited as you are to finally see some things come together. Until next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: December 2023</title><link href="https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: December 2023" /><published>2023-12-25T11:00:00+03:00</published><updated>2023-12-25T11:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2023-12/header.jpg" alt="MHServerEmu Progress Report - December 2023" /></p>

<p>Happy holidays everyone! This month and year are coming to an end, and it is time for another MHServerEmu progress report.</p>

<h2 id="game-database-update">Game Database Update</h2>

<p>In December there has been significant progress reimplementing the game database. If you have not yet read <a href="/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html">the last month’s report</a>, I suggest you go and do that right now, because what is coming is very much a continuation of that post.</p>

<p>The most significant milestone we have been able to achieve this month is restoring the original hierarchy of prototypes. This allows us to understand relationships between various pieces of data and make use of them.</p>

<p>For example, MHServerEmu has a command that allows you to look up costumes, <code class="language-plaintext highlighter-rouge">!lookup costume</code>. Previously it was implemented by iterating through all data files and checking every single file path for a certain pattern. This approach has always been a temporary solution: it is slow and it relies on files being consistently named (spoiler: they are not). What we can do instead now is just get a collection of all prototypes that reference the costume blueprint. This reduces pattern matching complexity and the number of iterations we have to do, and removes the reliance on naming. To put it in simpler terms, it is much faster and more convenient.</p>

<p>The prototype hierachy is also going to be essential for implementing the property system, which is the foundation of all game entities, such as player avatars and enemies. We are going to go into more detail on this topic in a future report, once it is actually up and running.</p>

<p>Another thing this development has allowed us to do is make some charts. Exciting, am I right?</p>

<p>First we have a chart of top 30 most used prototype classes. These use standard inheritance, so there is some overlap here (e.g. all world entity prototypes are also entity prototypes).</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/top-prototype-classes.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/top-prototype-classes.png" alt="Top 30 Most Used Prototype Classes" /></a></p>

<p>Next is top 30 most referenced blueprints. These function more like composition: entities at their core are collections of properties, such as their level or maximum health, and what properties an entity is supposed to have is defined by referencing individual property blueprints.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/top-blueprints.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/top-blueprints.png" alt="Top 30 Most Referenced Blueprints" /></a></p>

<p>However, while restoring the hierarchy is an important step, this is just one piece of the puzzle. Since there is a lot of interdependency between pieces of data, everything has to be loaded in the right order, or else things are going to get very messy very fast. So there has also been ongoing work on restoring various underlying systems that are going to allow us to do just that.</p>

<p>A good example of such system is on demand prototype loading. A naive approach that we used to take is to load all 93144 prototypes on startup in the order they are stored. Other than loading in the wrong order, this way we also load a lot of unnecessary data, including prototypes for cut and unfinished content, as well as debug prototypes that are disabled in shipping versions of the game. Although optimization is not really a high priority for us right now, it is still good to keep it in mind, especially when it comes as a side effect of doing something else.</p>

<p>So we have reverse engineered the solution Gazillion had: store all data in memory compressed using the <a href="https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)">LZ4</a> algorithm and decompress and deserialize only what is requested. By doing it this way we not only gain control over what is loaded and in what order, but also get some convenient savings on initial memory usage and initialization time. And this is despite the fact that we now spend additional memory and time on initializing and storing the hierarchy cache!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/memory-usage.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/memory-usage.png" alt="MHServerEmu Initial Memory Usage" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-12/game-database-initialization-time.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-12/game-database-initialization-time.png" alt="MHServerEmu Game Database Initialization Time" /></a></p>

<p>This is going to be especially useful for playing solo offline on lower end hardware. For potential larger scale servers this may cause hitching if too much new data is requested at once, and for that we have implemented an option to frontload all data in the correct order that is also present in the original game.</p>

<p>As we implement additional functionality, these numbers are going to gradually go back up. However, considering the amount of unused data I mentioned previously, even after loading all the relevant data it may end up using less memory than loading everything without storing a compressed copy.</p>

<p>Despite the great progress we have had with the game database this month, there is still work to be done. As I write this, we are approaching a point where we will be able to implement proper deserialization for Calligraphy prototypes, which is the biggest roadblock for working on game systems. When that happens, we are going see more things happening in-game.</p>

<h2 id="region-generation-update">Region Generation Update</h2>

<p>Meanwhile, as I have been working mostly on the game database, Alex continues his efforts on reimplementing the procedural region generation. If you have not yet, you can check his progress in the <a href="https://github.com/AlexBond2/MHServerEmu/tree/experimental">experimental branch</a>.</p>

<p>We are lucky to have most of the logic for procedural generation in the client. However, implementing it still proved to be a very laborious process due to how intricate and occasionally buggy the original code is. Once all the pieces are done and put together, this, along with the game database, is going to make all regions in the game explorable and, where applicable, randomly generated, as they should be.</p>

<p>To keep everything as authentic as possible and avoid future replication issues we try to stick to the disassembled original code as much as possible. This includes reimplementing even the basic building blocks that are usually already taken care of by various existing game engines these days.</p>

<p>One example of such building block are quadtrees, which is a data structure commonly used in video games for optimization. For instance, if you were to do collision detection without any tricks, you would have to check every single object against every other object, so the number of checks you would have to do would increase exponentially with the amount of objects in your game (which is the ultimate evil in computer science, also known as an O(n²) algorithm).</p>

<p>But when you think about it, it does not make any sense to check for collisions against far away objects. So it is common to divide space into sections, and do checks within each section separately. This is where quadtrees come in: they are used to divide objects into four sections (quads), but they are also trees, so each section can have subsections of its own. This may be a little difficult to grasp in writing, so here is a visualization of collision detection using quadtrees I found on YouTube:</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/TJzq_kjtGTc" frameborder="0" allowfullscreen=""></iframe></div>

<p>Although the Marvel Heroes game client is built using Unreal Engine 3, the game logic actually running everything is all custom Gazillion code. In a way this resembles the semi-recently released Diablo II Resurrected, where the original game is running underneath a new graphical engine. Except in the case of Marvel Heroes the “original game” does not have any graphics of its own.</p>

<p>So when we reimplement things such as quadtrees, we have to figure out and take into account all the original quirks. For example, the Marvel Heroes implementation of this data structure uses what is known as an intrusive circular linked list for storing its elements: each element is linked to elements before and after it, these links are stored within the element itself rather externally (which is why it is intrusive), and the link to the next element at the end of the list points back to the first element (circular).</p>

<p>This is just one example of the work that goes into restoring this system. The good news is, region generation is also steadily approaching testable state, and once everything is ready to combine it with the game database implementation, we are going to have a lot of fun.</p>

<h2 id="core-system-improvements">Core System Improvements</h2>

<p>In December I have also taken some time to do a pass on some of the foundational systems of MHServerEmu that could have used some extra work.</p>

<p>Previously we used a TCP server implementation ported from a Diablo III Beta server emulator that was in development in 2011-2012. This is the part of the server that handles client connections, as well as receiving and sending data. While this implementation does get the job done, it never got the chance to get polished, and it was built on an obsolete design pattern known as <a href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm">asynchronous programming model (APM)</a>. So this month I have written a new implementation based on the newer and hipper <a href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">task-based asynchronous pattern (TAP)</a>, which is hopefully going to be cleaner and more maintainable.</p>

<p>Another piece ported from the Diablo III server is our logging system. I was mostly happy with it, however one issue it had was the fact that it was synchronous, meaning that while something was being logged nothing else could be happening on the caller thread. This was an issue for logging large quantities of messages from the main game thread, which is supposed to update on a 50 millisecond cycle. And instead of the game running, everything had to wait until messages finished printing in the console window. This problem is gone: log messages are now enqueued synchronously allowing us to get accurate timestamps for each message, but the output happens asynchronously as a separate task. So now the impact of logging on game performance is just about as low as it can get without compromises.</p>

<p>Finally, as a test for doing Calligraphy prototype deserialization later on, I have improved our configuration system using the reflection capabilities of C#. This is not something that is going to affect the end user, but it has made adding and removing various server settings easier.</p>

<p>The end goal is to have not just something that is capable of running the game, but it also being maintainable and reasonably fast, so expect the work on this front to continue.</p>

<h2 id="miscellaneous-updates">Miscellaneous Updates</h2>

<p>Here are some additional points I would like to highlight without dedicating entire sections to them:</p>

<ul>
  <li>
    <p>We now have a tool for unpacking and packing <code class="language-plaintext highlighter-rouge">.sip</code> files. This is the first step for modding game data files. You can grab the source code for it <a href="https://github.com/Crypto137/MHServerEmu/tree/master/tools">here</a>.</p>
  </li>
  <li>
    <p>The work on documenting various versions of the game mentioned in the previous report continues. There is now <a href="https://github.com/Crypto137/MHProtobufs">a new repository</a> for documenting the evolution of the game’s network protocol.</p>
  </li>
</ul>

<hr />

<p>That’s it for today. A lot has happened this year, and even more exciting stuff awaits us in the next. See you next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: November 2023</title><link href="https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: November 2023" /><published>2023-11-28T03:00:00+03:00</published><updated>2023-11-28T03:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2023-11/header.jpg" alt="MHServerEmu Progress Report - November 2023" /></p>

<p>Hey everyone! Crypto here with the very first MHServerEmu progress report. I will try to do these semi-regularly to shine a light on all the latest things we are working on. Without further ado, let’s dive right in!</p>

<h2 id="game-database">Game Database</h2>

<p>While things have been on the quiet side this month, it doesn’t mean nothing is happening. Our biggest roadblock has been the game database, and its rebuilding will most likely remain our highest priority for the foreseeable future. So what is it and why does it take so long?</p>

<p>The thing is, Marvel Heroes is engineered in a way that’s somewhat unusual for an online RPG. Usually the client contains the bare minimum of information it needs to function, and one of the most time-consuming parts of reverse engineering a server for a game like this is collecting data and creating an approximation of things like where all the enemies should be, how much damage they should deal, what loot they should drop, their AI, scripting, and so on. This can be done using sophisticated tools that analyze packets received from the server, by watching what is happening in-game, or even by simply guessing in some cases. The problem is, the servers for Marvel Heroes are long gone, and it’s impossible to gather any new data, right? Not necessarily.</p>

<p>As we discovered doing our research, the game client actually contains a complete mirror of all the data used by the server. In a way, Marvel Heroes is built more like a single player game with an optional multiplayer mode, not unlike Diablo II, but where the single player functionality was stripped out at the last moment. So while the client lacks the “glue” that keeps everything together, all the individual pieces that make the game what it is, also known as prototypes, are completely preserved. But there’s a lot of pieces (there are 93114 prototypes in the version we are currently working with, and thousands more of auxiliary data files), and putting them together is tricky.</p>

<p>Gazillion developed their own custom framework for managing game data called <em>Calligraphy</em>. It appears most of the actual game was made with it, and it must have also included a set of custom tools reminiscent of programs like the Warcraft III World Editor:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/warcraft-3-trigger-editor.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/warcraft-3-trigger-editor.jpg" alt="Warcraft III Trigger Editor" /></a></p>

<p>In fact, this is a common way of developing video games, also known as data-driven design. Engineers develop a set of tools that expose various systems to game designers, who in turn define what the actual game is supposed to be through data, like what abilities should a hero have access to and how much damage should an enemy deal. These tools often contain some form of scripting functionality that allows designers to also define behaviours (like the trigger editor from Warcraft III shown on the screenshot above).</p>

<p>So while we do have all the original data for Marvel Heroes, to make use of it we also need to reverse engineer the framework it ran on. Calligraphy is a pretty powerful one: it features pretty advanced scripting capabilities and was used to define enemy AI, mission logic, damage formulas, and much more. And as we know, with great power comes great responsibility: there is a lot of moving parts, and just setting everything up requires a lot of steps.</p>

<p>A good example of this is the hierarchy of data:</p>

<ul>
  <li>
    <p>To interface with loaded data, there are over a thousand C++ classes that heavily rely on inheritance.</p>
  </li>
  <li>
    <p>Data is deserialized into these classes using a combination of blueprint and prototype files: blueprints contain field definitions, and prototypes contain the actual values.</p>
  </li>
  <li>
    <p>Each blueprint is paired with a default prototype that contains default values for a given blueprint. Most of the prototypes that are actually used in the game inherit from these default prototypes and override values as needed. For example, there is a blueprint / default prototype for an avatar, and prototypes for each playable hero override this default avatar prototype. This is a simple example, but there are often multiple levels of data inheritance here.</p>
  </li>
  <li>
    <p>Blueprints have their own inheritance that is really more like composition: each blueprint defines its own field group, but it can also reference other blueprints. And then a prototype gets its field groups from the blueprint it is directly bound to and all the other blueprints referenced in it.</p>
  </li>
  <li>
    <p>Some prototypes have “mix-in” prototypes that you are supposed to pass some of the field groups to.</p>
  </li>
  <li>
    <p>There are also resource prototypes that completely ignore everything mentioned above and use custom deserialization routines. However, they still fit into the same C++ class hierarchy.</p>
  </li>
</ul>

<p>As you can see, there’s a lot to unwrap here, and the devil is in the details. So figuring out all of this has been very time consuming, but progress is definitely being made. And once we get it all up and running, it’s going to open the way for implementing all sorts of in-game systems.</p>

<h2 id="mhdataparser">MHDataParser</h2>

<p>When we began investigating what data even was present in the client, we started by examining various file types on their own, and that led to the server emulator getting some data parsing and exporting functionality. As our understanding of the bigger picture grew, it became evident that rather than using the data structures present in the files as is, the game actually does a significant amount of post-processing during initialization. So it became harder and harder to maintain this functionality as our implementation of the game database matured.</p>

<p>However, there is a lot of value to having raw data parsed and represented as is in a more readable format. It’s more version-agnostic, it can be used for datamining, and eventually it can even be expanded for modding game data. So, to keep the main codebase clean while not losing anything, I separated raw data parsing into a separate tool called <a href="https://github.com/Crypto137/MHDataParser">MHDataParser</a>. I tested it with various builds of the game, and so far it seems to work on PC clients going as far back as June 2015, as well as console ports. It won’t work with 2013-2014 versions of the game due to data archive format differences, but implementing support for them is definitely possible in the future.</p>

<p>It’s essentially a piece cut from an older MHServerEmu version, so it works very similarly: you copy game data files to the tool’s subdirectory, run it, wait for it to initialize, and then enter commands to export the data you want to human-readable JSON/TSV files. However, all the file definitions are up to date with the latest versions of the server, and there’s even a little bit of extra functionality that allows you to parse and export locale and string files.</p>

<p>As I was working on this, I made a pretty hilarious discovery: in earlier versions of the game there is a hidden “Pig Latin” localization that was used for testing:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-login-screen.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-login-screen.jpg" alt="Pig Latin Login Screen" /></a></p>

<p>And with a little bit of file renaming, hex editing, and config adjustment I was able to get it running in version 1.52:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-mission-log.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-mission-log.jpg" alt="Pig Latin Mission Log" /></a></p>

<p>Not even S.H.I.E.L.D. Agent Stan Lee is safe from it (or should I say, Say.Hay.Iay.Eay.Lay.Day Agentay Anstay Eelay):</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-stan-lee.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/pig-latin-stan-lee.jpg" alt="Pig Latin Stan Lee" /></a></p>

<p>Having fun aside, this is actually a working proof-of-concept for translating the game into more languages. And way more ambitious mods may also be possible far in the future.</p>

<h2 id="region-generation">Region Generation</h2>

<p>Even though a lot of our efforts has gone into solving the game database conundrum, Alex has also been working very hard on reverse engineering procedural region generation. While it’s still very much work-in-progress. I will give you a brief overview of what it entails.</p>

<p>As you probably know, Marvel Heroes has a lot of Diablo DNA that brings with it heavy reliance on procedural generation, so every time you play the game you can explore slightly different zones, fight different enemies, and get random loot. The game world is actually structured like this:</p>

<ul>
  <li>
    <p>There is a number of <em>games</em> running on a server. Each game is very similar to games on Battle.net in Diablo II, but you transition in and out of them seamlessly.</p>
  </li>
  <li>
    <p>Each game hosts a number of <em>regions</em>, which are places like Avengers Tower, Midtown, and so on. As you transition between regions, you also often transfer between different games and even servers.</p>
  </li>
  <li>
    <p>Each region consists of <em>areas</em> that have their own names and other characteristics. You can go to different areas in a region without a loading screen by moving around. For example, in the Madripoor region the first area would be Buccaneer Beach, from which you can go to Bamboo Forest, and then eventually reach Lowtown.</p>
  </li>
  <li>
    <p>Each area is built from <em>cells</em>, which are basic building blocks of the game world.</p>
  </li>
</ul>

<p>The way Marvel Heroes approaches area generation is actually very similar to Diablo III, and I highly recommend watching <a href="https://www.youtube.com/watch?v=tUFvhDOPA_w">this talk on Diablo Dungeon Design</a> by Ed Hanes from Blizzard, where he goes quite in-depth and even demonstrates some of their internal tools. Unfortunately, the video is age-restricted, so I can’t embed it here, but I will add some of the slides relevant to Marvel Heroes.</p>

<p>Cells, just like tiles in Diablo, are classified by their cardinal directions:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-cardinal-directions.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-cardinal-directions.jpg" alt="Diablo III Tile Cardinal Directions" /></a></p>

<p>These cells are combined into areas according to sets of rules defined by game designers in development tools like these:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-procedural-layout.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/diablo-3-procedural-layout.jpg" alt="Diablo III Procedural Layout" /></a></p>

<p>Marvel Heroes uses a number of different region and area generators for various cases:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/region-generators.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/region-generators.png" alt="Diablo III Procedural Layout" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/area-generators.png"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/area-generators.png" alt="Diablo III Procedural Layout" /></a></p>

<p>Some regions are actually static and do not use procedural generation. But they still follow the same general rules and are built out of cells: regions like Avengers Tower can get away with using a single huge cell, while places like Midtown are collections of regular cells in a predefined layout, also known as a district.</p>

<p>Region generation heavily relies on data from the game database, so it won’t be out for a little while, but there may be something exciting happening in the experimental branch sooner.</p>

<h2 id="documentation">Documentation</h2>

<p>Another thing that happened this month is that I took some time to overhaul our <a href="https://github.com/Crypto137/MHServerEmu/blob/master/docs/Index.md">documentation</a>:</p>

<ul>
  <li>
    <p>All existing information was restructured and updated with latest discoveries.</p>
  </li>
  <li>
    <p>There are two new sections: <em>Networking</em> lays out some of our understanding of the client &lt;-&gt; server communication, while <em>Game Data</em> focuses on the intricacies of file formats, prototypes, and all the other game database related topics.</p>
  </li>
</ul>

<p>While it’s still nowhere near its final form, hopefully this will help potential developers get up to speed with what we’ve been doing. When I first started doing this, the lack of pretty much any publicly available technical information on Marvel Heroes was one of the hardest hurdles to overcome, especially when compared to many other well-documented online games.</p>

<p>If you have any suggestions for topics you would like to see covered, be sure to let us know!</p>

<h2 id="version-research">Version Research</h2>

<p>On a separate note, I’ve been doing some digging into the various versions of Marvel Heroes that we have access to. As you may know if you’ve read our documentation, there are almost 700 different client builds still available to download from Steam if you have ever played the game and still have a license on your account. So what I’ve been doing is downloading and documenting every single one of them. It’s a massive amount of data to go through, and you may wonder if it’s even worth doing. In my opinion, it is, for three reasons: preservation, getting additional data to reference, and finding internal builds.</p>

<p>Preservation should be pretty self-explanatory. As a live service game, Marvel Heroes went through a lot, and many of these moments were rather fleeting. Be it resource gathering to open the Bifrost for the very first time, some event you spent a few too many hours grinding through the night, or just a memorable login screen, to have definitive records of all of this we need old versions of the game.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/GZul9BIN4F0" frameborder="0" allowfullscreen=""></iframe></div>

<p>Another important result of this task is getting additional data to reference, which can be extremely useful for development. A very good example of this is version 1.25 released on July 31, 2014. The following was mentioned in the <a href="https://web.archive.org/web/20150101185936/http://forums.marvelheroes.com/discussion/118449/marvel-heroes-2015-1-1-patch-notes">patch notes</a> by the infamous master of spoilers Doomsaw himself:</p>

<blockquote>
  <p>This update features major changes to how the game processes certain aspects of data, including how data it transmitted to you and players around you.</p>

  <p>This will result in a decent improvement to server performance as well as client performance, depending on your exact system specs, CPU and GPU.</p>
</blockquote>

<p>To explain what it really means we need to go through some fundamental aspects of the game’s netcode. At the heart of it are Google’s Protocol Buffers (protobufs): in case you are unfamiliar with them, they are kind of like XML or JSON, but instead of human-readable text files your data is serialized into binary using a custom <em>wire format</em>. They are widely used in video games (for example, Blizzard does a lot of Battle.net communication with protobufs), however they are a general-purpose technology that can be sub-optimal in cases where you have thousands of messages to process, and every microsecond counts.</p>

<p>To work around this, Gazillion developed a custom archive system based on the protobuf wire format. Without going too in-depth here, what they essentially did is cut all the extra bells and whistles that make protobufs more flexible while keeping all the tricks that reduce message size and serialization time. And a significant part of the optimizations done in 1.25 is actually taking some of the “heavier” and frequently used protobuf messages (<code class="language-plaintext highlighter-rouge">NetMessageEntityCreate</code>, <code class="language-plaintext highlighter-rouge">NetMessageLocomotionStateUpdate</code>, <code class="language-plaintext highlighter-rouge">NetMessageActivatePower</code>, <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code>, and <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code>), and expanding the custom archive system to include them.</p>

<p>For example, let’s take a look at <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code> as it was in 1.24:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityEnterGameWorld</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">entityId</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">NetStructPoint3</span>    <span class="na">position</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructPoint3</span>    <span class="na">orientation</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">avatarWorldInstanceId</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructLocomotionState</span>    <span class="na">locomotionState</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">entityPrototypeId</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">isClientEntityHidden</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">newOnServer</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetStructLocomotionState</span> <span class="p">{</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">locomotionflags</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">method</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">movespeed</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">height</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">followentityid</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">followentityrange</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">bool</span>    <span class="na">updatepathnodes</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="n">NetStructLocomotionPathNode</span>    <span class="na">pathnodes</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int32</span>    <span class="na">pathgoalnodeindex</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetStructLocomotionPathNode</span> <span class="p">{</span>
    <span class="k">required</span> <span class="n">NetStructPoint3</span>    <span class="na">vertex</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">int32</span>    <span class="na">vertexSideRadius</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here is <code class="language-plaintext highlighter-rouge">NetMessageEntityEnterGameWorld</code> in 1.25+:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityEnterGameWorld</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, a side effect of this optimization is that some messages became a lot less verbose, and therefore less readable. Although it is possible to figure out the overall structure by decompiling and examining the deserialization routine, it takes more time to do blindly, and you have to guess most of the field names. So in some cases looking at older versions of the game can provide invaluable insight for reverse engineering the more recent builds.</p>

<p>Finally, not all builds are made equal. Most publicly available game clients are compiled using the <code class="language-plaintext highlighter-rouge">Shipping</code> configuration that automatically removes all the spicy stuff, such as the developer console and cheats. On the other hand, <code class="language-plaintext highlighter-rouge">Internal</code> builds contain everything but the kitchen sink (and even that after Deadpool’s level 52 review). For instance, MichaelMayhem and Ryolnir demonstrated some of their dev might during the <a href="https://www.youtube.com/watch?v=MekhABg5gCo">Rogue preview livestream</a> in August 2014:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2023-11/internal-cheats.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2023-11/internal-cheats.jpg" alt="MichaelMayhem and Ryolnir using cheats" /></a></p>

<p>Turns out, there was a number of slip-ups, and some of these internal builds actually ended up being uploaded to Steam. So far I’ve found five of them, with the earliest one being <code class="language-plaintext highlighter-rouge">1.10.0.69</code> from late May 2013, and the newest so far is <code class="language-plaintext highlighter-rouge">1.0.4932.0</code> from June 2015. While we have no way of getting them up and running right now, eventually it’s going to be possible, and we may end up being able to access forbidden powers reserved only for the few. Exciting!</p>

<hr />

<p>And this wraps it up for today. Thanks for reading (or scrolling) all the way to the end, and I hope to see you all again next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry></feed>