<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://crypto137.github.io/MHServerEmu/feed.xml" rel="self" type="application/atom+xml" /><link href="https://crypto137.github.io/MHServerEmu/" rel="alternate" type="text/html" /><updated>2024-10-31T17:58:10+03:00</updated><id>https://crypto137.github.io/MHServerEmu/feed.xml</id><title type="html">MHServerEmu Blog</title><subtitle>A volunteer-driven research project aimed at reverse engineering the technology developed by Gazillion Entertainment.</subtitle><entry><title type="html">MHServerEmu Progress Report: October 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/10/31/progress-report-october-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: October 2024" /><published>2024-10-31T17:55:00+03:00</published><updated>2024-10-31T17:55:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/10/31/progress-report-october-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/10/31/progress-report-october-2024.html"><![CDATA[<p><img src="/MHServerEmu/assets/blog/progress-report/2024-10/header.jpg" alt="MHServerEmu Progress Report - October 2024" /></p>

<p>Time for the spookiest MHServerEmu Progress Report of the year.</p>

<h2 id="loot-continued">Loot Continued</h2>

<p>With most of the obvious low-hanging fruit features taken care of, this month it was time for me to work on a more time-consuming aspect of the game. After discussing this with Alex and some of the community members on our Discord server, I decided to continue iterating on our loot system implementation.</p>

<p>At the start of the month we had loot tables rolling, items dropping, and affixes being picked, but the game’s loot system is much broader than just items. In total there are 12 loot types:</p>

<ul>
  <li>
    <p><strong>Item</strong> - should be self-explanatory.</p>
  </li>
  <li>
    <p><strong>Agent</strong> - health, mana, and experience orbs, as well as boons.</p>
  </li>
  <li>
    <p><strong>Credits</strong> - legacy loot type from before currencies were implemented, credit piles are represented by agent entities (more on that later).</p>
  </li>
  <li>
    <p><strong>Experience</strong> - mission experience rewards.</p>
  </li>
  <li>
    <p><strong>Power Points</strong> - extra power points (pre-BUE missions only).</p>
  </li>
  <li>
    <p><strong>Health Bonus</strong> - max health bonuses (pre-BUE missions only).</p>
  </li>
  <li>
    <p><strong>Endurance Bonus</strong> - max primary resource (spirit, etc.) bonuses (pre-BUE missions only).</p>
  </li>
  <li>
    <p><strong>Real Money</strong> - special drop type used only for the <a href="https://web.archive.org/web/20150711031211/https://forums.marvelheroes.com/discussion/216905/marvel-heroes-2015-1-61-patch-notes">Vibranium Ticket promotion</a> in 2015.</p>
  </li>
  <li>
    <p><strong>Callback Nodes</strong> - actions that need to happen when loot is distributed, such as displaying a banner message.</p>
  </li>
  <li>
    <p><strong>Vanity Title</strong> - title unlocks.</p>
  </li>
  <li>
    <p><strong>Vendor XP</strong> - experience for leveling up vendors (this is also how Genosha influence rewards are implemented).</p>
  </li>
  <li>
    <p><strong>Currency</strong> - any non-credits currency that can be represented by either an item or an agent.</p>
  </li>
</ul>

<p>Loot can awarded through two types of <em>loot actions</em>: <em>spawning</em> and <em>giving</em>. Spawning creates loot represented in the game world by items and agents for players to pick up, while giving adds everything straight to players’ inventories. Only items, agents, credits, and currency can exist in the game world, everything else goes directly to players, even if the spawn loot action is requested.</p>

<p>Loot that needs to be clicked on to be picked up is represented by the <code class="language-plaintext highlighter-rouge">Item</code> entity class, while things that get picked automatically when you run over them exist as <code class="language-plaintext highlighter-rouge">Agent</code> entity instances. Here is a chart that shows how loot types relate to entity types that represent them:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-10/loot-entity-types.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/loot-entity-types.png" alt="Loot Entity Types" /></a>
</center>

<p>Note that item and agent <em>loot types</em> are different from <code class="language-plaintext highlighter-rouge">Item</code> and <code class="language-plaintext highlighter-rouge">Agent</code> <em>entity types</em>. When loot tables are rolled, and an item or an agent drop node is encountered, the game checks if the entity prototype specified in the node has an <code class="language-plaintext highlighter-rouge">ItemCurrency</code> property defined. If it does, the drop gets designated as a currency loot type, rather than the loot type corresponding its underlying entity type. To add even more confusion to the mix, credits are their own drop type, and they are always represented by <code class="language-plaintext highlighter-rouge">Agent</code> entities. And because things were not hectic enough, <code class="language-plaintext highlighter-rouge">Agent</code> entities representing currencies are referred to as currency <em>items</em> in the game data.</p>

<p>With all of that figured out, we now had non-item drops spawning. The next thing to do was implementing pickups for orb (agent) drops when you run over them.</p>

<p>The obvious approach would have been to use the physics system to detect when avatars overlap with orbs, and do the pickup interaction in the handler for this event. There was a problem though: most orb entities do not have a collision shape defined, meaning they are not capable of overlapping with other world entities. The correct way to do it was to implement the <code class="language-plaintext highlighter-rouge">ProceduralProfileOrbPrototype</code> and do the pickup interaction within the <code class="language-plaintext highlighter-rouge">Think()</code> method. Orbs actually have the <code class="language-plaintext highlighter-rouge">AICustomThinkRateMS</code> property, allowing them to “think” and check distances to potential receipients on every frame, making this interaction more responsive than it would have been with default AI settings.</p>

<p>Here is what the current implementation of <code class="language-plaintext highlighter-rouge">Think()</code> for orbs looks like:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Think</span><span class="p">(</span><span class="n">AIController</span> <span class="n">ownerController</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ProceduralAI</span> <span class="n">proceduralAI</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Brain</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">proceduralAI</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">Agent</span> <span class="n">agent</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Owner</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">agent</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">Game</span> <span class="n">game</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">Game</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">game</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Destroy this orb if it has finished shrinking</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ShrinkageDurationMS</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TimeSpan</span> <span class="n">shrinkageEndTime</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">Properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">AICustomTimeVal1</span><span class="p">]</span> 
            <span class="p">+</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="n">ShrinkageDelayMS</span><span class="p">)</span> 
            <span class="p">+</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="n">ShrinkageDurationMS</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">CurrentTime</span> <span class="p">&gt;=</span> <span class="n">shrinkageEndTime</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">agent</span><span class="p">.</span><span class="nf">Kill</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">KillFlags</span><span class="p">.</span><span class="n">NoDeadEvent</span> <span class="p">|</span> <span class="n">KillFlags</span><span class="p">.</span><span class="n">NoExp</span> <span class="p">|</span> <span class="n">KillFlags</span><span class="p">.</span><span class="n">NoLoot</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Find an avatar that can potentially pick this orb up</span>
    <span class="n">Avatar</span> <span class="n">avatar</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

    <span class="kt">ulong</span> <span class="n">restrictedToPlayerGuid</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">Properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">RestrictedToPlayerGuid</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">restrictedToPlayerGuid</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Player</span> <span class="n">player</span> <span class="p">=</span> <span class="n">game</span><span class="p">.</span><span class="n">EntityManager</span><span class="p">.</span><span class="n">GetEntityByDbGuid</span><span class="p">&lt;</span><span class="n">Player</span><span class="p">&gt;(</span><span class="n">restrictedToPlayerGuid</span><span class="p">);</span>
        <span class="c1">// Get current avatar for the player we are looking for</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">player</span><span class="p">?.</span><span class="n">CurrentAvatar</span><span class="p">?.</span><span class="n">IsInWorld</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span>
            <span class="n">avatar</span> <span class="p">=</span> <span class="n">player</span><span class="p">.</span><span class="n">CurrentAvatar</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If we found an avatar, check if it can pick this orb up</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">avatar</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Vector3</span> <span class="n">agentPosition</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">;</span>
        <span class="n">Vector3</span> <span class="n">avatarPosition</span> <span class="p">=</span> <span class="n">avatar</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="nf">DistanceSquared2D</span><span class="p">(</span><span class="n">agentPosition</span><span class="p">,</span> <span class="n">avatarPosition</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">_orbRadiusSquared</span> <span class="p">&amp;&amp;</span> <span class="nf">TryGetPickedUp</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="n">avatar</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The actual pickup interaction happens within <code class="language-plaintext highlighter-rouge">TryGetPickedUp()</code>: this includes applying orb effects, such as adding currency, awarding XP, and activating powers (restoring health/spirit, applying boon buffs, etc.). There is still some additional AI behavior left to implement: health and spirit orbs are supposed to be able to follow avatars that get close enough to them, and some orbs need to be non-instanced and available for all players to pick up. This is something we will be iterating on in the future.</p>

<p>With more varied loot being able to drop and be picked up, it was now time to expand the range of available <em>loot drop event types</em>. Everything so far has been using the four events associated with defeating enemies: <code class="language-plaintext highlighter-rouge">OnKilled</code>, <code class="language-plaintext highlighter-rouge">OnKilledChampion</code>, <code class="language-plaintext highlighter-rouge">OnKilledElite</code>, and <code class="language-plaintext highlighter-rouge">OnKilledMiniBoss</code>. However, for treasure chests it was necessary to implement a separate event type called <code class="language-plaintext highlighter-rouge">OnInteractedWith</code>, which was not possible to trigger without a more in-depth interaction system.</p>

<p>I did not have to go through the trouble of overhauling the entire interaction system: as part of his work on missions, Alex had already done most of the work needed. However, missions are a huge all-encompassing system, and merging the development branch would have been too disruptive at this stage. So instead I went through it and manually ported just the parts that could work on their own, including the new interaction system. There were a few small crashes as a result of this porting process, but they were very quickly dealt with, and implementing treasure chest loot was as easy as adding some function calls in the right place. I also had to do a bit of refactoring to isolate some code from <code class="language-plaintext highlighter-rouge">OnKilled</code> event handlers that could be shared with <code class="language-plaintext highlighter-rouge">OnInteractedWith</code>. With that taken care of, we now have a much more satifying treasure room experience.</p>

<p>The next thing to do became obvious as soon as currency items started dropping: without cooldowns, entire screens were covered with Eternity Splinters, which was obviously not how it was supposed to work. Work on this is still ongoing at the time of writing this, but the iconic six-minute Eternity Splinter timer is now working in nightly builds as it should.</p>

<p>This is just one type of loot cooldowns though. As with almost everything in this game, there are many almost conflicting systems that were piled up on top of one another. For instance, some loot cooldowns can be tied to specific entities rather than drops, like terminal bosses you would get Cube Shards from. Other cooldowns are rollover-based, meaning your loot is gated by specific daily or weekly reset times rather than amount of time since your last drop. Untangling all of this is going to take some time, which is what I am going to be continuing to work on next month.</p>

<h2 id="lets-get-dangerous">Let’s Get Dangerous</h2>

<p><em>Alex has some details to share on what he has been working on in October.</em></p>

<hr />

<p>Hello everyone, this is AlexBond. In this report I would like to <del>overwhelm you with code</del> talk about how the <code class="language-plaintext highlighter-rouge">SpawnMap</code> class works, how <em>Legendary Missions</em> are rolled, and how I got into the <em>Danger Room</em>.</p>

<h3 id="spawnmap">SpawnMap</h3>

<p><code class="language-plaintext highlighter-rouge">AreaPrototype</code> contains various population parameters, and some of them have a <code class="language-plaintext highlighter-rouge">SpawnMap</code> prefix. We used to ignore them, but now we took advantage of them to implement an additional spawning system.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-1.png" alt="AlexBond 1" /></a></p>

<p>A <code class="language-plaintext highlighter-rouge">SpawnMap</code> (also referred to as a <code class="language-plaintext highlighter-rouge">HeatMap</code>) is like a bitmap image with a resolution of 256x256, in which each “pixel” represents a byte of information of type <code class="language-plaintext highlighter-rouge">HeatData</code>. The contained “heat” is transferred to clusters of mobs for spawning.</p>

<p>When we initialize this class, we iterate over all coordinates within our area to determine walkable sections using the navi system.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">_boundsY</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">_boundsX</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Vector3</span> <span class="n">position</span> <span class="p">=</span> <span class="n">center</span> <span class="p">+</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">Resolution</span> <span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">Resolution</span> <span class="p">*</span> <span class="n">y</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">navi</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">spawnRadius</span><span class="p">,</span> <span class="k">new</span> <span class="nf">WalkPathFlagsCheck</span><span class="p">()))</span>
        <span class="p">{</span>
            <span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">HeatData</span><span class="p">.</span><span class="n">Min</span><span class="p">;</span>
            <span class="n">_spawnZone</span><span class="p">++;</span>
        <span class="p">}</span>
        <span class="n">index</span><span class="p">++;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using the <code class="language-plaintext highlighter-rouge">spawnZone</code> parameter, we calculate the heat density of the population that is going to be spawned. This density is then applied to our <code class="language-plaintext highlighter-rouge">SpawnMap</code> instance.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Add heat to HeatMap</span>
<span class="n">_pool</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="p">&lt;</span> <span class="n">_heatMap</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">index</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">HeatData</span> <span class="n">heatData</span> <span class="p">=</span> <span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">HasFlags</span><span class="p">(</span><span class="n">heatData</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">heat</span> <span class="p">=</span> <span class="nf">GetHeat</span><span class="p">(</span><span class="n">heatData</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">heat</span> <span class="p">+</span> <span class="n">_heatBase</span> <span class="p">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">HeatData</span><span class="p">.</span><span class="n">Max</span><span class="p">)</span>
        <span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">HeatData</span><span class="p">)(</span><span class="n">heat</span> <span class="p">+</span> <span class="n">_heatBase</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">_pool</span> <span class="p">+=</span> <span class="n">_heatBase</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The surplus heat is transferred to a <em>pool</em>, and at intervals defined by the <code class="language-plaintext highlighter-rouge">SpawnMapPoolTickMS</code> parameter we attempt to bring back the heat from the pool to the map.</p>

<p>Because <code class="language-plaintext highlighter-rouge">SpawnMap</code> instances update every time a player moves, they require some additional optimizations. To reduce server load, only areas around players defined by <code class="language-plaintext highlighter-rouge">SpawnGimbal</code> instances are populated.</p>

<p>A <code class="language-plaintext highlighter-rouge">SpawnGimbal</code> is a sort of shifting area that has already been checked, in which a player is located. This system allows us to significantly reduce server load for processing areas that have already been populated.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">UpdateSpawnMap</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Region</span> <span class="n">region</span> <span class="p">=</span> <span class="nf">GetRegion</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">_spawnGimbal</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_spawnGimbal</span><span class="p">.</span><span class="nf">ProjectGimbalPosition</span><span class="p">(</span><span class="n">region</span><span class="p">.</span><span class="n">Aabb</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="k">out</span> <span class="n">Point2</span> <span class="n">coord</span><span class="p">)</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_spawnGimbal</span><span class="p">.</span><span class="n">Coord</span> <span class="p">==</span> <span class="n">coord</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">inGimbal</span> <span class="p">=</span> <span class="n">_spawnGimbal</span><span class="p">.</span><span class="nf">InGimbal</span><span class="p">(</span><span class="n">coord</span><span class="p">);</span>
    <span class="n">_spawnGimbal</span><span class="p">.</span><span class="nf">UpdateGimbal</span><span class="p">(</span><span class="n">coord</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inGimbal</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">Aabb</span> <span class="n">volume</span> <span class="p">=</span> <span class="n">_spawnGimbal</span><span class="p">.</span><span class="nf">HorizonVolume</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">area</span> <span class="k">in</span> <span class="n">region</span><span class="p">.</span><span class="nf">IterateAreas</span><span class="p">(</span><span class="n">volume</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="p">.</span><span class="n">SpawnMap</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="n">area</span><span class="p">.</span><span class="n">PopulationArea</span><span class="p">?.</span><span class="nf">UpdateSpawnMap</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is a trade-off though: when a player moves at high speed, groups of enemies can spawn right at their position, but this behavior is accurate to the original game. The reason for these delays is that spawning takes at least 500 ms, which is not enough for enemies to spawn ahead of time. We can reduce this number, but then it would take longer to wait a spawn to happen.</p>

<p>When <code class="language-plaintext highlighter-rouge">UpdateHeatMap()</code> is called, the related population is spawned in “hot spots”. These spots are projected to the <code class="language-plaintext highlighter-rouge">HeatMap</code>, and the heat is subtracted from those points, along with neighboring points within a certain radius. This frees up space for a group of mobs represented by a <code class="language-plaintext highlighter-rouge">ClusterObject</code>, and allows us to spread the population evenly.</p>

<p>Clusters may contain special <code class="language-plaintext highlighter-rouge">BlackOutZone</code> objects that prevent spawning from happening. We take these objects into account by transferring heat from their locations into the common pool.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">spawnZone</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">_boundsY</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">_boundsX</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">&amp;=</span> <span class="p">~</span><span class="n">HeatData</span><span class="p">.</span><span class="n">BlackOut</span><span class="p">;</span>

        <span class="n">Vector3</span> <span class="n">position</span> <span class="p">=</span> <span class="n">center</span> <span class="p">+</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">Resolution</span> <span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">Resolution</span> <span class="p">*</span> <span class="n">y</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">BlackOutZone</span> <span class="n">zone</span> <span class="k">in</span> <span class="n">zones</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">radiusSq</span> <span class="p">=</span> <span class="n">MathHelper</span><span class="p">.</span><span class="nf">Square</span><span class="p">(</span><span class="n">zone</span><span class="p">.</span><span class="n">Sphere</span><span class="p">.</span><span class="n">Radius</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">distanceSq</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">DistanceSquared2D</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">zone</span><span class="p">.</span><span class="n">Sphere</span><span class="p">.</span><span class="n">Center</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">distanceSq</span> <span class="p">&lt;</span> <span class="n">radiusSq</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">heat</span> <span class="p">=</span> <span class="nf">GetHeat</span><span class="p">(</span><span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                <span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">&amp;</span> <span class="n">HeatData</span><span class="p">.</span><span class="n">FlagMask</span><span class="p">)</span> <span class="p">|</span> <span class="n">HeatData</span><span class="p">.</span><span class="n">BlackOut</span><span class="p">;</span>
                <span class="nf">PoolHeat</span><span class="p">(</span><span class="n">heat</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nf">HasFlags</span><span class="p">(</span><span class="n">_heatMap</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span> <span class="n">spawnZone</span><span class="p">++;</span>
        <span class="n">index</span><span class="p">++;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When a group of enemies is fully destroyed, the heat they took is returned to the common pool. This gives regions an endless lifespan, which is crucial for public regions.  This way newly arriving players will encounter a living world, rather than a wasteland from past battles. Ensuring this is the primary function of the <code class="language-plaintext highlighter-rouge">SpawnMap</code> class.</p>

<p>As you can see, there are numerous different systems for spawning: <code class="language-plaintext highlighter-rouge">PopulationArea</code>, <code class="language-plaintext highlighter-rouge">RespawnDestructibles</code>, <code class="language-plaintext highlighter-rouge">MetaGame</code>, <code class="language-plaintext highlighter-rouge">Mission</code>, <code class="language-plaintext highlighter-rouge">SpawnMap</code>, <code class="language-plaintext highlighter-rouge">Spawner</code>, and more. Here is a recap of what they are all for:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PopulationArea</code> populates regions without using markers.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RespawnDestructibles</code> allows props, such as cars and garbage cans, to be restored.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MetaGame</code> populates regions with timer-based events or waves.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Mission</code> spawns in response to event triggers.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SpawnMap</code> prevents regions from becoming barren wastelands.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Spawner</code> can activate when a player enters its radius, or via some other kind of trigger.</p>
  </li>
</ul>

<p>In other words, dynamic spawning makes the game more alive. Now let’s take a look at legendary missions.</p>

<h3 id="legendary-missions">Legendary Missions</h3>

<p>This game has a lot of activities: in addition to the story, region events, and terminal bounties, there are also Legendary Missions, Daily Missions, Shared Quests, Omega Missions, and Weekly Missions. So how does it all work?</p>

<p>When a player enters a region, their <code class="language-plaintext highlighter-rouge">MissionManager</code> runs <code class="language-plaintext highlighter-rouge">InitializeForPlayer()</code> and does a number of random picks.</p>

<p>First it picks <em>categories</em> through <code class="language-plaintext highlighter-rouge">LegendaryMissionCategoryPicker</code>, and then for each category it picks a random mission using <code class="language-plaintext highlighter-rouge">PickLegendaryMissionForCategory()</code>. At first it seems simple enough, but there is a catch.</p>

<p>For example, a mission was picked, and we don’t like it. What do we do in this case? That’s right, we reroll it with credits!</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-2.png" alt="AlexBond 6" /></a>
</center>

<p>In this case the current mission must be added to a <code class="language-plaintext highlighter-rouge">LegendaryMissionBlacklist</code>, and we should receive a new one. This is also used when we complete a mission, so that we don’t get the same one multiple times in a row. But what happens when all missions get blacklisted? In this case we need a second round of picking.</p>

<p>This is what the code looks like. Confusing, isn’t it?</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">PrototypeId</span> <span class="nf">PickLegendaryMission</span><span class="p">()</span>
<span class="p">{</span> 
    <span class="n">PrototypeId</span> <span class="n">pickedMissionRef</span> <span class="p">=</span> <span class="n">PrototypeId</span><span class="p">.</span><span class="n">Invalid</span><span class="p">;</span>

    <span class="n">Picker</span><span class="p">&lt;</span><span class="n">LegendaryMissionCategoryPrototype</span><span class="p">&gt;</span> <span class="n">picker</span> <span class="p">=</span> <span class="nf">LegendaryMissionCategoryPicker</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">picker</span><span class="p">.</span><span class="nf">PickRemove</span><span class="p">(</span><span class="k">out</span> <span class="n">LegendaryMissionCategoryPrototype</span> <span class="n">categoryProto</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="n">PrototypeGuid</span><span class="p">&gt;</span> <span class="n">blacklist</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">categoryProto</span><span class="p">.</span><span class="n">BlacklistLength</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PrototypeGuid</span> <span class="n">guid</span> <span class="p">=</span> <span class="n">GameDatabase</span><span class="p">.</span><span class="nf">GetPrototypeGuid</span><span class="p">(</span><span class="n">categoryProto</span><span class="p">.</span><span class="n">DataRef</span><span class="p">);</span>
            <span class="n">_legendaryMissionBlacklist</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">guid</span><span class="p">,</span> <span class="k">out</span> <span class="n">blacklist</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">pickedMissionRef</span> <span class="p">=</span> <span class="nf">PickLegendaryMissionForCategory</span><span class="p">(</span><span class="n">categoryProto</span><span class="p">,</span> <span class="n">blacklist</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pickedMissionRef</span> <span class="p">!=</span> <span class="n">PrototypeId</span><span class="p">.</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pickedMissionRef</span> <span class="p">==</span> <span class="n">PrototypeId</span><span class="p">.</span><span class="n">Invalid</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">picker</span> <span class="p">=</span> <span class="nf">LegendaryMissionCategoryPicker</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">picker</span><span class="p">.</span><span class="nf">PickRemove</span><span class="p">(</span><span class="n">LegendaryMissionCategoryPrototype</span> <span class="kt">var</span> <span class="n">categoryProto</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">pickedMissionRef</span> <span class="p">=</span> <span class="nf">PickLegendaryMissionForCategory</span><span class="p">(</span><span class="n">categoryProto</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pickedMissionRef</span> <span class="p">!=</span> <span class="n">PrototypeId</span><span class="p">.</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pickedMissionRef</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When picking Legendary Missions, one thing that needs to be taken into account is its restriction defined using the <code class="language-plaintext highlighter-rouge">EvalCanStart</code> eval. It uses the same formula for all Legendary Missions that looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EvalCanStart = ( ( CharacterLevelProp &gt; 19 ) &amp;&amp; ( CharacterLevelProp &lt; 61 ) )
</code></pre></div></div>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-3.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-3.png" alt="AlexBond 3" /></a></p>

<p>This ensures that Legendary Missions are unavailable until level 20. However, the game designers did not define separate formulas for each mission, which is why I would get Legendary Missions for chapter 9 at level 20. I wanted to do them as I went through the story, so I had to spend all my credits on rerolling!</p>

<p>In addition to Legendary Missions there are also <em>Daily Missions</em>, and they use a different picking method.</p>

<p>First, the current <code class="language-plaintext highlighter-rouge">CalendarDay</code> is determined, and if it’s larger than the last recorded day, daily missions get rerolled.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">calendarDay</span> <span class="p">=</span> <span class="nf">CalendarDay</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">lastDailyDay</span> <span class="p">=</span> <span class="n">Player</span><span class="p">.</span><span class="n">Properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">LastDailyMissionCalendarDay</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">lastDailyDay</span> <span class="p">&lt;</span> <span class="n">calendarDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">ResetDailyMissions</span><span class="p">(</span><span class="n">calendarDay</span><span class="p">,</span> <span class="n">lastDailyDay</span><span class="p">);</span>
    <span class="nf">RollDailyMissions</span><span class="p">();</span>
    <span class="n">Player</span><span class="p">.</span><span class="n">Properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">LastDailyMissionCalendarDay</span><span class="p">]</span> <span class="p">=</span> <span class="n">calendarDay</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As part of the reroll process, the current day of the week is determined, and missions for this day are activated.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-4.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-4.jpg" alt="AlexBond 4" /></a></p>

<p>The same happens for <em>Advanced Missions</em>, but with blacklists and two picking passes, similar to Legendary Missions.</p>

<p>But what happens if someone plays at night and waits for the daily reset at midnight? In this case we need a clock: events scheduled using <code class="language-plaintext highlighter-rouge">ScheduleDailyMissionUpdate()</code> check every second whether the current day ended, like a second hand on a clock.</p>

<p>With this taken care of, let’s move onto another fun activity.</p>

<h3 id="danger-room">Danger Room</h3>

<p>The main difficulty with implementing the <em>Danger Room</em> mode is regenerating the same region with different input data.</p>

<p>Here is what the insides of a generator prototype for such region look like:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-5.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-5.png" alt="AlexBond 5" /></a></p>

<p>The current mode is chosen based on the <code class="language-plaintext highlighter-rouge">EndlessLevel</code> parameter like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">EndlessThemeEntryPrototype</span> <span class="nf">GetEndlessGeneration</span><span class="p">(</span><span class="kt">int</span> <span class="n">randomSeed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endlessLevel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endlessLevelsTotal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EndlessThemes</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">endlessLevel</span> <span class="p">&lt;=</span> <span class="m">0</span> <span class="p">||</span> <span class="n">endlessLevelsTotal</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">totalThemes</span> <span class="p">=</span> <span class="n">EndlessThemes</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">randomIndex</span> <span class="p">=</span> <span class="n">randomSeed</span> <span class="p">%</span> <span class="n">totalThemes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">endlessOffset</span> <span class="p">=</span> <span class="p">(</span><span class="n">endlessLevel</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">/</span> <span class="n">endlessLevelsTotal</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">selectedIndex</span> <span class="p">=</span> <span class="p">(</span><span class="n">randomIndex</span> <span class="p">+</span> <span class="n">endlessOffset</span><span class="p">)</span> <span class="p">%</span> <span class="n">totalThemes</span><span class="p">;</span>

    <span class="n">EndlessThemePrototype</span> <span class="n">EndlessTheme</span> <span class="p">=</span> <span class="n">EndlessThemes</span><span class="p">[</span><span class="n">selectedIndex</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">levelInTheme</span> <span class="p">=</span> <span class="n">endlessLevel</span> <span class="p">%</span> <span class="n">endlessLevelsTotal</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">levelInTheme</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EndlessTheme</span><span class="p">.</span><span class="n">TreasureRoom</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">levelInTheme</span> <span class="p">==</span> <span class="n">endlessLevelsTotal</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EndlessTheme</span><span class="p">.</span><span class="n">Boss</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">EndlessTheme</span><span class="p">.</span><span class="n">Normal</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For the initial region <code class="language-plaintext highlighter-rouge">EndlessLevel = 1</code>, so this function will return the <code class="language-plaintext highlighter-rouge">Normal</code> mode.</p>

<p>Next, in the <code class="language-plaintext highlighter-rouge">Normal</code> mode a random <code class="language-plaintext highlighter-rouge">Entry</code> is picked from <code class="language-plaintext highlighter-rouge">Challenges</code>, and a mission approprite for our difficulty <code class="language-plaintext highlighter-rouge">Tier</code> is started.</p>

<p>The transfer of all of these settings and affixes from a <code class="language-plaintext highlighter-rouge">DangerRoomScenario</code> item to a region goes through the following sequence:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DangerRoomScenario</code> – <code class="language-plaintext highlighter-rouge">Transition</code> – <code class="language-plaintext highlighter-rouge">RegionContext</code> – <code class="language-plaintext highlighter-rouge">RegionSettings</code> – <code class="language-plaintext highlighter-rouge">Region</code></p>
</blockquote>

<p>When the first <code class="language-plaintext highlighter-rouge">EndlessLevel</code> is cleared, it is incremented by one, and the settings sequence looks like this:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">OldRegion</code> - <code class="language-plaintext highlighter-rouge">RegionContext</code> - <code class="language-plaintext highlighter-rouge">RegionSettings</code> - <code class="language-plaintext highlighter-rouge">Region</code></p>
</blockquote>

<p>All of these settings make the region transfer more complex. But there is more.</p>

<p>When a Danger Room mission is cleared, the client needs to receive an invitation to move to the next level. It looks like this:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-6.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-6.jpg" alt="AlexBond 6" /></a>
</center>

<p>Implementing it was not easy at all. To create this dialog, we needed to implement a lot of classes, and the result is almost as complex as <code class="language-plaintext highlighter-rouge">CreateDialogA</code> in the Windows API:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">CreateDialog</span><span class="p">(</span><span class="kt">ulong</span> <span class="n">playerGuid</span><span class="p">,</span> <span class="n">DialogPrototype</span> <span class="n">dialogProto</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_dialogs</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">playerGuid</span><span class="p">,</span> <span class="k">out</span> <span class="n">GameDialogInstance</span> <span class="n">dialog</span><span class="p">)</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dialog</span> <span class="p">=</span> <span class="n">Game</span><span class="p">.</span><span class="n">GameDialogManager</span><span class="p">.</span><span class="nf">CreateInstance</span><span class="p">(</span><span class="n">playerGuid</span><span class="p">);</span>
        <span class="n">dialog</span><span class="p">.</span><span class="n">OnResponse</span> <span class="p">=</span> <span class="n">_onResponseAction</span><span class="p">;</span>
        <span class="n">dialog</span><span class="p">.</span><span class="n">Message</span><span class="p">.</span><span class="n">LocaleString</span> <span class="p">=</span> <span class="n">dialogProto</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>
        <span class="n">dialog</span><span class="p">.</span><span class="n">Options</span> <span class="p">=</span> <span class="n">DialogOptionEnum</span><span class="p">.</span><span class="n">ScreenBottom</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dialogProto</span><span class="p">.</span><span class="n">Button1</span> <span class="p">!=</span> <span class="n">LocaleStringId</span><span class="p">.</span><span class="n">Blank</span><span class="p">)</span>
            <span class="n">dialog</span><span class="p">.</span><span class="nf">AddButton</span><span class="p">(</span><span class="n">GameDialogResultEnum</span><span class="p">.</span><span class="n">eGDR_Option1</span><span class="p">,</span> <span class="n">dialogProto</span><span class="p">.</span><span class="n">Button1</span><span class="p">,</span> <span class="n">dialogProto</span><span class="p">.</span><span class="n">Button1Style</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dialogProto</span><span class="p">.</span><span class="n">Button2</span> <span class="p">!=</span> <span class="n">LocaleStringId</span><span class="p">.</span><span class="n">Blank</span><span class="p">)</span>
            <span class="n">dialog</span><span class="p">.</span><span class="nf">AddButton</span><span class="p">(</span><span class="n">GameDialogResultEnum</span><span class="p">.</span><span class="n">eGDR_Option2</span><span class="p">,</span> <span class="n">dialogProto</span><span class="p">.</span><span class="n">Button2</span><span class="p">,</span> <span class="n">dialogProto</span><span class="p">.</span><span class="n">Button2Style</span><span class="p">);</span>

        <span class="n">_dialogs</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">playerGuid</span><span class="p">,</span> <span class="n">dialog</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dialog</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">Game</span><span class="p">.</span><span class="n">GameDialogManager</span><span class="p">.</span><span class="nf">ShowDialog</span><span class="p">(</span><span class="n">dialog</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is how it works: finishing a mission initiates <code class="language-plaintext highlighter-rouge">MetaStateShutdown</code> and creates a dialog that is relayed to the client through <code class="language-plaintext highlighter-rouge">NetMessagePostDialogToClient</code>. The player presses the dialog button, and the client responds with <code class="language-plaintext highlighter-rouge">NetMessageDialogResult</code> that triggers the <code class="language-plaintext highlighter-rouge">OnDialogResult()</code> event on the server. <code class="language-plaintext highlighter-rouge">OnDialogResult()</code> calls <code class="language-plaintext highlighter-rouge">MetaStateShutdown.OnResponse()</code> that teleports the player to the next <code class="language-plaintext highlighter-rouge">EndlessLevel</code> region.</p>

<p>As you can see, a simple button has a not-so-simple implementation. And there is also a case for when there are multiple players in a party, and each one has to confirm for a teleport to happen.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-10/alex-7.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-10/alex-7.jpg" alt="AlexBond 7" /></a>
</center>

<p>To get the mode to a feature-complete state we still have timer widgets to implement with three <code class="language-plaintext highlighter-rouge">MetaStateScoringEventTimer</code> states: <code class="language-plaintext highlighter-rouge">Start</code>, <code class="language-plaintext highlighter-rouge">Stop</code>, and <code class="language-plaintext highlighter-rouge">End</code>. However, even at this stage Danger Room regions can be completed without any significant issues.</p>

<p>Now you should have a better idea about what I have been working on this month. There is still a lot more work to do, see you in future reports!</p>

<hr />

<p>That’s all we have for you today. See you next month!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: September 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/09/30/progress-report-september-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: September 2024" /><published>2024-09-30T14:35:00+03:00</published><updated>2024-09-30T14:35:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/09/30/progress-report-september-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/09/30/progress-report-september-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-09/header.jpg" alt="MHServerEmu Progress Report - September 2024" /></p>

<p>You know the drill, it’s progress report time.</p>

<h2 id="wtb-godly-plate-of-the-whale">WTB Godly Plate of the Whale</h2>

<p>This month we released our third stable version, <a href="https://github.com/Crypto137/MHServerEmu/releases/tag/0.3.0">0.3.0</a>, and immediately I started working on features for 0.4.0, which is currently planned for early December.</p>

<p>The first thing on my “to do” list was implementing item affix generation. When I did the loot table implementation <a href="/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html">back in July</a>, I already knew that it would not be difficult to get affix generation up and running with what we already had. However, I wanted to wait until we had persistence working: there is no worse feeling in a loot game than getting a good drop and knowing you are going to lose it as soon as you log out.</p>

<p>Here is an overview of how affix generation works. After the <code class="language-plaintext highlighter-rouge">ItemResolver</code> goes through a loot table, you end up with an <code class="language-plaintext highlighter-rouge">ItemSpec</code> that has the item’s base type, quality, and level, but no affixes. This <code class="language-plaintext highlighter-rouge">ItemSpec</code> is passed to a function called <code class="language-plaintext highlighter-rouge">LootUtilities.UpdateAffixes()</code> that does the real magic.</p>

<p>Based mainly on the item’s base type and level, the game rolls a number of <em>category</em> affixes and <em>position</em> affixes.</p>

<p>Categories are data-defined pools, which in practice are primarily used for “white” affixes you see on gear, like damage rating and health.  Theoretically it should be possible to add more affix categories by changing game data, although you will have to modify both the server and the client <code class="language-plaintext highlighter-rouge">.sip</code> files.</p>

<p>There are 19 affix positions, and they are hardcoded into the game: unlike categories, you cannot add or remove new affix positions without recompiling the client. Available positions include things that are typical for games in this genre, like prefixes and suffixes, but also more specialized options, such as PetTech-specific affixes. Here is a full list of affix positions that exist in version 1.52:</p>

<table>
  <thead>
    <tr>
      <th>Prefix</th>
      <th>Unique</th>
      <th>PetTech1</th>
      <th>RegionAffix</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Suffix</strong></td>
      <td><strong>Blessing</strong></td>
      <td><strong>PetTech2</strong></td>
      <td><strong>Socket1</strong></td>
    </tr>
    <tr>
      <td><strong>Visual</strong></td>
      <td><strong>Runeword</strong></td>
      <td><strong>PetTech3</strong></td>
      <td><strong>Socket2</strong></td>
    </tr>
    <tr>
      <td><strong>Ultimate</strong></td>
      <td><strong>TeamUp</strong></td>
      <td><strong>PetTech4</strong></td>
      <td><strong>Socket3</strong></td>
    </tr>
    <tr>
      <td><strong>Cosmic</strong></td>
      <td><strong>Metadata</strong></td>
      <td><strong>PetTech5</strong></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>For each affix roll a pool is formed based on various filters, including compatibility with the base type, keywords, categories, and the region the affix is being rolled in. An affix is then picked from this pool, checking for duplicates that are already attached to this <code class="language-plaintext highlighter-rouge">ItemSpec</code> if needed. Some affixes also require an additional parameter, referred to as its <em>scope</em>: the most typical example of this are affixes that affect specific powers or groups of powers. For an affix like <code class="language-plaintext highlighter-rouge">+3 to Repulsor Barrage</code> the scope would be a reference to the prototype for the <code class="language-plaintext highlighter-rouge">Repulsor Barrage</code> power, while for <code class="language-plaintext highlighter-rouge">+10% Area Power Damage</code> it would be a reference to the prototype for the <code class="language-plaintext highlighter-rouge">Area</code> keyword. The scope system is a good example of how surface-level many BUE changes actually were: although power ranks were “removed”, the entire backend for them still exists and is in use, with all powers simply being set to rank 1 and rebalanced accordingly.</p>

<p>With affixes picked and added to the <code class="language-plaintext highlighter-rouge">ItemSpec</code>, it is now time to apply it to an <code class="language-plaintext highlighter-rouge">Item</code> entity instance. This is when the actual rolling of values happens. The funny thing about this process is that it is done in parallel by the server and the client: rather than sending a fully rolled item, the server sends the client a serialized <code class="language-plaintext highlighter-rouge">ItemSpec</code> that also contains a seed for the random number generator. Because the input data and the algorithm are the same between the two of them, they both generate the same item independently from one another. While this means we have all the logic for the rolling process client-side, any deviation from it also causes desynchronization issues. In addition to that, you can’t modify most of the static item data, such as affix ranges, server-side without also having to change the client.</p>

<p>In addition to randomly picked affixes, the prototypes for base types can also have <em>built-in affixes</em>, and <em>built-in properties</em>. The vast majority of fixed stat items you see in the game, like uniques and artifacts, are implemented using built-in properties. The core difference between them is that affix properties are attached to the item as child property collections and can be removed, while built-in properties are written right into the item’s own property collection.</p>

<p>Implementing built-in properties initially caused unexpected game instances crashes. Turns out, the data contains mistakes made by designers, and in some cases minimum and maximum ranges are mixed up. Generally it’s negative decimal numbers, like <code class="language-plaintext highlighter-rouge">-0.1</code> and <code class="language-plaintext highlighter-rouge">-0.2</code>, but there are also cases that look like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/unique-range.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/unique-range.png" alt="Unique Range" /></a></p>

<p>Here is the default implementation of <code class="language-plaintext highlighter-rouge">Math.Clamp()</code> in C#:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Clamp</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="p">&gt;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">ThrowMinMaxException</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&lt;</span> <span class="n">min</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&gt;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So when you try to clamp a value to a mixed up range like this, an exception is thrown, which leads to a crash. We cannot fix the issue with the data without also modifying the client, so what we have to do here is remove the <code class="language-plaintext highlighter-rouge">min &gt; max</code> check to process malformed data in the same way as the client, or we are going to get different rolls server-side and end up with desync issues.</p>

<p>With affixes actually rolling and applying, it was now time to take another look at combat calculations. The version of the game we are currently working on uses a form of level scaling called dynamic combat level (DCL). Surprisingly enough, it is actually not that complicated compared to most other systems in this game: all damage players deal to mobs and receive from mobs is scaled as if the mob was the same level as the player (with upper and lower bounds for this scaling defined by the region). Enemy health never actually changes, and the illusion of enemies scaling up or down to player level is created by sending fake damage numbers to the client. So if you would deal <code class="language-plaintext highlighter-rouge">100</code>  damage to a target of your level, it gets scaled to <code class="language-plaintext highlighter-rouge">1000</code> to match the target’s higher level, but the client receives and displays the number <code class="language-plaintext highlighter-rouge">100</code>.</p>

<p>It would not be Marvel Heroes if there was no jank at all though. When the DCL system was initially being implemented, it was made in a way where it could be turned off. For this reason all mobs in the game have two health curves: the default one and the “new” DCL one. The main difference between them is that while default curves have separate baseline scaling for regular mobs and bosses, the new DCL curves are unified, and the difference is achieved by applying external health multipliers. In the vast majority of cases this multiplier comes from the mob’s rank (<code class="language-plaintext highlighter-rouge">Popcorn</code>, <code class="language-plaintext highlighter-rouge">Champion</code>, <code class="language-plaintext highlighter-rouge">Elite</code>, <code class="language-plaintext highlighter-rouge">MiniBoss</code>, <code class="language-plaintext highlighter-rouge">Boss</code>), but sometimes it is baked into the mob’s prototype itself. This was the reason why some mobs, like Doop, were nearly unkillable before: they were using their default health curves that had baseline scaling <em>and</em> they also had a crazy high multiplier bonus that was applied on top of that.</p>

<p>With players having items with stats, the DCL system being mostly implemented, and characters using proper health curves with multipliers applied to them, everything in the game now has a much more authentic feel to it, with proper contrast between weaker popcorn mobs and tougher elites. There is still lots and lots of work to do on this front, but I feel we are in a much better place balance-wise now.</p>

<h2 id="and-this-is-to-go-even-further-beyond">And This… Is to Go Even Further Beyond!</h2>

<p>As MHServerEmu matures and more features are implemented, the workload the server has to do increases. Even 0.3.0, with its basic combat and loot generation, already starts coming apart at the seams with high enough load, and with missions and metagames coming in 0.4.0, this month I decided it was time to take a good look at what we can do to optimize the server.</p>

<h3 id="round-1-memory-management">Round 1: Memory Management</h3>

<p>The core difference between our server implementation and the original game is that MHServerEmu is written in C#, which compiles to bytecode and has automatic memory management, while the client is C++ compiled to native code with manual memory management. The biggest advantage of using C# for this project is that it’s great for rapid iteration with fast build times and features like hot reload, and more often than not <em>it just works</em>. However, there is an inherent loss of control compared to C++, the most critical point being how memory is managed.</p>

<p>Both languages use the concepts of the stack and the heap for managing memory. I will not go into too much detail on this, as there are countless other resources that go as deep into this as you will ever want, and do a much better job at it than I can, but here is the gist of it:</p>

<ul>
  <li>
    <p>Stack-allocated data is cleared automatically after you leave the block of code that contains the allocation. Working with the stack is very fast, but it has relatively small size (1 MB by default in C#), and if you exceed this limit, you will get the infamous stack overflow error. So generally you want to use this for smaller temporary data with short lifespans.</p>
  </li>
  <li>
    <p>Anything allocated on the heap needs to be cleaned up at some point. In C++ this can be done in various ways, while C# does it automatically using its <em>garbage collector</em> (GC). Working with the heap is much slower than the stack, but it can handle significantly larger volumes of data with longer lifespans.</p>
  </li>
  <li>
    <p>In C++ pretty much anything can be allocated either on the stack or on the heap. C# restricts this by dividing types into <em>value types</em> and <em>reference types</em>: there are exceptions and edge cases, but the general idea is that reference types cannot be allocated on the stack, and there are cases when value types have to be wrapped in reference types, which forces them to be allocated on the heap. This wrapping process is called <em>boxing</em>.</p>
  </li>
</ul>

<p>As a result of this, in C++ if you are not careful with your memory management, you will end up continuously allocating more memory than you free, eventually completely running out of it. This is what is commonly referred to as a <em>memory leak</em>. In languages like C# it’s a lot harder to get a memory leak like this, but it’s still very easy to unintentionally end up doing too many heap allocations, increasing <em>garbage collection pressure</em>, which manifests as unpredictable stuttering, as the garbage collector periodically suspends all threads to do its work. This is made worse by the fact that C# has limited tools for stack allocations, and some features end up allocating garbage behind the scenes.</p>

<p>While Marvel Heroes has a relatively loose simulation time step of 50 ms, there is also a lot of stuff going on, so the amount of garbage you generate can get very out of hand very fast. Here are some examples of the issues I have recently identified and fixed.</p>

<h4 id="arrays">Arrays</h4>

<p>By default, arrays in C# are reference types. This means when you create a new array like this…</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">1024</span><span class="p">];</span>
</code></pre></div></div>

<p>…you are allocating 1024 bytes on the heap that the garbage collector will have to reclaim at some point. This is not too bad when it’s done every once in a while, but what if you are doing this tens of thousands of times per second?</p>

<p>As I was profiling our memory allocations, I discovered that we had literally millions of <code class="language-plaintext highlighter-rouge">double[]</code> allocations happening every minute. The culprit wasn’t even our own code: we are using a third party library that implements <a href="https://www.cs.cmu.edu/~quake/robust.html">fast robust predicates for computational geometry</a>, which is a way of quickly testing points in space with a high degree of accuracy. The original implementation is <a href="https://www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c">written in C</a>, and instead of adapting it to C# ourselves, we used <a href="https://github.com/modios/robust-predicates">an existing port</a>.</p>

<p>However, as I looked at the code, I started seeing parts like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span><span class="p">[]</span> <span class="n">finswap</span><span class="p">;</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp16a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp32a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp16b</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp32b</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp16c</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">temp48</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">48</span><span class="p">];</span>
<span class="kt">double</span><span class="p">[]</span> <span class="n">axtbc</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">8</span><span class="p">];</span>
</code></pre></div></div>

<p>These tests are used extensively in the game for updating the navi system, and they can cause millions of heap allocations in just a few minutes of playing. Thankfully, this is temporary data that gets thrown away as soon the function finishes, so we can make use of one of the optimization tools available in C# - <code class="language-plaintext highlighter-rouge">Span&lt;T&gt;</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">finswap</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp16a</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp32a</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp16b</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp32b</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp16c</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp48</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">48</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">axtbc</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">8</span><span class="p">];</span>
</code></pre></div></div>

<p>Doing it this way we break the “rules” of C# arrays a bit and allocate them on the stack. Behind the scenes this is actually a way of writing unsafe code that looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span><span class="p">*</span> <span class="n">temp16aPtr</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">double</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
<span class="n">Span</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">temp16a</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">temp16aPtr</span><span class="p">);</span>
</code></pre></div></div>

<p>Spans are essentially highly limited pointers that allow us to use some C# features that had been traditionally restricted to unsafe code, such as the <code class="language-plaintext highlighter-rouge">stackalloc</code> keyword. They are very useful for situations like this, although with an external library it may be worth rewriting it in fully unsafe code to get more performance out of it in the future. Our span-based fork of this robust predicates implementation is available on <a href="https://github.com/Crypto137/robust-predicates">GitHub</a> for everyone to use.</p>

<p>Replacing arrays with spans works for smaller arrays, but what about those that can potentially exceed the 1 MB stack limit or need to persist for longer periods of time? The best example of this are <code class="language-plaintext highlighter-rouge">byte[]</code> buffers used for serializing network messages and player data. This is where another useful optimization tool comes in: <code class="language-plaintext highlighter-rouge">ArrayPool&lt;T&gt;</code>. Instead of allocating a new buffer each time like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">size</span> <span class="p">=</span> <span class="n">packet</span><span class="p">.</span><span class="n">SerializedSize</span><span class="p">;</span>
<span class="kt">byte</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="n">packet</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="nf">Send</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>We can “rent” and later reuse the same buffers:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">size</span> <span class="p">=</span> <span class="n">packet</span><span class="p">.</span><span class="n">SerializedSize</span><span class="p">;</span>
<span class="kt">byte</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">ArrayPool</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;.</span><span class="n">Shared</span><span class="p">.</span><span class="nf">Rent</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="n">packet</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="nf">Send</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="n">ArrayPool</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;.</span><span class="n">Shared</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>There are certain limitations to using <code class="language-plaintext highlighter-rouge">ArrayPool&lt;T&gt;</code>: for example, you will most likely get a buffer larger than what you requested, and you will have to handle this yourself. However, it works very well for cases like high-volume packet serialization.</p>

<p>This was a very simple example where integrating pooling was just two lines of code. Unfortunately, things are not always this easy. For client compatibility reasons we are using <code class="language-plaintext highlighter-rouge">protobuf-csharp-port</code>, a legacy C# implementation of Google’s Protocol Buffers (protobufs) that was last updated in 2015. Gazillion utilized certain protobuf encoding functions directly for their custom archive format, which is used for high-frequency messages, like entity creation, locomotion updates, and power activations.</p>

<p>These encoding functions can be accessed in <code class="language-plaintext highlighter-rouge">protobuf-csharp-port</code> using the <code class="language-plaintext highlighter-rouge">CodedOutputStream</code> class. <code class="language-plaintext highlighter-rouge">CodedOutputStream</code> is a wrapper for various <code class="language-plaintext highlighter-rouge">Stream</code> implementations, like a protobuf-specific version of <code class="language-plaintext highlighter-rouge">BinaryWriter</code>. You can create <code class="language-plaintext highlighter-rouge">CodedOutputStream</code> instances using various overloads of the <code class="language-plaintext highlighter-rouge">CreateInstance()</code> factory method, but there is a problem: you can provide your own fixed-size buffer to write to directly, or you can provide a stream and specify the size of the write buffer. However, the constructor for <code class="language-plaintext highlighter-rouge">CodedOutputStream</code> is <code class="language-plaintext highlighter-rouge">private</code>, and there is no <code class="language-plaintext highlighter-rouge">CreateInstance()</code> overload that accepts both a stream and a buffer:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="nf">CodedOutputStream</span><span class="p">(</span><span class="n">Stream</span> <span class="n">output</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">buffer</span> <span class="p">=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">limit</span> <span class="p">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">CodedOutputStream</span> <span class="nf">CreateInstance</span><span class="p">(</span><span class="n">Stream</span> <span class="n">output</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">CodedOutputStream</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">bufferSize</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The “normal” thing to do here would be either to accept that we will waste allocations on this, or to just bite the bullet and start modifying <code class="language-plaintext highlighter-rouge">protobuf-csharp-port</code> for our needs.  However, I am stubborn, and I felt like doing the latter would be like opening the Pandora’s box: we may end up doing it at some point, but now was not the right time. Modern problems require modern solutions, and here is the one I came up with:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">CodedOutputStreamEx</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">Stream</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[],</span> <span class="n">CodedOutputStream</span><span class="p">&gt;</span> <span class="n">CreateInstanceDelegate</span><span class="p">;</span>

    <span class="k">static</span> <span class="nf">CodedOutputStreamEx</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Type</span><span class="p">[]</span> <span class="n">argTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Type</span><span class="p">[]</span> <span class="p">{</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Stream</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">byte</span><span class="p">[])</span> <span class="p">};</span>

        <span class="n">DynamicMethod</span> <span class="n">dm</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"CreateInstance"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CodedOutputStream</span><span class="p">),</span> <span class="n">argTypes</span><span class="p">);</span>
        <span class="n">ILGenerator</span> <span class="n">il</span> <span class="p">=</span> <span class="n">dm</span><span class="p">.</span><span class="nf">GetILGenerator</span><span class="p">();</span>

        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_0</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_1</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Newobj</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CodedOutputStream</span><span class="p">).</span><span class="nf">GetConstructor</span><span class="p">(</span><span class="n">BindingFlags</span><span class="p">.</span><span class="n">NonPublic</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Instance</span><span class="p">,</span> <span class="n">argTypes</span><span class="p">));</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ret</span><span class="p">);</span>

        <span class="n">CreateInstanceDelegate</span> <span class="p">=</span> <span class="n">dm</span><span class="p">.</span><span class="n">CreateDelegate</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Stream</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[],</span> <span class="n">CodedOutputStream</span><span class="p">&gt;&gt;();</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">AggressiveInlining</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">CodedOutputStream</span> <span class="nf">CreateInstance</span><span class="p">(</span><span class="n">Stream</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">CreateInstanceDelegate</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we are using <code class="language-plaintext highlighter-rouge">System.Reflection.Emit</code> to pretty much generate a new <code class="language-plaintext highlighter-rouge">CodedOutputStream.CreateInstance()</code> overload at runtime, which we then access via a cached delegate. Is it an overengineered hack? Yes. Does it work? Also yes.</p>

<p>With these targeted applications of <code class="language-plaintext highlighter-rouge">Span&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">ArrayPool&lt;T&gt;</code> we were able to get arrays under control and eliminate literally millions of unnecessary heap allocations. Nevertheless, this was just one stop in my optimization journey.</p>

<h4 id="boxing">Boxing</h4>

<p>Boxing is what occurs in C# when a value type is cast to a reference type. Here is the simplest example of this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="kt">object</span> <span class="n">boxedValue</span> <span class="p">=</span> <span class="p">(</span><span class="kt">object</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">int</code> is a value type and <code class="language-plaintext highlighter-rouge">object</code> is a reference type, and reference types cannot exist on the stack in C#, this conversion requires allocating an object instance on the heap that will contain our <code class="language-plaintext highlighter-rouge">value</code>.</p>

<p>In a simple example like this boxing is clear to see if you know about value and reference types, but some of the “automagical” C# features can cause unintentional boxing and heap allocations. One common pitfall for this are interfaces: interfaces are inherently reference types, so when a <code class="language-plaintext highlighter-rouge">struct</code>, a value type, implements an interface like <code class="language-plaintext highlighter-rouge">IEnumerator</code>, and is then cast to an instance of this interface, it will end up being boxed.</p>

<p>Here is an example of a very simplified wrapper class that implements the <code class="language-plaintext highlighter-rouge">IEnumerable</code> interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PowerCollection</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="n">_powers</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_powers</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Legacy non-generic version of GetEnumerator() required by IEnumerable here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you have it like this, you can very conveniently iterate all <code class="language-plaintext highlighter-rouge">Power</code> instances in your <code class="language-plaintext highlighter-rouge">PowerCollection</code> in a <code class="language-plaintext highlighter-rouge">foreach</code> loop:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">foreach</span> <span class="p">(</span><span class="n">Power</span> <span class="n">power</span> <span class="k">in</span> <span class="n">PowerCollection</span><span class="p">)</span>
    <span class="n">power</span><span class="p">.</span><span class="nf">EndPower</span><span class="p">();</span>
</code></pre></div></div>

<p>Here is a problem though: <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code> uses a struct-based enumerator to avoid heap allocations, but when you iterate like this, here is what is actually happening behind the scenes:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="p">(</span><span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="n">enumerator</span> <span class="p">=</span> <span class="n">PowerCollection</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">enumerator</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Power</span> <span class="n">power</span> <span class="p">=</span> <span class="n">enumerator</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
        <span class="n">power</span><span class="p">.</span><span class="nf">EndPower</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a result, your <code class="language-plaintext highlighter-rouge">List&lt;T&gt;.Enumerator</code> struct is cast to <code class="language-plaintext highlighter-rouge">IEnumerator</code> and boxed. You end up doing completely unnecessary heap allocations out of nowhere, and if you are iterating hundreds or even thousands of times per second, it can really add up.</p>

<p>The solution is to add a separate <code class="language-plaintext highlighter-rouge">GetEnumerator()</code> implementation for your wrapper classes that returns a concrete enumerator type:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PowerCollection</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="n">_powers</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;.</span><span class="n">Enumerator</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_powers</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;.</span><span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_powers</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Legacy non-generic version of GetEnumerator() required by IEnumerable here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This way you avoid boxing when doing a simple <code class="language-plaintext highlighter-rouge">foreach</code> iteration, but also still have access to various <code class="language-plaintext highlighter-rouge">IEnumerable</code> extension methods, like <code class="language-plaintext highlighter-rouge">Select()</code> and <code class="language-plaintext highlighter-rouge">Where()</code>.</p>

<h4 id="yield-return">yield return</h4>

<p>Related to iteration and boxing is another source of garbage: <code class="language-plaintext highlighter-rouge">yield return</code>. Looking again at the example above, it can also be implemented like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PowerCollection</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="n">_powers</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Power</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">Power</span> <span class="n">power</span> <span class="k">in</span> <span class="n">_powers</span><span class="p">)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">power</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Legacy non-generic version of GetEnumerator() required by IEnumerable here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a quick and dirty way of implementing a custom iterator, which can be great for getting complex filtered iteration up and running. However, behind the scenes this actually creates a state machine object that causes more heap allocations. So to optimize this, I went back and replaced some of our <code class="language-plaintext highlighter-rouge">yield return</code> filtered iteration implementations with struct-based <code class="language-plaintext highlighter-rouge">IEnumerator</code> implementations. It is a more verbose way of doing things, but it prevents more unnecessary garbage.</p>

<h4 id="delegates">Delegates</h4>

<p>Delegates in C# are objects that encapsulate function pointers. They are reference types, which means more heap allocations. And sometimes they happen when you do not expect it.</p>

<p>A good of example of this is one of the iteration methods of <code class="language-plaintext highlighter-rouge">PropertyCollection</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PropertyList</span><span class="p">.</span><span class="n">Iterator</span> <span class="nf">IteratePropertyRange</span><span class="p">(</span><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Func</span> <span class="n">filterFunc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_aggregateList</span><span class="p">.</span><span class="nf">IteratePropertyRange</span><span class="p">(</span><span class="n">filterFunc</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This takes a filter delegate defined in the <code class="language-plaintext highlighter-rouge">PropertyEnumFilter</code> static class as an argument:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">PropertyEnumFilter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">delegate</span> <span class="kt">bool</span> <span class="nf">Func</span><span class="p">(</span><span class="n">PropertyEnum</span> <span class="n">propertyEnum</span><span class="p">);</span>

    <span class="c1">// A filter function that skips properties that don't have a valid aggregation method</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Agg</span><span class="p">(</span><span class="n">PropertyEnum</span> <span class="n">propertyEnum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PropertyInfo</span> <span class="n">info</span> <span class="p">=</span> <span class="n">GameDatabase</span><span class="p">.</span><span class="n">PropertyInfoTable</span><span class="p">.</span><span class="nf">LookupPropertyInfo</span><span class="p">(</span><span class="n">propertyEnum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">Prototype</span><span class="p">.</span><span class="n">AggMethod</span> <span class="p">!=</span> <span class="n">AggregationMethod</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The most intuitive way of using it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">kvp</span> <span class="k">in</span> <span class="n">Properties</span><span class="p">.</span><span class="nf">IteratePropertyRange</span><span class="p">(</span><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Agg</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// Do something with properties</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But here is yet another pitfall: this</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Func</span> <span class="n">aggFunc</span> <span class="p">=</span> <span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Agg</span><span class="p">;</span>
</code></pre></div></div>

<p>is actually a short way of writing this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Func</span> <span class="n">aggFunc</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">Agg</span><span class="p">);</span>
</code></pre></div></div>

<p>So every time you pass a function as an argument, you end up instantiating an extra delegate. The garbage-free way of doing this actually looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">PropertyEnumFilter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">delegate</span> <span class="kt">bool</span> <span class="nf">Func</span><span class="p">(</span><span class="n">PropertyEnum</span> <span class="n">propertyEnum</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Func</span> <span class="n">AggFunc</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="n">Agg</span><span class="p">;</span>

    <span class="c1">// A filter function that skips properties that don't have a valid aggregation method</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Agg</span><span class="p">(</span><span class="n">PropertyEnum</span> <span class="n">propertyEnum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PropertyInfo</span> <span class="n">info</span> <span class="p">=</span> <span class="n">GameDatabase</span><span class="p">.</span><span class="n">PropertyInfoTable</span><span class="p">.</span><span class="nf">LookupPropertyInfo</span><span class="p">(</span><span class="n">propertyEnum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">Prototype</span><span class="p">.</span><span class="n">AggMethod</span> <span class="p">!=</span> <span class="n">AggregationMethod</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Which you then use like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">kvp</span> <span class="k">in</span> <span class="n">Properties</span><span class="p">.</span><span class="nf">IteratePropertyRange</span><span class="p">(</span><span class="n">PropertyEnumFilter</span><span class="p">.</span><span class="n">AggFunc</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// Do something with properties</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This little maneuver’s gonna save us 800 000 allocations on server startup.</p>

<h4 id="stack-like-pooling">Stack-like Pooling</h4>

<p>Sometimes you just need a way of imitating C++’s “allocate whatever on the stack” behavior. A good example of this is <code class="language-plaintext highlighter-rouge">PropertyCollection</code>: it is a pretty heavy data structure that is occasionally used just as a way of transferring data. For instance, when you create an <code class="language-plaintext highlighter-rouge">Entity</code>, you can pass it a <code class="language-plaintext highlighter-rouge">PropertyCollection</code> as a parameter, and all properties in it will be copied to the freshly created <code class="language-plaintext highlighter-rouge">Entity</code>. This temporary <code class="language-plaintext highlighter-rouge">PropertyCollection</code> has a very short lifespan, never leaves its initial scope, and the client actually uses stack allocations for it. However, in C# “we don’t do that here”, so we need a workaround.</p>

<p>The one I have implemented involves an approach similar to what is used for database connections. We define an interface for poolable objects:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IPoolable</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ResetForPool</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then we create a manager singleton:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ObjectPoolManager</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">ObjectPoolManager</span> <span class="n">Instance</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">private</span> <span class="nf">ObjectPoolManager</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IPoolable</span><span class="p">,</span> <span class="k">new</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Retrieve or create a new object of type T</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="n">Return</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">instance</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IPoolable</span><span class="p">,</span> <span class="k">new</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
        <span class="c1">// Return a previously created object to the pool</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we can implement two interfaces on objects that we want to use in a stack-allocated fashion:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PropertyCollection</span> <span class="p">:</span> <span class="n">IPoolable</span><span class="p">,</span> <span class="n">IDisposable</span>
<span class="p">{</span>
    <span class="c1">// The rest of the class</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">ResetForPool</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">Clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">ObjectPoolManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we can use it like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">PropertyCollection</span> <span class="n">tempProperties</span> <span class="p">=</span> <span class="n">ObjectPoolManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">PropertyCollection</span><span class="p">&gt;();</span>
</code></pre></div></div>

<p>When we leave the scope where we got this collection, in a very stack-like fashion our <code class="language-plaintext highlighter-rouge">PropertyCollection</code> is “disposed” thanks to the <code class="language-plaintext highlighter-rouge">using</code> keyword, which in this case returns it to the pool and clears it. This reduces the number of <code class="language-plaintext highlighter-rouge">PropertyCollection</code> allocations we need to do from hundreds of thousands to just 3 or 4 per game instance.</p>

<h3 id="round-2-game-database-initialization">Round 2: Game Database Initialization</h3>

<p>Hello darkness, my old friend. Those of you who have been following these reports since the beginning will remember our earlier, many months-long struggle with implementing the game database. Eventually everything got to a functional state, but I was never really happy with how well it performed. Not only did it take pretty long to start if you were preloading all prototypes (about 14.5 seconds on my machine), even when loading prototypes on demand you would occasionally get long lags when defeating certain enemies for the first time, caused by their loot tables being deserialized. So with this optimization pass I was determined to dive back into the abyss and try to make it better.</p>

<h4 id="pak-files">Pak Files</h4>

<p>The very first thing that happens when you start MHServerEmu is the initialization of the <code class="language-plaintext highlighter-rouge">PakFileSystem</code>. All game data files are stored in <code class="language-plaintext highlighter-rouge">.sip</code> packages that consist of a header, an entry table, and raw data for all files compressed using the <a href="https://lz4.org/">LZ4</a> algorithm. Both the client and our server implementation read the header and the entry table, and then load the compressed data for all files into RAM. When files need to be decompressed and deserialized, their data is taken from RAM rather than disk. This may seem wasteful at first, but this is actually much faster than performing file system IO operations thousands of times.</p>

<p>Previously, we were loading data for each file into separate <code class="language-plaintext highlighter-rouge">byte[]</code> buffers. As I was rechecking all of our libraries after I discovered the issues with <code class="language-plaintext highlighter-rouge">RobustPredicates</code>, I noticed that our LZ4 implementation, <a href="https://github.com/MiloszKrajewski/K4os.Compression.LZ4">K4os.Compression.LZ4</a>, actually accepts <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Span&lt;T&gt;</code> as arguments. Before, we were looking at spans as a way of doing stack allocations for arrays, but they have another use: “slicing” an array. A span is essentially just a way of representing regions of memory, and you can represent different sections of the same array as different spans.</p>

<p>So I had an idea for of dealing with <code class="language-plaintext highlighter-rouge">.sip</code> packages more efficiently: rather than reading data for each file into separate buffers, we could just read everything into a single large buffer, and slice it with spans on decompression. While it wasn’t really what the file format was designed for, it was easy to implement thanks to the fact that all file entries are in the same order as their data that follows, so the total size of the data section can be easily calculated from the last entry as follows:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">numEntries</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="nf">ReadInt32</span><span class="p">();</span>
<span class="n">_entryDict</span><span class="p">.</span><span class="nf">EnsureCapacity</span><span class="p">(</span><span class="n">numEntries</span><span class="p">);</span>

<span class="n">PakEntry</span> <span class="n">newEntry</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">numEntries</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">newEntry</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
    <span class="n">_entryDict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newEntry</span><span class="p">.</span><span class="n">FilePath</span><span class="p">,</span> <span class="n">newEntry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">dataSize</span> <span class="p">=</span> <span class="n">newEntry</span><span class="p">.</span><span class="n">Offset</span> <span class="p">+</span> <span class="n">newEntry</span><span class="p">.</span><span class="n">CompressedSize</span><span class="p">;</span>
<span class="n">_data</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="nf">ReadBytes</span><span class="p">(</span><span class="n">dataSize</span><span class="p">);</span>
</code></pre></div></div>

<p>Doing it this way doubled the performance of this initial step, reducing the time it takes from 200 to 100 ms on my machine. The real challenge still awaited me though.</p>

<h4 id="prototype-copying">Prototype Copying</h4>

<p>While my initial assumption was that our performance issues were caused by overreliance on <code class="language-plaintext highlighter-rouge">System.Reflection.PropertyInfo.SetValue()</code> for assigning deserialized field values, to my surprise, it wasn’t actually that bad: even when I did some tests and tried implementing caching and eliminating boxing, it made practically no difference. However, profiling revealed the actual culprit: <code class="language-plaintext highlighter-rouge">CalligraphySerializer.CopyPrototypeFields()</code>, which is called 625 772 times when doing a full server initialization. Within it there were two issues that were absolutely killing our performance.</p>

<p>The first issue was pretty straightforward: we were calling <code class="language-plaintext highlighter-rouge">GetProperties()</code> to get an array of C# <code class="language-plaintext highlighter-rouge">PropertyInfo</code> instances for the prototype type that is being copied. Not only <code class="language-plaintext highlighter-rouge">GetProperties()</code> is more costly than I thought, we were actually redoing the work of filtering non-Calligraphy fields each time. By implementing caching here, we reduced the number of <code class="language-plaintext highlighter-rouge">GetProperties()</code> calls and subsequent filtering to just 877, giving us a noticable boost.</p>

<p>But the real gains were in solving the second issue, that lied within the <code class="language-plaintext highlighter-rouge">AssignPointedAtValues()</code> function called in <code class="language-plaintext highlighter-rouge">CopyPrototypeFields()</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AssignPointedAtValues</span><span class="p">(</span><span class="n">Prototype</span> <span class="n">destPrototype</span><span class="p">,</span> <span class="n">Prototype</span> <span class="n">sourcePrototype</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Reflection</span><span class="p">.</span><span class="n">PropertyInfo</span> <span class="n">fieldInfo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fieldInfo</span><span class="p">.</span><span class="nf">SetValue</span><span class="p">(</span><span class="n">destPrototype</span><span class="p">,</span> <span class="n">fieldInfo</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">sourcePrototype</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This little line of naive reflection runs 7 317 481 times during full server initialization, and it used to take about 2750 out of 14500 ms it took to load all prototypes on my machine. There are much better ways of handling this, and at first I went for the most obvious one you see recommended: using expression trees to compile and cache delegates:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">CopyValue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">PropertyInfo</span> <span class="n">propertyInfo</span><span class="p">,</span> <span class="n">T</span> <span class="n">source</span><span class="p">,</span> <span class="n">T</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CopyPropertyValueDelegateDict</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">propertyInfo</span><span class="p">,</span> <span class="k">out</span> <span class="n">Delegate</span> <span class="n">copyValueDelegate</span><span class="p">)</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ParameterExpression</span> <span class="n">sourceParam</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Parameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">object</span><span class="p">));</span>
        <span class="n">ParameterExpression</span> <span class="n">destinationParam</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Parameter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">object</span><span class="p">));</span>

        <span class="n">Type</span> <span class="n">type</span> <span class="p">=</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="n">DeclaringType</span><span class="p">;</span>

        <span class="n">UnaryExpression</span> <span class="n">castSourceParam</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Convert</span><span class="p">(</span><span class="n">sourceParam</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
        <span class="n">UnaryExpression</span> <span class="n">castDestinationParam</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Convert</span><span class="p">(</span><span class="n">destinationParam</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

        <span class="n">MethodCallExpression</span> <span class="n">getCall</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="n">castSourceParam</span><span class="p">,</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="nf">GetGetMethod</span><span class="p">());</span>
        <span class="n">MethodCallExpression</span> <span class="n">setCall</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="n">castDestinationParam</span><span class="p">,</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="nf">GetSetMethod</span><span class="p">(</span><span class="k">true</span><span class="p">),</span> <span class="n">getCall</span><span class="p">);</span>

        <span class="n">copyValueDelegate</span> <span class="p">=</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">&lt;</span><span class="n">CopyValueDelegate</span><span class="p">&gt;(</span><span class="n">setCall</span><span class="p">,</span> <span class="n">sourceParam</span><span class="p">,</span> <span class="n">destinationParam</span><span class="p">).</span><span class="nf">Compile</span><span class="p">();</span>
        <span class="n">CopyPropertyValueDelegateDict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">propertyInfo</span><span class="p">,</span> <span class="n">copyValueDelegate</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">var</span> <span class="n">copy</span> <span class="p">=</span> <span class="p">(</span><span class="n">CopyValueDelegate</span><span class="p">)</span><span class="n">copyValueDelegate</span><span class="p">;</span>
    <span class="nf">copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This generates and caches functions for every encountered prototype/C# property combination that are equivalent to this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">CopyValue</span><span class="p">(</span><span class="n">Prototype</span> <span class="n">source</span><span class="p">,</span> <span class="n">Prototype</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="n">SomePrototype</span><span class="p">)</span><span class="n">destination</span><span class="p">).</span><span class="n">SomeProperty</span> <span class="p">=</span> <span class="p">((</span><span class="n">SomePrototype</span><span class="p">)</span><span class="n">source</span><span class="p">).</span><span class="n">SomeProperty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This did give me a performance boost, reducing the time it took from 2750 to about 1750 ms. However, as I looked more closely at what was taking time, I realized that creating and compiling expression trees took about 1050 ms, with only 700 ms spent on the actual workload. While it was more efficient than naive reflection, it was obvious I was still missing out on performance.</p>

<p>I had to descend deep into the forbidden archives of Microsoft Learn and seek the dark knowledge of <code class="language-plaintext highlighter-rouge">System.Reflection.Emit</code>. Rather than relying on an abstraction in the form of expression trees, I had to throw away what remained of my humanity and look into the abyss of the Microsoft Intermediate Language (MSIL) directly. The end result looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">CopyValue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">PropertyInfo</span> <span class="n">propertyInfo</span><span class="p">,</span> <span class="n">T</span> <span class="n">source</span><span class="p">,</span> <span class="n">T</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CopyPropertyValueDelegateDict</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">propertyInfo</span><span class="p">,</span> <span class="k">out</span> <span class="n">Delegate</span> <span class="n">copyValueDelegate</span><span class="p">)</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Type</span> <span class="n">type</span> <span class="p">=</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="n">DeclaringType</span><span class="p">;</span>

        <span class="n">DynamicMethod</span> <span class="n">dm</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"CopyValue"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">CopyValueArgs</span><span class="p">);</span>
        <span class="n">ILGenerator</span> <span class="n">il</span> <span class="p">=</span> <span class="n">dm</span><span class="p">.</span><span class="nf">GetILGenerator</span><span class="p">();</span>

        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_1</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Castclass</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_0</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Castclass</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Callvirt</span><span class="p">,</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="nf">GetGetMethod</span><span class="p">());</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Callvirt</span><span class="p">,</span> <span class="n">propertyInfo</span><span class="p">.</span><span class="nf">GetSetMethod</span><span class="p">(</span><span class="k">true</span><span class="p">));</span>
        <span class="n">il</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ret</span><span class="p">);</span>

        <span class="n">copyValueDelegate</span> <span class="p">=</span> <span class="n">dm</span><span class="p">.</span><span class="n">CreateDelegate</span><span class="p">&lt;</span><span class="n">CopyValueDelegate</span><span class="p">&gt;();</span>
        <span class="n">CopyPropertyValueDelegateDict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">propertyInfo</span><span class="p">,</span> <span class="n">copyValueDelegate</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">var</span> <span class="n">copy</span> <span class="p">=</span> <span class="p">(</span><span class="n">CopyValueDelegate</span><span class="p">)</span><span class="n">copyValueDelegate</span><span class="p">;</span>
    <span class="nf">copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>NOTE: Chronologically this happened before my <code class="language-plaintext highlighter-rouge">CodedOutputStream</code> hack I talked about above. This is actually the real moment of my <code class="language-plaintext highlighter-rouge">ILGenerator</code> downfall.</em></p>

<p>This emits the same code as using expression trees, but at an almost ridiculously lower cost: my delegate creation time went from 1050 to about 70 ms, bringing the total time time <code class="language-plaintext highlighter-rouge">AssignPointedAtValues()</code> took to just about 770 ms, a 72% reduction.</p>

<h4 id="net-8-and-quick-jit-for-loops">.NET 8 and Quick JIT for Loops</h4>

<p>C# is part of the .NET platform, and the way it works these days is that there is a new version released every year. Odd versions (7, 8, 9) are supported for 1.5 years, while even versions (6, 8, 10) are long-term support (LTS) releases with 3 years of updates. When a version’s support ends, it stops receiving updates, including security fixes, and Visual Studio starts giving you the evil eye for targeting a “deprecated” framework. The support for .NET 6, the version that MHServerEmu is currently targeting, will end on November 12, 2024. While we can live with VS annoying us slightly more than usual, not having security updates for potentially public-facing server software is unacceptable, so we had to get ready for November.</p>

<p>I had been testing this for some time now. Retargeting is as easy as changing the number from 6 to 8 in project files and pressing the “Build” button, but there were two issues that made me less enthusiastic about this forced upgrade.</p>

<p>The first one is admittedly rather silly: .NET 7 dropped the support for Windows 7, so by retargeting to .NET 8 we would be doing so as well. This is honestly not that big of a deal: the few Windows 7 enjoyers (0.37% of Steam users according to the August 2024 hardware survey) are probably getting used to their OS of choice no longer being supported, and if you really want to, you can retarget the server back to a legacy framework relatively easily.</p>

<p>The other one was much more severe though: for some reason, the exact same game database initialization code targeting .NET 8 ran 35% slower than in .NET 6, contrary to all claims of performance improvements that new .NET versions bring. Something was not right here, but it was difficult to pinpoint the exact issue by profiling.</p>

<p>Eventuallly I ran into <a href="https://stackoverflow.com/questions/74833459/performance-issue-with-for-loop-on-the-initial-run-on-net-7/74837351">a discussion on Stack Overflow</a> started by somebody who was having a similar issue when upgrading to .NET 7. This massive performance degradation appears to be indirectly caused by a feature called <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#on-stack-replacement">On-Stack Replacement</a> introduced in .NET 7. Here is an overview of what was happening:</p>

<ul>
  <li>
    <p>When you build your project, your C# code is compiled to intermediate language (IL), also referred to as bytecode.</p>
  </li>
  <li>
    <p>The runtime that executes your program uses just-in-time (JIT) compilation to compile IL to native code for the platform it is running on. This happens as the program is being executed.</p>
  </li>
  <li>
    <p>There are cases when it takes more time to compile IL than to actually execute it, and if this code is only executed once, wasting too much time compiling it leads to an overall performance loss.</p>
  </li>
  <li>
    <p>To mitigate this issue, a feature called <em>tiered compilation</em> was introduced to the JIT compiler in .NET Core 2.1. When a piece of code is executed for the first time, it is compiled quickly with minimal optimizations, which is called <em>quick JIT</em>. If the runtime detects that your code is executed often enough, it recompiles it with a higher level of optimization.</p>
  </li>
  <li>
    <p>When quick JIT was first introduced, it had performance issues with functions containing loops, so it was disabled by default for those cases. .NET 7 changes apparently made this no longer necessary, so quick JIT for loops became enabled by default, even though the <a href="https://learn.microsoft.com/en-us/dotnet/core/runtime-config/compilation#quick-jit-for-loops">documentation</a> still says the default behavior is equivalent to <code class="language-plaintext highlighter-rouge">false</code>.</p>
  </li>
</ul>

<p>The game database initialization contains many intensive functions with loops that are executed only once. Because of this, most of them do not use quick JIT in .NET 6, making them compile to optimized native code on the initial run (which is their <em>only</em> run). In .NET 8, by default quick JIT is now applied to them, making them run in their less optimized form.</p>

<p>Turning quick JIT for loops off brought our code running on .NET 8 approximately back to .NET 6 levels. Turning quick JIT completely off gave us a noticable performance boost on <em>both</em> 6 and 8 (about 500 ms on my machine).</p>

<hr />

<p>All of these optimizations brought full database initialization time from approximately 14500 ms to 8500 ms on average on my machine, an overall 40-42% boost.</p>

<h3 id="round-3-propertylist">Round 3: PropertyList</h3>

<p>The final frontier of this optimization pass was always going to be the <code class="language-plaintext highlighter-rouge">PropertyList</code> data structure. Properties are everywhere in this game: heroes, villains, friendly NPCs, regions, powers, conditions, and more. This makes any changes made to this system more impactful, both in terms of performance gains and ways thing can go wrong.</p>

<p>Each <code class="language-plaintext highlighter-rouge">PropertyCollection</code> has two <code class="language-plaintext highlighter-rouge">PropertyList</code> instances backing it. One is called a <em>base list</em>, which contains all properties actually belonging to that collection. The other one is referred to as an <em>aggregate list</em>, and it contains properties from the base list aggregated (combined) with properties from all attached child collections. The simplest example of this would be an avatar with equipped gear: <code class="language-plaintext highlighter-rouge">PropertyCollection</code> instances of each equipped item are aggregated with the avatar’s own collection, which results in the base list containing properties inherent to the avatar entity itself, and the aggregate list containing a combination of the avatar’s base properties with all of the item properties.</p>

<p>Our previous <code class="language-plaintext highlighter-rouge">PropertyList</code> implementation was just a simple wrapper around <code class="language-plaintext highlighter-rouge">Dictionary&lt;PropertyId, PropertyValue&gt;</code>. It works well for simple lookups, but the game makes heavy use of all kinds of filtered property iteration, some of which require properties to be grouped by <code class="language-plaintext highlighter-rouge">PropertyEnum</code> (see the <a href="/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html">February 2024 report</a> for more information on how properties work). Initially I tried using <code class="language-plaintext highlighter-rouge">SortedDictionary&lt;PropertyId, PropertyValue&gt;</code>, but its performance was not acceptable compared to a regular dictionary. The fastest and easiest to implement solution that would do the job turned out to be using the <code class="language-plaintext highlighter-rouge">OrderBy()</code> LINQ extension method for every iteration, which copies all data to a new collection and sorts it. While it did work, it was also stupidly inefficient, especially in terms of memory allocation. And when you consider that <code class="language-plaintext highlighter-rouge">PropertyList</code> iteration is also used for lookup methods, like <code class="language-plaintext highlighter-rouge">PropertyCollection.HasProperty()</code>, it starts getting just silly.</p>

<p>For this overhaul I took another look at the client implementation, aptly named <code class="language-plaintext highlighter-rouge">NewPropertyList</code>. While it does some things that do not translate to C# well, there is one core concept I adapted from it. In most cases properties are actually <em>not</em> parameterized: it is common that over a half or even all properties in a collection are basically combinations of <code class="language-plaintext highlighter-rouge">PropertyEnum</code> and <code class="language-plaintext highlighter-rouge">PropertyValue</code>. So instead of storing all properties in a single monolithic collection, it is actually more efficient to use a divide-and-conquer approach:</p>

<ul>
  <li>
    <p>Each <code class="language-plaintext highlighter-rouge">PropertyEnum</code> gets a <code class="language-plaintext highlighter-rouge">PropertyEnumNode</code> instance, which can be accessed by a hash table (a <code class="language-plaintext highlighter-rouge">Dictionary&lt;PropertyEnum, PropertyEnumNode&gt;</code> in our implementation).</p>
  </li>
  <li>
    <p>Each <code class="language-plaintext highlighter-rouge">PropertyEnumNode</code> consists of a <code class="language-plaintext highlighter-rouge">PropertyValue</code> and a <code class="language-plaintext highlighter-rouge">PropertyArray</code>, which is a collection of <code class="language-plaintext highlighter-rouge">PropertyId</code>/<code class="language-plaintext highlighter-rouge">PropertyValue</code> pairs. A node is essentially a bucket for a specific <code class="language-plaintext highlighter-rouge">PropertyEnum</code>.</p>
  </li>
  <li>
    <p>When a node is created for an enum for the first time, the list checks whether or not the <code class="language-plaintext highlighter-rouge">PropertyId</code> that is being set has parameters. If it does, a new <code class="language-plaintext highlighter-rouge">PropertyArray</code> is allocated for it, and the id/value pair is added there. If it does not, the value is simply assigned to the <code class="language-plaintext highlighter-rouge">PropertyValue</code> field.</p>
  </li>
  <li>
    <p>If an existing node containing a non-parameterized property is updated with another non-parameterized property, the value field is simply overwritten. If a parameterized property is added to a non-parameterized node, a new <code class="language-plaintext highlighter-rouge">PropertyArray</code> is allocated for this node, and both id/value pairs are added to it.</p>
  </li>
</ul>

<p>The end result in our best case scenario is that we do a single dictionary lookup and immediately get our non-parameterized value from the node, nice and efficient. And because most of the time properties are not parameterized, we get our best case most of the time.</p>

<p>When I was picking the backing data structure for our <code class="language-plaintext highlighter-rouge">PropertyArray</code> implementation, at first I looked again at what I tried before, <code class="language-plaintext highlighter-rouge">Dictionary&lt;PropertyId, PropertyValue</code> and <code class="language-plaintext highlighter-rouge">SortedDictionary&lt;PropertyId, PropertyValue&gt;</code>. My thinking was that maybe sorted dictionaries will outperform hashed ones at smaller element counts, but this assumption was wrong: benchmarking revealed that hash dictionaries were faster in pretty much all circumstances in .NET 6, and almost on par in .NET 8. However, creating tens of thousands of dictionaries, each managing their own hash buckets, was too costly for this, so I looked for the simplest solution possible.</p>

<p>The one I ended up picking was <code class="language-plaintext highlighter-rouge">List&lt;PropertyPair&gt;</code>, with <code class="language-plaintext highlighter-rouge">PropertyPair</code> being a variation of <code class="language-plaintext highlighter-rouge">KeyValuePair&lt;PropertyId, PropertyValue&gt;</code> with an <code class="language-plaintext highlighter-rouge">IComparable</code> implementation that compares pairs by keys. We add pairs to the list in sorted order, which in practice is basically free, because the most common case for property assignment is copying them from another collection, where they would already be sorted.</p>

<p>Since our lists are often tiny (&lt; 10 elements), for lookups we are using the simplest thing possible: linear search with early exit.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="n">PropertyId</span> <span class="n">id</span><span class="p">,</span> <span class="k">out</span> <span class="n">PropertyValue</span> <span class="k">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="n">_list</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">PropertyPair</span> <span class="n">pair</span> <span class="p">=</span> <span class="n">_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="n">id</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">value</span> <span class="p">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">Id</span><span class="p">.</span><span class="n">Raw</span> <span class="p">&gt;</span> <span class="n">id</span><span class="p">.</span><span class="n">Raw</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">value</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I did some measurements actually playing the game, and in the vast majority of cases (94.13%) this loop exits at <code class="language-plaintext highlighter-rouge">i &lt; 8</code>, with a significant portion of them (32.38%) being at <code class="language-plaintext highlighter-rouge">i &lt; 4</code>. Relatively costly lookups (<code class="language-plaintext highlighter-rouge">i &gt;= 16</code>) were only 5.69%.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/property-array.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/property-array.png" alt="PropertyArray Lookups" /></a></p>

<p>With usage like this, the simpler thing is actually more efficient than doing something more complex, like binary search. In theory it should also work better with the CPU’s branch prediction, making it even faster.</p>

<p>With all of that done, the new <code class="language-plaintext highlighter-rouge">PropertyList</code> implementation was almost a drop-in replacement for the old one. The only real major difference that had to be dealt with was the fact that the list can no longer be modified while it is being iterated, because we are now iterating the actual data instead of its copy. However, there were only two such cases in our codebase, and they were both very easy to fix.</p>

<hr />

<p>And with that our optimization journey comes to an end. There are always more gains to be made, but for now I feel the server is in a much better state than it was a month ago, and now I can get back to implementing exciting gameplay features, such as conditions (buffs/debuffs) and loot system improvements.</p>

<h2 id="mission-impossible">Mission: Impossible</h2>

<p><em>Time for a deep dive into missions, presented by AlexBond.</em></p>

<hr />

<p>Hey everyone, it’s AlexBond. Let there be missions!</p>

<p>In this report I would like to share details on how I brought missions back to the game, and how it all works.</p>

<h3 id="mission-prototypes">Mission Prototypes</h3>

<p>The first thing to do was figuring out what prototypes are used for missions and how they are related to each other. Using the <em>Game Database Browser</em>, I determined the four main prototype classes:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MissionPrototype</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MissionObjectivePrototype</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MissionActionPrototype</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MissionConditionPrototype</code></p>
  </li>
</ul>

<p>There are various subclasses of MissionPrototype (<code class="language-plaintext highlighter-rouge">OpenMissionPrototype</code>, <code class="language-plaintext highlighter-rouge">LegendaryMissionPrototype</code>, <code class="language-plaintext highlighter-rouge">DailyMissionPrototype</code>, <code class="language-plaintext highlighter-rouge">AdvancedMissionPrototype</code>), but this time we will be looking at the base type.</p>

<p>The two primary groups of data contained in a <code class="language-plaintext highlighter-rouge">MissionPrototype</code> are <code class="language-plaintext highlighter-rouge">MissionConditions</code> and <code class="language-plaintext highlighter-rouge">MissionActions</code>. The former group defines events that need to tracked, while the latter determines what will happen when a mission’s state changes.</p>

<p>Here is an overview of how <code class="language-plaintext highlighter-rouge">MissionPrototype</code> data is used to interact with players and other objects in the game world:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-1.png" alt="Mission Structure" style="max-height: 500px;" /></a>
</center>

<p>The are two varieties of <code class="language-plaintext highlighter-rouge">MissionManager</code>: one for regions, and one for player entities.</p>

<p>When a region is loaded, a global <code class="language-plaintext highlighter-rouge">MissionManager</code> is created and bound to that region. It then loads all <code class="language-plaintext highlighter-rouge">OpenMissionPrototype</code> instances that specify this region in their <code class="language-plaintext highlighter-rouge">ActiveInRegions</code> field.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-2.png" alt="ActiveInRegions" /></a></p>

<p>Also, as part of the region generation process, a function called <code class="language-plaintext highlighter-rouge">GenerateMissionPopulation()</code> is run, which takes population data from <code class="language-plaintext highlighter-rouge">PopulationSpawns</code> and forwards it to a <code class="language-plaintext highlighter-rouge">MissionSpawnEvent</code> (more on that later).</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-3.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-3.png" alt="MissionPopulationEntry" /></a></p>

<p>After the region finishes loading and spawning all required objects, the mission’s state changes to active, and the <code class="language-plaintext highlighter-rouge">OnStartActions</code> event is invoked, which mainly activates various ambient animations for NPCs and mobs using <code class="language-plaintext highlighter-rouge">MissionActionEntityPerformPowerPrototype</code>.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-4.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-4.png" alt="MissionActionEntityPerformPowerPrototype" /></a></p>

<p>Each mission has a <code class="language-plaintext highlighter-rouge">MissionState</code> that switches in the following order:</p>

<p><code class="language-plaintext highlighter-rouge">Invalid</code> - <code class="language-plaintext highlighter-rouge">Inactive</code> - <code class="language-plaintext highlighter-rouge">Available</code> - <code class="language-plaintext highlighter-rouge">Completed</code> - <code class="language-plaintext highlighter-rouge">Failed</code></p>

<p>The switching process is very complex, so I will not be going into detail on how it works. Instead, here is a flowchart:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-5.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-5.png" alt="Mission State Chart" /></a></p>

<h3 id="missionobjective">MissionObjective</h3>

<p>Each mission contains a collection of <em>objectives</em>. <code class="language-plaintext highlighter-rouge">MissionObjective</code> has some differences from <code class="language-plaintext highlighter-rouge">Mission</code>, but overall they are very similar:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-6.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-6.png" alt="Mission Objective Structure" style="max-height: 500px;" /></a>
</center>

<p>When a mission is activated, it switches all of its objectives to the <code class="language-plaintext highlighter-rouge">Available</code> state. This registers events for triggers and creates all the required <em>actions</em> and <em>conditions</em>. When an objective’s state changes to <code class="language-plaintext highlighter-rouge">Active</code>, its <code class="language-plaintext highlighter-rouge">SuccessConditions</code> start being tracked.</p>

<p>All objectives are completed in order, and more often than not their success condition is the completion of another mission. <code class="language-plaintext highlighter-rouge">MissionObjectiveState</code> switching process is similar to <code class="language-plaintext highlighter-rouge">MissionState</code>, but there are some differences. Here is a diagram of this process:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-7.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-7.png" alt="Missions Objective State Chart" /></a></p>

<p>Now that we have “figured out” all the complexities, it’s time to take a look at how it all works in the game in the context of the <em>story</em> mode.</p>

<h3 id="story">Story</h3>

<p>The game went through a lot of rewrites: many patches came out, the story mode underwent changes, content was removed, gameplay systems were reworked. Because of this, the prototypes are a mess of working and deprecated missions mixed together. Some missions have conflicts with one another, and others do not work at all. Let’s take a look at this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-8.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-8.png" alt="Act vs Story" /></a></p>

<p>As you can see, we have two mission directories, and many missions are duplicated and/or have conflicts… Sometimes it’s the Story missions that are the working ones, and sometimes it’s the ones from Acts…</p>

<p>Let’s take a look at an example of Story with Chapter 1.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-9.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-9.png" alt="Story Chapter 1" style="max-height: 500px;" /></a>
</center>

<p>Missions are divided into <code class="language-plaintext highlighter-rouge">Main</code>, <code class="language-plaintext highlighter-rouge">Controllers</code>, <code class="language-plaintext highlighter-rouge">Discoveries</code>, and <code class="language-plaintext highlighter-rouge">Events</code>.</p>

<p>Each <code class="language-plaintext highlighter-rouge">Main</code> mission contains objectives:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-10.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-10.png" alt="Mission Objectives" /></a>
</center>

<p>Let’s examine one of these objectives:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-11.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-11.png" alt="Mission Objective Example" /></a></p>

<p>The completion of this objective requires the fullfillment of a <code class="language-plaintext highlighter-rouge">MissionConditionMissionComplete</code> for a controller (another mission) - <code class="language-plaintext highlighter-rouge">NYPDSonicEmitter</code> .</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-12.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-12.png" alt="Mission Condition Example" /></a></p>

<p>Within this controller there are three more conditions:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-13.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-13.png" alt="Mission Controller Example" /></a></p>

<p><code class="language-plaintext highlighter-rouge">Controller</code> missions in most cases manage a single boss, animation, or event.</p>

<p><code class="language-plaintext highlighter-rouge">Discovery</code> missions activate triggers for discoverable mission objects on the map. They manage interactable NPCs that need to be saved or helped. All interactable NPCs on the map are <code class="language-plaintext highlighter-rouge">Discovery</code> missions.</p>

<p><code class="language-plaintext highlighter-rouge">Event</code> missions start region events when a player comes near them.</p>

<p>In other words, <code class="language-plaintext highlighter-rouge">MissionPrototype</code> is essentially a form of scripting. Many smaller missions are restarted automatically.</p>

<p>All of the above was about <em>region missions</em>, now let’s talk about <em>player missions</em>.</p>

<h3 id="player-missions">Player Missions</h3>

<p>Player missions start loading when a player with an active chapter enters a region. In total there are 303 such missions. They are saved per account and represent a player’s story progress. Many of them have the <code class="language-plaintext highlighter-rouge">SaveStatePerAvatar</code> flag and are saved in property collections of each avatar separately, which is what allows you to play through the story from beginning to end as each hero separately.</p>

<p>When I was testing the story, these missions were enough to get me to chapter 5, where I encountered <code class="language-plaintext highlighter-rouge">MetaGames</code> with no way forward without implementing them.</p>

<h3 id="metagames">MetaGames</h3>

<p>MetaGames are sets of global events for a given region that run on timers. Each MetaGame has a <code class="language-plaintext highlighter-rouge">MetaGameMode</code> and various <code class="language-plaintext highlighter-rouge">MetaStates</code>. The start of a MetaGame event usually creates a UI widget that looks like this:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-14.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-14.jpg" alt="MetaGame Widget" /></a>
</center>

<p>Here is a list of modes that exist:</p>

<table>
  <thead>
    <tr>
      <th>GameMode</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MetaGameMode</td>
      <td>Story</td>
    </tr>
    <tr>
      <td>MetaGameModeIdle</td>
      <td>TrainingRoom</td>
    </tr>
    <tr>
      <td>MetaGameModeShutdown</td>
      <td>Challenges</td>
    </tr>
    <tr>
      <td>MetaGameStateMode</td>
      <td>Story</td>
    </tr>
    <tr>
      <td>NexusPvPMainMode</td>
      <td> </td>
    </tr>
    <tr>
      <td>PvEScaleGameMode</td>
      <td>Limbo</td>
    </tr>
    <tr>
      <td>PvEWaveGameMode</td>
      <td> </td>
    </tr>
    <tr>
      <td>PvPDefenderGameMode</td>
      <td>PvP</td>
    </tr>
  </tbody>
</table>

<p>As you can see, the story uses only two modes. It also requires a number of states: <code class="language-plaintext highlighter-rouge">MetaStateMissionActivate</code>, <code class="language-plaintext highlighter-rouge">MetaStateMissionSequence</code>, <code class="language-plaintext highlighter-rouge">MetaStatePopulationMaintain</code>, and <code class="language-plaintext highlighter-rouge">MetaStateWaveInstance</code>.</p>

<p>Here is a full list of all states:</p>

<table>
  <thead>
    <tr>
      <th>MetaState</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MetaStateCombatQueueLockout</td>
      <td>Raids</td>
    </tr>
    <tr>
      <td>MetaStateEntityEventCounter</td>
      <td>XMansion, Holo-Sim</td>
    </tr>
    <tr>
      <td>MetaStateEntityModifier</td>
      <td>XMansion, Holo-Sim</td>
    </tr>
    <tr>
      <td>MetaStateLimitPlayerDeaths</td>
      <td>Gate, Raids</td>
    </tr>
    <tr>
      <td>MetaStateLimitPlayerDeathsPerMission</td>
      <td>SurturDebugMainMode</td>
    </tr>
    <tr>
      <td>MetaStateMissionActivate</td>
      <td> </td>
    </tr>
    <tr>
      <td>MetaStateMissionProgression</td>
      <td>Raids</td>
    </tr>
    <tr>
      <td>MetaStateMissionRestart</td>
      <td>AxisRaid</td>
    </tr>
    <tr>
      <td>MetaStateMissionSequence</td>
      <td> </td>
    </tr>
    <tr>
      <td>MetaStateMissionStateListener</td>
      <td>XMansion</td>
    </tr>
    <tr>
      <td>MetaStatePopulationMaintain</td>
      <td> </td>
    </tr>
    <tr>
      <td>MetaStateRegionPlayerAccess</td>
      <td> </td>
    </tr>
    <tr>
      <td>MetaStateScoringEventTimerEnd</td>
      <td>DangerRoomTimerEnd</td>
    </tr>
    <tr>
      <td>MetaStateScoringEventTimerStart</td>
      <td>DangerRoomTimerStart</td>
    </tr>
    <tr>
      <td>MetaStateScoringEventTimerStop</td>
      <td>DangerRoomTimerStop</td>
    </tr>
    <tr>
      <td>MetaStateShutdown</td>
      <td>DangerRoom</td>
    </tr>
    <tr>
      <td>MetaStateStartTargetOverride</td>
      <td>SurturStartTargetCaldera</td>
    </tr>
    <tr>
      <td>MetaStateTimedBonus</td>
      <td>AgeOfUltronTimedBonusPhase01</td>
    </tr>
    <tr>
      <td>MetaStateTrackRegionScore</td>
      <td>DangerRoom, AgeOfUltron</td>
    </tr>
    <tr>
      <td>MetaStateWaveInstance</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>I had to implement the required modes and states to continue working on missions.</p>

<p>Many of these states contain populations that need to be spawned dynamically using <code class="language-plaintext highlighter-rouge">MetaStateSpawnEvent</code>. This is what we will be looking at next.</p>

<h3 id="spawnevent">SpawnEvent</h3>

<p>The old spawning system I was using became no longer suitable for current circumstances. I had to rework it, which involved creating the following classes:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SpawnEvent</code> (<code class="language-plaintext highlighter-rouge">PopulationAreaSpawnEvent</code>, <code class="language-plaintext highlighter-rouge">MissionSpawnEvent</code>, <code class="language-plaintext highlighter-rouge">MetaStateSpawnEvent</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SpawnScheduler</code> (<code class="language-plaintext highlighter-rouge">MarkerScheduler</code>, <code class="language-plaintext highlighter-rouge">LocationScheduler</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PopulationObjectQueue</code> (<code class="language-plaintext highlighter-rouge">CriticalQueue</code>, <code class="language-plaintext highlighter-rouge">RegularQueue</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SpawnLocation</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SpawnMap</code> (to be implemented)</p>
  </li>
</ul>

<p>All the information we need for spawning is contained in <code class="language-plaintext highlighter-rouge">PopulationObject</code>, but it needs to be retrieved and processed correctly. Previously I did this manually, which is why everything was static. However, the game requires dynamic spawning.</p>

<p>Here is how it’s done. First, the <code class="language-plaintext highlighter-rouge">SpawnEvent</code> type is determined, which then processes our population by getting all <code class="language-plaintext highlighter-rouge">PopulationObject</code> instances from it. Objects are divided based on their properties by how <em>critical</em> they are for spawning and how <em>tied</em> they are to a location. Critical objects are spawned first, and while we have even a single critical object for a marker, none of the non-critical objects should be spawning (this caused a lot of issues with missions). If there is a <code class="language-plaintext highlighter-rouge">UsePopulationMarker</code> marker, the object is forwarded to a <code class="language-plaintext highlighter-rouge">MarkerScheduler</code>, otherwise it goes to a <code class="language-plaintext highlighter-rouge">LocationScheduler</code>.</p>

<p>First, we check if the region has a free marker using <code class="language-plaintext highlighter-rouge">SpawnMarkerRegistry</code>, and if it matches our <code class="language-plaintext highlighter-rouge">SpawnLocation</code>, this marker becomes reserved, and our object spawns on it. The number of markers in a region is limited, which causes problems, because the spawn queue is very large. To solve this issue, I have implemented two classes: <code class="language-plaintext highlighter-rouge">PopulationObjectQueue</code> and <code class="language-plaintext highlighter-rouge">SpawnScheduler</code>. They manage the queue and keep everything in order, preventing missions from breaking.</p>

<p>When all <code class="language-plaintext highlighter-rouge">SpawnEvent</code> objects are spawned, the <code class="language-plaintext highlighter-rouge">OnSpawnedPopulation</code> event is invoked, which activates the mission. If the marker is occupied, the required mission objects fail to spawn, and the mission does not activate.</p>

<p>This chart demonstrates how spawning is planned:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-09/missions-15.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-09/missions-15.png" alt="Spawn Queue Chart" /></a></p>

<h3 id="conclusion">Conclusion</h3>

<p>As you can see, missions are a very complex system of interconnections, states, conditions, and events. This makes it difficult to find the reason something breaks and understand it. Although I was able to fix the most glaring issues, and right now it is possible to finish all 10 chapters of the story, there is still a lot of work to do, including debugging internal missions, MetaState, widgets, animations, rewards, SpawnMap, and so on.</p>

<p>Thank you to everybody who is helping me debug missions, and until we meet again in future reports!</p>

<hr />

<p>This was a huge one! Thanks to everyone who read (or just scrolled) all the way to the end, see you all next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: August 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/08/31/progress-report-august-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: August 2024" /><published>2024-08-31T15:30:00+03:00</published><updated>2024-08-31T15:30:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/08/31/progress-report-august-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/08/31/progress-report-august-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-08/header.jpg" alt="MHServerEmu Progress Report - August 2024" /></p>

<p>The development of MHServerEmu keeps chugging along.</p>

<h2 id="back-to-basics">Back to Basics</h2>

<p><a href="/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html">After getting sidetracked with implementing some of the more “flashy” features in July</a>, such as powers and loot tables, it was time for me to go back and continue some of the backend work I started back in June.</p>

<p>While our area of interest (AOI) implementation did work, it still relied on some of our earliest code from July-August 2023 when we were just starting getting the hang of things. For instance, the code that would put players into regions was a mess of hardcoded hacks, resulting in limitations such as not being able to teleport outside of a client’s area of interest without completely exiting and reentering the region. Combined with the lack of persistence, this resulted in, for example, your data being reset when you would transition between floors of tower regions, and it also made resurrecting avatars at checkpoints very hard to do, which we had to circumvent by doing resurrections on the spot. After painstakingly going through the old code and refactoring various things, those limitations are now gone, which you can see in current nightly builds of the server.</p>

<p>Another set of issues that had to be dealt with was how AOIs were interacting with the environment (areas and cells). When there are no players around world entities, like enemies and NPCs, most of them stop being <em>simulated</em>, meaning their AI turns off and they no longer become interactable for systems like powers. The problem was with how we determined when a player was “nearby”: we reused the same proximity volume around the active avatar we use for periodic entity scans, and turned simulation on or off based on whether an entity was replicated to a client. This caused frequent simulation switching and made enemies “forget” about players at relatively small distances, especially in larger cells, like the one used in Holo-Sim, where the whole region is just one big cell. So we switched to doing simulation updates per cell instead of per individual entity: if a cell is visible to any player, all world entites in it will now be simulated, making the whole experience more consistent.</p>

<p>Here is a diagram to better illustrate what was happening:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-08/aoi.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-08/aoi.png" alt="AOI Simulation Range" /></a></p>

<p>In this example the player’s AOI proximity volume (indicated in green) intersects cells 1, 2, 4, and 5, so those are the cells that are loaded client-side. Cells 0 and 3 are too far away, so the client is not made aware of them by the server, making them not exist from the client’s point of view. There are enemies (indicated in red) in all cells, however, only some of them intersect the player’s AOI volume. Previously, only the enemies in the volume would be simulated, while the stragglers would get turned off. Now, all enemies in all loaded cells (1, 2, 4, and 5) will continue to be simulated even if they are slightly outside the player’s AOI, allowing them to, for example, pursue the player more effectively. Meanwhile, enemies in faraway cells (0 and 3) will still be turned off.</p>

<p>In addition to that, the order of operations when updating proximity was also off. We were doing all entity updates at the same time, and there were cases when messages were being sent out of order, making the client try to put entities into environments that did not exist client-side, or deleting environments that still had entities in them. The whole entity processing queue had to be split into two, with entity removal happening before environment updates, and creation after, when areas and cells were ready. However, there is a catch: an entity can continue to exist client-side even if it is no longer in proximity (through ownership, discovery, or party channels), allowing its map icon to continue being displayed. In this case though, it is removed from the game world client-side when the environment for it stops existing due to no longer being in proximity. For this reason when we separate entity updates into pre-environment and post-environment we also have to take into account entities that gain or lose the proximity policy, with the former needing to be replicated after the environment, and the latter before.</p>

<p>Finally, one annoying thing that had to be fixed was how the current avatar could occasionally get outside of its own proximity when moving fast, causing it to disappear. The reason for this is that avatar movement in this game is mostly client-authoritative, with the server predicting client movement most of the time and only correcting when things get completely out of hand. We had our proximity update trigger tied to locomotion updates arriving from the client, but due to how the locomotion system works, an avatar can move pretty far without sending any updates as long as the movement is predictable, and this caused the aformentioned issues at high speed predictable movements. The obvious fix was to make proximity updates trigger more frequently based on server-side predictions at a given time, which is what we did. If you still see this issue, please be sure to report it!</p>

<p>While these little problems may not seem as important as a whole new gameplay system, like powers or AI, they are the blood vessels that allow everything else to happen, and some of them can be quite tricky to fix without breaking anything, taking a significant amount of time in the process. But with another round of those done, we can go back to more exciting matters.</p>

<h2 id="persistent-perfection">Persistent Perfection</h2>

<p>In September we plan to release our next stable version, 0.3.0, which is going to include most of the progress we were able to achieve over the course of this summer. Releasing a stable version is a moment when we are able to get feedback from some of the less engaged and technically savvy users, and when we released 0.2.0 I went through the feedback and identified two key features that I wanted to implement for the next release: powers doing damage when you hold the button down, and your loot being saved when you transfer to another region or logout (also known as persistence). With the former goal being overachieved if I do say so myself, it was now time to spend the remaining time on preserving your loot.</p>

<p><a href="/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html">In April we talked about the game’s serialization system and the various modes it has.</a> Back then we focused on replication, which is the process synchronizing server game state with clients, but the system also supports a database serialization mode used for persistent storage. And since it’s just another mode for the same system that reuses a lot of the same serialization routines, most of it is actually contained in the client. We could in theory implement some kind of custom serialization solution, but since we already had most of it implemented for replication, it made sense to just expand it a little.</p>

<p>One key difference between database and replication serialization is how data references are stored. For example, <a href="/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html">in February we went over various tricks the game uses for efficiently encoding properties</a>, and as you might imagine, most of them are going to break with a changing game data set. While in runtime the game can rely on sorted file path hashes and their indexes, for cross-version compatibility needed in persistent storage the game references data using 64-bit GUIDs that remain valid even if a data file is moved, renamed, or replaced. We cannot say for sure how those GUIDs were generated, but there does not appear to be any noticable pattern, indicating that they may be hashes of some internal identifiers not exposed in the client. Properties specifically also required reimplementation of a separate <code class="language-plaintext highlighter-rouge">PropertyStore</code> structure used to break up property parameters into independent data references that are serialized as their own values, rather than being embedded in the id. Some data that can be derived from other data is also omitted to reduce file sizes. For example, power collections that contain available powers can be restored from the game database by knowing an avatar’s prototype and character level, so they do not need to be serialized.</p>

<p>One potentially neat side effect of using the original serialization implementation is that it was designed with backward compatibility in mind. In theory this should make it easier to bring data from an older version of the game into a newer one, provided we implement versioning routines for game versions we want to support. This is going to make it easier to implement progression servers that would go through versions of the game over a span of time, as seen in other legacy online games, although it remains to be seen how well this concept suits Marvel Heroes in particular.</p>

<p>What this serialization process gives us is <a href="https://en.wikipedia.org/wiki/Object_storage">blobs</a> of serialized entity data that we need to store somehow. This is one of the rarer times in this project when we have the freedom to be creative and come up with our own solutions rather than trying to fit into an existing system dictated by the client.</p>

<p>For me personally, it is very important for MHServerEmu to remain self-contained and have it be as easy as a mod to set up and run, if someone just wants to play offline single player on their own machine. For this reason we are using SQLite as our default storage backend: it is embedded into the server and does not require separate setup, while also being very reliable and flexible enough to serve our needs. Depending on how many people play on a single server and how much writing load there is going to be, it may also be the only thing we are ever going to need. But there is also some room for additional flexibility via dependency injection: interaction with the database happens via an interface called <code class="language-plaintext highlighter-rouge">IDBManager</code> that is implemented by the <code class="language-plaintext highlighter-rouge">SQLiteDBManager</code> class. An instance of <code class="language-plaintext highlighter-rouge">SQLiteDBManager</code> is injected into the <code class="language-plaintext highlighter-rouge">AccountManager</code> during server initialization, and it can be replaced with another implementation that uses a different backend. Right now we also have another implementation called <code class="language-plaintext highlighter-rouge">JsonDBManager</code> that wraps JSON serialization in the database API, allowing you to essentially have a save file, like you would in a single player game, without changing the overall system. Similarly, it should be possible to implement a more powerful solution, such as PostgreSQL or MySQL, if the need ever arises.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-08/db-manager.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-08/db-manager.png" alt="Dependency Injection Using IDBManager" /></a></p>

<p>With great power comes great responsibility, and as we store more and more data we need to make the persistency layer more robust. While some data corruption and/or wipes are inevitable while the server is still in earlier stages of development, we understand how important your stuff is in a loot progression game like this, so we would like to keep them to a minimum. For this purpose we are implementing a number of features that are going to be coming with this persistency update:</p>

<ul>
  <li>
    <p>The server will now automatically create backups of the database file. If something goes wrong with your primary file, you may have a backup in place to fall back to. By default the server creates up to 5 backups with an interval of at least 15 minutes between them, but this is configurable.</p>
  </li>
  <li>
    <p>The server will now create a new database file if one is not present in the <code class="language-plaintext highlighter-rouge">Data</code> folder, and it will no longer come with one. This means when you update to a recent nightly build or stable release, you can safely overwrite all files without having to back up <code class="language-plaintext highlighter-rouge">Account.db</code>.</p>
  </li>
  <li>
    <p>There is a new automated migration system that will upgrade your existing database file if there are any schema changes, such as columns or tables being added or removed.</p>
  </li>
</ul>

<p>As of writing this, we have most of the IO matters sorted out, but some of the game logic still needs more work to be able to properly handle entities actually persisting. For example, we had to hardcode your character level to 60 because this information did not persist on region transfers and log outs, and you would be getting reset to level 1 all the time even if we had leveling implemented. But, if we roll persistence out in the current state, everyone would get saved as level 60 because of this workaround, and when we would eventually implement leveling we would have to force a wipe of all progress to allow everyone to start from level 1. Other examples include stash tab unlocks, selected team-ups, and more. Once those are dealt with, which should not take too long, we are going to be ready to release 0.3.0.</p>

<h2 id="the-road-ahead">The Road Ahead</h2>

<p>As we wrap things up with 0.3.0, we begin looking towards what is ahead of us. So far we have been hitting our target stable release cadence of once every three months, and we plan to continue doing so. Recently <a href="https://github.com/users/Crypto137/projects/5/views/1">we have published a rough roadmap of features we plan for upcoming stable releases</a>: while plans change and specific features will most likely shift around as we get further along, it should give you a broad overview of the current outlook.</p>

<p>One large new feature that is most likely going to be ready for 0.4.0 is the mission system, and AlexBond has already spent the better part of August working on it. It is a very complex system that involves dozens of missions conditions, such as <code class="language-plaintext highlighter-rouge">MissionConditionEntityDeath</code> and<code class="language-plaintext highlighter-rouge">MissionConditionItemCollect</code>, that trigger various actions, like <code class="language-plaintext highlighter-rouge">MissionActionEntityPerformPower</code>, and <code class="language-plaintext highlighter-rouge">MissionActionShowMotionComic</code>. The mission system makes use of numerous other gameplay systems, and it is tightly coupled with the spawning system that needed a major overhaul. We will go into more detail on this in one of the future reports.</p>

<p>We are also planning to continue working on itemization pretty soon. The current implementation allows us to pick mostly accurate base types and qualities, but equipment currently has no affixes, which is something we have been holding back on implementing due to not having persistence working. We would not want anyone to feel the pain of getting an amazing drop, knowing that it is going to be lost forever as soon as you go back to hub.</p>

<p>In general, with most of the backend now being in a reasonably decent state, the focus will continue shifting towards in-game systems that are more clearly visible when playing the game.</p>

<hr />

<p>Time for us to get back to work. Until the next report!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: July 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: July 2024" /><published>2024-07-31T22:30:00+03:00</published><updated>2024-07-31T22:30:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/07/31/progress-report-july-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-07/header.jpg" alt="MHServerEmu Progress Report - July 2024" /></p>

<p>We have a lot of exciting updates to share. It has been one year since this project started, and this month <em>combat</em> has returned to Marvel Heroes, which I would dare to call our biggest leap forward since we first got in-game in July 2023.</p>

<h2 id="you-got-the-power">You Got the Power</h2>

<p>We have laid the foundation for one of the most important and complex systems of Marvel Heroes - <em>powers</em>. From a certain perspective, it would not be an exaggeration to call it <em>the</em> most complex system in the entire game because of its deep interconnection with other systems and just the sheer amount of stuff it involves. Covering all of it is outside the scope of a single report, but I will give a brief overview of the work that has been done so far and what is left to do.</p>

<p>One important thing to note is that prior to this month we barely had any power-related functionality implemented server-side. The fact that you could “use” a lot of powers before was just the magic of client-side prediction, and the server was almost completely unaware of what was actually happening.</p>

<p>So where do we even begin? First of all, there are many different kinds of powers. Powers are classified by categories: <code class="language-plaintext highlighter-rouge">NormalPower</code>, <code class="language-plaintext highlighter-rouge">ComboEffect</code>, <code class="language-plaintext highlighter-rouge">EmotePower</code>, <code class="language-plaintext highlighter-rouge">GameFunctionPower</code>, <code class="language-plaintext highlighter-rouge">HiddenPassivePower</code>, <code class="language-plaintext highlighter-rouge">HotspotEffect</code>, <code class="language-plaintext highlighter-rouge">ItemPower</code>, <code class="language-plaintext highlighter-rouge">MissileEffect</code>, <code class="language-plaintext highlighter-rouge">ProcEffect</code>, <code class="language-plaintext highlighter-rouge">ThrowablePower</code>, and <code class="language-plaintext highlighter-rouge">ThrowableCancelPower</code>. Powers can have various targeting shapes: <code class="language-plaintext highlighter-rouge">ArcArea</code>, <code class="language-plaintext highlighter-rouge">BeamSweep</code>, <code class="language-plaintext highlighter-rouge">CapsuleArea</code>, <code class="language-plaintext highlighter-rouge">CircleArea</code>, <code class="language-plaintext highlighter-rouge">RingArea</code>, <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">TeamUp</code>, <code class="language-plaintext highlighter-rouge">SingleTarget</code>, <code class="language-plaintext highlighter-rouge">SingleTargetOwner</code>, <code class="language-plaintext highlighter-rouge">SingleTargetRandom</code>, <code class="language-plaintext highlighter-rouge">SkillShot</code>, <code class="language-plaintext highlighter-rouge">SkillShotAlongGround</code>, or <code class="language-plaintext highlighter-rouge">Wedge</code>. A power’s targeting style can have various flags applied to it, such as <code class="language-plaintext highlighter-rouge">AOESelfCentered</code>, <code class="language-plaintext highlighter-rouge">NeedsTarget</code>, <code class="language-plaintext highlighter-rouge">TurnsToFaceTarget</code>, <code class="language-plaintext highlighter-rouge">AlwaysTargetMousePos</code>, and more. This list can continue on and on, but the point is that there is <em>a lot</em> of factors to consider here, which is why our reimplementation of the <code class="language-plaintext highlighter-rouge">Power</code> class is already at over 6000 lines of code, and it continues to grow.</p>

<p>But all of that is just static data defined by game designers, and powers are dynamic beasts that live in runtime. Before a power can be used it needs to be <em>assigned</em> to a world entity’s <code class="language-plaintext highlighter-rouge">PowerCollection</code>. The assignment process includes the creation of an instance of the <code class="language-plaintext highlighter-rouge">Power</code> class that is in many ways not unlike an entity: it has its own <code class="language-plaintext highlighter-rouge">PropertyCollection</code>, as well as various other pieces of state. When a power is assigned it gets passed a set of information used for scaling referred to as <em>power index properties</em>: power rank, character level, combat level, item level, and item variation. This is one of the places where we can see that BUE was not as thorough as it may appear: although the update “removed” power ranks, they still exist internally, with most powers instead being set to rank 0 or 1 and rebalanced accordingly.</p>

<p>With the power assigned and initialized it can now be used. Every time you use a power it goes through a pipeline consisting of four main stages:</p>

<ul>
  <li>
    <p><strong>Activation</strong>: this is when the game checks if you can use the power (you have enough resources, your target is valid if the power needs one, etc.), starts the animation, and schedules a <em>power application</em> for when the contact frame is supposed to happen. Although the server does not actually play animations, it still needs to know how long they are, taking into account variables such as attack speed modifiers. In many cases it is possible to cancel activation before the animation reaches its contact frame.</p>
  </li>
  <li>
    <p><strong>Power Application</strong>: at the contact frame of the animation we reach the point of no return, which is when the power can actually begin doing something. At this moment the properties of the power and its owner are snapshotted and recorded into an instance of the <code class="language-plaintext highlighter-rouge">PowerPayload</code> class. Depending on the power, this payload may either get processed as soon as it is created, or it can be scheduled to be processed later. At the time of writing we do not have delayed processing implemented yet, which is why, for example, throwable objects deal damage instantly rather than when they actually reach their target destination. The correct way of doing this involves calculating the time the throwable object is going to spend in the air and delaying the processing of the payload by that time.</p>
  </li>
  <li>
    <p><strong>Payload Processing</strong>: this is where the fun begins. The snapshot of the power and its owner recorded in the payload is processed, and the <em>results</em> are calculated, which include damage, healing, and conditions (buffs and/or debuffs) that need to be applied to the target. Depending on the calculations, various result flags may be set, such as critical strike and dodge.</p>
  </li>
  <li>
    <p><strong>Application of Results</strong>: the results of the payload calculations are applied to the target. This involves adjusting the health of the target, potentially killing it, and applying conditions to it. Clients also get sent a copy of the results to display damage numbers and additional hit visual effects.</p>
  </li>
</ul>

<p>At various points in this process additional <em>power events</em> may get triggered. In total there are 30 event types that can trigger 36 types of actions. Some of these actions are very specific, like <code class="language-plaintext highlighter-rouge">BodySlide</code>, <code class="language-plaintext highlighter-rouge">SwitchAvatar</code>, and <code class="language-plaintext highlighter-rouge">PetItemDonate</code>, but others are more general purpose, such as <code class="language-plaintext highlighter-rouge">UsePower</code>, <code class="language-plaintext highlighter-rouge">EndPower</code>, and <code class="language-plaintext highlighter-rouge">CooldownStart</code>. One of the most common use cases for power events is the activation of <em>combo powers</em>: when a power needs to do more than one thing, like moving your character and dealing AoE damage around your destination, this is usually achieved by having two different powers, with one triggering the other as a combo.</p>

<p>While all kinds of entities can use powers, avatars are a very special case, because they are controlled by players connected remotely. One example of special treatment in this regard is the concept of <em>continuous powers</em>. You may recall how in our earlier iteration of “combat” that you can still see in stable builds most powers would deal damage only on the initial activation, with no effect if you held the button down or pressed it frequently enough. The reason for this is that the game classifies a lot of powers as continuous based on various criteria, such as animation length, category, override flags, and more. If a power is continuous, activations after the initial one are not communicated between the client and server: the server just assumes the client is still holding the button down and continuously reactivates it until it receives a cancellation message. This requires the server to be able to run the entire power activation process on its own in parallel to the client, which was not possible previously with hacks, but can now be done.</p>

<p>Another example of avatar-specific behavior is the priority queue system. The basic idea of it is that if a player input cannot be acted on immediately because another power is already being used, this input is put into a very small queue with a size of one or two commands. If there is a new command that is different from the rest of commands that have been issued recently, such as when you try to activate a defensive power inbetween spamming regular attacks, this different command takes priority so it doesn’t get lost. This system works almost exactly the same as, for example, Diablo III, and if you are interested in this topic I strongly recommend watching the talk <a href="https://gdcvault.com/play/1017794/Through-the-Grinder-Refining-Diablo">Through the Grinder: Refining Diablo III’s Game Systems by Wyatt Cheng</a>. Not only will you learn interesting stuff, you will also discover Wyatt’s origin story before he became infamously known as the “do you guys not have phones” guy. Currently we do not have command queueing implemented server side, which is why some of your inputs may occasionally get lost in the heat of battle, especially with higher latency.</p>

<p>So far we have implemented a lot of the foundation, which allows most powers that deal direct damage to enemies to function, but there is still a lot of work left to do, including:</p>

<ul>
  <li>
    <p>Various additional aspects of payload processing, including taking the target’s defensive properties into account, paying resource costs, and more. The current implementation is a very simplified one based on formulas the client uses to calculate tooltip damage.</p>
  </li>
  <li>
    <p>Hidden damage scaling mechanics: dynamic combat level (DCL) and scaling player damage output based on the total number of players in proximity.</p>
  </li>
  <li>
    <p>Implementations for the rest of power event triggers and actions.</p>
  </li>
  <li>
    <p>Avatar power activation priority queue.</p>
  </li>
  <li>
    <p>Condition (buff and debuff) application and removal, including those that deal damage over time (DoTs).</p>
  </li>
  <li>
    <p>Hotspot powers. Hotspots are zones that apply certain effects when entities stand in them, such as fire that deals damage when you stand in it.</p>
  </li>
  <li>
    <p>Procs.</p>
  </li>
  <li>
    <p>Summon powers.</p>
  </li>
</ul>

<p>For now though we have enough of this system working to have the game feel like a real game again, especially when combined with the AI implementation by AlexBond.</p>

<h2 id="loot-tables-for-dummies">Loot Tables for Dummies</h2>

<p>While it is nice to be able to smash things and beat bad guys, the core thing that makes you do it again and again in games like these is the loot. Although we did have a placeholder system put in place last month, I felt this aspect started falling behind, especially with how authentic the rest of the game is now looking.</p>

<p>We are extremely lucky to have all the original loot tables in the client. The underlying loot system is very complex, but this month I have made significant progress in untangling it. Although items still lack affixes and stats, their rarities and base types should now be accurate, making the lootsplosions from defeating bosses way more satisfying. So how does it all work?</p>

<p>Although they are called loot “tables”, they are actually tree structures consisting of <code class="language-plaintext highlighter-rouge">LootNodePrototype</code> instances. Each node can be either a <code class="language-plaintext highlighter-rouge">LootTablePrototype</code> or a <code class="language-plaintext highlighter-rouge">LootDropPrototype</code>. Here is what a typical “loot table” looks like:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/loot-table.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/loot-table.png" alt="Loot Tables" /></a></p>

<p>When you want to use a loot table, you recursively iterate through the nodes of this tree, with each “table” representing a branch and “drops” representing end points that get recorded (more on that later). Visiting a node is referred to as <em>selecting</em> it, and activating the node is called <em>rolling</em>.</p>

<p>When you select a loot table node, it gets rolled one or more times, with each roll determining branches to go down to. When rolling loot tables the game uses the concept of <em>nodrop</em> similar to <em>Diablo II</em>: rather than specifying the drop chance of something, instead each table node has a <em>nodrop chance</em> defined that determines whether or not the table will be skipped entirely. So a 1% drop chance is represented as a 99% nodrop chance. If the roll passes this nodrop chance check, branches of the table are picked using one of three methods:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickWeight</code>: picks one of the branch nodes randomly based on their defined weight.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickWeightTryAll</code>: excludes branch nodes randomly based on their weight until only one remains, which gets picked.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PickAll</code>: picks all branch nodes.</p>
  </li>
</ul>

<p>Picked nodes are selected and rolled, and this process continues recursively until it reaches a loot drop node.</p>

<p>In total there are 17 different types of loot drop nodes representing various things that can “drop”. The most obvious and widely-used one is <code class="language-plaintext highlighter-rouge">LootDropItemPrototype</code> that represents an item dropping. There is also <code class="language-plaintext highlighter-rouge">LootDropAgentPrototype</code> used for spawning entities, like health and experience orbs, that are actually implemented as AI-controlled agent entities rather than items. But just like it was with inventories, the definition of a “drop” is quite broad here: there are drop nodes such as <code class="language-plaintext highlighter-rouge">LootDropPlayVisualEffectPrototype</code>, <code class="language-plaintext highlighter-rouge">LootDropChatMessagePrototype</code>, and <code class="language-plaintext highlighter-rouge">LootDropBannerMessagePrototype</code> that are more like actions triggered by rolling rather than representations of physical things that you can pick up.</p>

<p>As you navigate a loot tree and reach various drop nodes, you need to record your journey to make use of it later. For this the game uses an abstract <code class="language-plaintext highlighter-rouge">IItemResolver</code> interface class the gets implemented by various systems that need to interact with loot tables. Successfully rolled drop nodes are “pushed” onto the resolver, and the accumulated data from the resolver is then used to spawn rolled items in the world, add them to an inventory, or just output the results as text for testing.</p>

<p>One last essential piece of the loot table puzzle are <em>loot roll modifiers</em>. When you interact with a loot table tree you also pass to it an instance of <code class="language-plaintext highlighter-rouge">LootRollSettings</code> that contains the context, from obvious things, such as level and difficulty tier, to more esoteric factors, such as the current day of the week. Each node in the tree can then have modifiers that process and/or override these settings. One of the simplest examples would be filtering drops based on level range. But you can also, for instance, override the current avatar and always drop items for somebody else. Or you could have the rare item find stat apply to an arbitrary selection of items. When modifiers are applied to a drop node they affect only that drop node, but when they are applied to a table node, the affect all branches of that table. This is how, for example, eternity splinters drops are controlled: splinters have their own branches in common loot tables with applied modifiers.</p>

<p>And with all of that we have basic loot table rolling working. We still have work to do, including implementing all the special drop types, additional modifiers, and some more drop processing, such as taking item quality bonuses into account and applying affixes to items, but the foundation is now in place. If only we could have our loot persist when we transfer between regions and log out…</p>

<h2 id="the-barrel-made-me-do-it">The Barrel Made Me Do It</h2>

<p><em>AlexBond is back yet again this month to talk about AI profile overriding.</em></p>

<hr />

<p>Hey everyone, this is AlexBond. Let the combat begin! In this report I would like to share how I enabled AI and brought all the enemies in the game to life.</p>

<p>This month there were a lot of major updates: enemies and bosses now attack and deal damage, and the game is really starting to come to live. But let’s talk about how it all works.</p>

<p>Enemy movement uses the <code class="language-plaintext highlighter-rouge">AIController</code> class that I already covered in previous reports. This time I would I would like to talk about <code class="language-plaintext highlighter-rouge">AIOverride</code> and how it is used.</p>

<h3 id="ai-override">AI Override</h3>

<p>An agent’s prototype generally specifies its AI profile that defines its behavior. All attack-based AI profiles (<code class="language-plaintext highlighter-rouge">ProceduralProfileWithAttackPrototype</code>) function in two modes:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DefaultSensory</code> - scanning mode (based on <code class="language-plaintext highlighter-rouge">BehaviorSensorySystem</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">HandleContext</code> - action mode</p>
  </li>
</ul>

<p>Scanning involves searching for a target. If no target is found using <code class="language-plaintext highlighter-rouge">SelectTargetEntity()</code>, the AI profile is overriden with a <code class="language-plaintext highlighter-rouge">NoTargetOverrideProfile</code>. Usually it is <code class="language-plaintext highlighter-rouge">ProceduralProfileDefaultActiveOverridePrototype</code> that makes the agent wander around (<code class="language-plaintext highlighter-rouge">WanderInPlace</code>) or return to its spawn location (<code class="language-plaintext highlighter-rouge">Wander</code>). While doing so it continues scanning its surroundings, and if it finds an enemy, it switches to the attack profile.</p>

<p>But it gets more complicated. Enemies created via a <code class="language-plaintext highlighter-rouge">PopulationObject</code> contain an <code class="language-plaintext highlighter-rouge">EntitySelector</code>, which has another AI override called <code class="language-plaintext highlighter-rouge">DefaultBrainOnSimulated</code> that uses <code class="language-plaintext highlighter-rouge">ProceduralProfileSenseOnly</code></p>

<p>The basic idea of this profile is that instead of wandering or attacking, it simply plays an idle animation (such as NPCs talking to each other), and when a player enters its scanning radius, it switches to one of the talking profiles. Generally it picks a random profile from the <code class="language-plaintext highlighter-rouge">AIOverrides</code> list:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-1.png" alt="AI 1" style="max-height: 400px;" /></a>
</center>

<p>All of these switches are controlled by the <code class="language-plaintext highlighter-rouge">ProcessEntityAction()</code> function.</p>

<p>So when you see an NPC talking or calling you, this happens via complex AI profile switching.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-2.jpg" alt="AI 2" style="max-height: 400px;" /></a>
</center>

<p>This is how previously silent NPCs learned how to speak.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-3.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-3.jpg" alt="AI 3" /></a></p>

<p>As for combat, Crypto did a lot of work here by implementing the power system. I assisted with implementing <code class="language-plaintext highlighter-rouge">MissilePower</code>, since it involves AI, and I am quite familiar with this topic.</p>

<p>This game has so many AI profiles, and it is hard to see them at first glance. For example, drops lying on the ground, such as orbs, are not pulled by some kind of magnetic force. Instead, they all have follow target AI profiles, with your avatar being that target. Every moving entity in the game is “alive”. This includes projectiles, such as Captain America’s shield, Thor’s hammer, or Iron Man’s micro-missiles - all of them are moved using AI profiles. But it gets more interesting!</p>

<p>You may remember bosses or other powerful enemies picking objects up and throwing them at you. You think this is because the boss’s AI is so smart? Wrong answer! Actually, throwable objects themselves have brains!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-4.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-4.jpg" alt="AI 4" /></a></p>

<p>Yes, I am not joking, every single one of Mr. Hyde’s barrels has its own brain!</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-07/ai-5.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-07/ai-5.png" alt="AI 5" style="max-height: 400px;" /></a>
</center>

<p>Every 10 seconds the barrel, just like Emma Frost, attempts to take control of its owner, Mr. Hyde, and override his AI behavior profile. And the boss takes orders from this barrel, picks it up, and throws it at the avatar. Entities that act like this have their own class - <code class="language-plaintext highlighter-rouge">ThrowableSmartProp</code>.</p>

<p>There are not too many of them in the game, and they still do not function completely right, but now you know that when the Hulk boss in Holo-Sim picks up a car, he was forced to do so by the car itself!</p>

<p>Overriding AI profiles is a complicated process, and I am still working on it. For instance, timing the activation of the appropriate AI profile when an entity enters the world and/or starts being simulated still has a lot issues, which is why some of the idle animations got replaced with wandering. In the future we will come back and fix these issues. For now I am working on missions, which also involves some AI overriding and idle animation playaback via <code class="language-plaintext highlighter-rouge">MissionActionEntityPerformPower()</code>, but this is a story for another report. That’s it for now, have fun playing, and until the next report!</p>

<hr />

<p>Back to work now. See you in August!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: June 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: June 2024" /><published>2024-06-30T04:20:00+03:00</published><updated>2024-06-30T04:20:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/06/30/progress-report-june-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-06/header.jpg" alt="MHServerEmu Progress Report - June 2024" /></p>

<p>June has been jam-packed full of developments, and we have a lot to cover.</p>

<h2 id="mhserveremu-2-electric-boogaloo">MHServerEmu 2: Electric Boogaloo</h2>

<p>This month we released the second stable release of MHServerEmu - <a href="https://github.com/Crypto137/MHServerEmu/releases/tag/0.2.0">version 0.2.0</a>. This release contains all the backend work we had been working on since <a href="/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html">March</a>, including, but not limited to:</p>

<ul>
  <li>
    <p>General server architecture improvements.</p>
  </li>
  <li>
    <p>An overhaul of the serialization system.</p>
  </li>
  <li>
    <p>An implementation of navi, locomotion, and physics systems.</p>
  </li>
  <li>
    <p>An overhaul of the entity management system.</p>
  </li>
  <li>
    <p>An implementation of the inventory system.</p>
  </li>
  <li>
    <p>An implementation of the game event system.</p>
  </li>
  <li>
    <p>A significantly upgraded version of the area of interest system.</p>
  </li>
  <li>
    <p>Most of the backend for the AI system.</p>
  </li>
</ul>

<p>We have barely scratched the surface of what is now possible. One significant improvement that happened almost as a side effect of all of this is that now you can see and interact with other players in the game world.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/multiplayer.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/multiplayer.jpg" alt="Multiplayer" /></a></p>

<p>And in just a few days we were able to build a very rough early iteration of the loot system (<em>disclaimer: quantity exaggerated for dramatic purposes, may not match what you see in the final product</em>):</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/loot.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/loot.jpg" alt="Loot" /></a></p>

<p>As soon as 0.2.0 was out, we started work on version 0.3.0. Our current tentative target for its release is September 2024, but you can check out all the latest features we are working on early via <a href="https://nightly.link/Crypto137/MHServerEmu/workflows/nightly-release-windows-x64/master?preview">nightly builds</a> or by building the source code yourself. Now that a significant bulk of the backend work is out of the way, we can focus more on aspects you can actually see in the game. One good example of this you can check out yourself right now in nightly 0.3.0 builds is an early iteration of pets and team-ups that rely on navi, locomotion and AI systems for pathfinding, physically moving around, and being aware that they need to follow their owner respectively.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pets.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pets.jpg" alt="Pets" /></a></p>

<h2 id="i-am-running-out-of-interesting-puns">I Am Running Out of Interesting Puns</h2>

<p>This month our implementation of the area of interest (AOI) system received a major upgrade, which literally made visible the results of our work on other systems. Now that it is mostly working, we can dive deeper into the specifics.</p>

<p>First, a quick recap. Marvel Heroes is a server-authoritative game, meaning the entire game simulation (where everything is, what powers everyone is using, how much health everyone has, and so on) runs on the server. The server is the ultimate dungeon master, aware of everything happening to everyone. The client program you are using to play the game also has a simulation of its own that runs in parallel based on the data it receives from the server. However, the data clients receive is just a small slice of the overall server pie, and each client’s slice if referred to as its area of interest.</p>

<p>Putting it into more concrete terms, the <code class="language-plaintext highlighter-rouge">AreaOfInterest</code> class in the server code determines what data needs to go to the client it is bound to and keeps track of things the client is already aware of. The data managed by AOI can be separated into two categories: environment (a region with its areas and cells) and entities (game objects that populate the region).</p>

<p>Everything starts with entities. When a client logs into a game server, a <code class="language-plaintext highlighter-rouge">Player</code> entity is created for it that gets bound to an <code class="language-plaintext highlighter-rouge">AreaOfInterest</code> instance. This entity does not physically exist in the game world and is used to represent the player’s account: what heroes are unlocked, how much of each currency there is, when was the last time this player logged in, and so on. Hero and team-up unlocks are internally represented as “items” held in various hidden inventories, such as <code class="language-plaintext highlighter-rouge">PlayerAvatarLibrary</code> and <code class="language-plaintext highlighter-rouge">PlayerTeamUpLibrary</code> (see <a href="/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html">the previous report</a> for more on that).</p>

<p>This player entity is automatically <em>considered</em> by the area of interest it is bound to. Consideration is a process of determining what (if any) <em>interest policies</em> (also referred to as <em>replication channels</em>) a specific entity has in relation to an area of interest. If an area of interest determines that an entity matches one or more interest policies, it starts tracking the entity and notifies the client by sending network messages containing information about this entity. The client uses this information to create a copy of this entity in its local simulation. When an entity loses all of its replication policies, it is removed from the AOI and the client simulation. In addition to player entity creation, consideration can be triggered by other events, such moving around the game world, but more on that later.</p>

<p>In total there are five possible replication policies: <code class="language-plaintext highlighter-rouge">Owner</code>, <code class="language-plaintext highlighter-rouge">Proximity</code>, <code class="language-plaintext highlighter-rouge">Discovery</code>, <code class="language-plaintext highlighter-rouge">Party</code>, and <code class="language-plaintext highlighter-rouge">Trader</code>. When the player entity is considered by its AOI, it always enters it with the <code class="language-plaintext highlighter-rouge">Owner</code> policy. Then, the AOI recursively considers all entities stored in the player’s various inventories, which is how avatars and team-ups owned by the player with all of their equipment enter the AOI. Entities that enter the AOI by being present in the player entity’s inventories also have the <code class="language-plaintext highlighter-rouge">Owner</code> interest policy.</p>

<p>With this initialization step done, the server proceeds to put one of the player’s avatars at a specific <code class="language-plaintext highlighter-rouge">RegionLocation</code>, which includes a region instance id, coordinates within this region instance, and the initial orientation of the avatar. The AOI scans the environment within a certain radius around this location to determine what cells the client needs to load. The server then sends a message packet that instructs the client to put up a loading screen and load all determined cells. For every loaded cell the client sends a notification message to the server. The server tracks these notifications, and when all requested cells are loaded, it instructs the client to remove the loading screen, and player’s selected avatar enters the world at the required region location.</p>

<p>When the avatar enters world, it and everything within a certain radius is considered for a <code class="language-plaintext highlighter-rouge">Proximity</code> policy. Some entities do not get the <code class="language-plaintext highlighter-rouge">Proximity</code> policy despite being physically near the player’s avatar in the game world. One good example of this is loot, which is restricted to the player it dropped for until it is picked up. As the player’s avatar moves around the game world, the AOI periodically scans the proximity to determine cells and entities that need to be added or removed.</p>

<p>Here is what it looks like if we artificially reduce the proximity radius:</p>

<div><video controls="" width="100%" /><source src="/MHServerEmu/assets/blog/progress-report/2024-06/proximity.webm" type="video/webm" /></div>

<p>When entities in proximity are considered, the contents of their inventories are considered in a similar fashion to the player, and there is a set of conditions that determines when an entity stored in an inventory can enter an area of interest. This is what ultimately allows you to see items equipped on nearby players, such as their costumes and artifacts with fancy visual effects, while avoiding the necessity of loading items stored in their stashes like a certain other game.</p>

<p>In some cases when an entity enters proximity and/or satisfies some other condition, it also gains a <code class="language-plaintext highlighter-rouge">Discovery</code> policy, which allows it to remain in the client’s simulation even after it leaves proximity. For example, this is how the client can draw map icons for NPCs and waypoints even when they are no longer in proximity.</p>

<p>There are two special cases that have their own replication policies: <code class="language-plaintext highlighter-rouge">Party</code> and <code class="language-plaintext highlighter-rouge">Trade</code>. What makes them different from the other three is that they are the only cases when player entities belonging to other clients can enter your area of interest. We are still investigating the specifics of them, and we will talk more about this in a future report when we get to work on various social features.</p>

<p>Interest policies play an important role in the serialization process. For example, world entity power collections are omitted unless they have the <code class="language-plaintext highlighter-rouge">Proximity</code> policy, and some properties are added or removed based on changing policies. The latter one was the cause of one of the issues we had to solve when implementing team-up spawning. For some reason, the client failed to recognize team-ups as belonging to the current avatar and did not display a green circle indicator under them that should look like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/teamup.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/teamup.jpg" alt="Team-Up" /></a></p>

<p>As it turned out, the issue was that the property that the client uses to determine this ownership relation, <code class="language-plaintext highlighter-rouge">PowerUserOverrideID</code>, is compatible only with <code class="language-plaintext highlighter-rouge">Proximity</code> and <code class="language-plaintext highlighter-rouge">Trader</code> policies, and it is filtered out in other cases. Because team-ups are initially added to the AOI and serialized to the client with just the <code class="language-plaintext highlighter-rouge">Owner</code> policy during initial loading, this property was not included. The solution was to implement handling for the interest policy change event on the server to automatically send newly revealed properties to the client when existing entities in its AOI gain new interest policies.</p>

<p>While there is still some work to do on this system, at this stage it is already capable of performing its most essential operations that allows it to act as a window to what is happening on the server for the client.</p>

<h2 id="time-is-of-the-essence">Time is of the Essence</h2>

<p>Another important area where we have recently had significant advancements is game simulation timing and event scheduling. We first started seriously considering this <a href="/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html">back in April</a>, and are now at a point where we are approaching client-accuracy.</p>

<p>As we were researching this, we discovered an intricate system of numerous clocks that would fit right in at Dr. Emmett Brown’s lab.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/3isQI0nXQRE" frameborder="0" allowfullscreen=""></iframe></div>

<p>In total there are five clocks that are actively used, and we had to add a sixth one to the mix for compatibility with .NET.</p>

<ul>
  <li>
    <p><strong>.NET DateTime</strong> - a point in time from <code class="language-plaintext highlighter-rouge">January 1, 1</code> to <code class="language-plaintext highlighter-rouge">December 31, 9999</code>. This is the default date time format used by C# that you get from <code class="language-plaintext highlighter-rouge">DateTime.Now</code> and <code class="language-plaintext highlighter-rouge">DateTime.UtcNow</code>.</p>
  </li>
  <li>
    <p><strong>DateTime</strong> - the number of microseconds since <code class="language-plaintext highlighter-rouge">January 1, 1970</code>. Also known as Unix time.</p>
  </li>
  <li>
    <p><strong>CoreGameTime</strong> - the number of microseconds since <code class="language-plaintext highlighter-rouge">September 22, 2012 09:31:18 GMT+0000</code>. This epoch is not arbitrary: the game’s closed beta began on <code class="language-plaintext highlighter-rouge">October 1, 2012</code>, and this point in time must have been when the development team was making final preparations. In a way, this is the game’s true birthday.</p>
  </li>
  <li>
    <p><strong>RealGameTime</strong> - the number of microseconds in full fixed time frames since <code class="language-plaintext highlighter-rouge">September 22, 2012</code>. More on that later.</p>
  </li>
  <li>
    <p><strong>Game.CurrentTime</strong> - the current time step of the game simulation.</p>
  </li>
  <li>
    <p><strong>GameEventScheduler.CurrentTime</strong> - the current game simulation time adjusted for the currently executing scheduled event. This is the clock used by most of the gameplay logic. If <code class="language-plaintext highlighter-rouge">GameEventScheduler</code> is not available, it falls back to <code class="language-plaintext highlighter-rouge">Game.CurrentTime</code>.</p>
  </li>
</ul>

<p>Let’s unwrap what is happening here step by step.</p>

<p>During server initialization we query system time with <code class="language-plaintext highlighter-rouge">DateTime.UtcNow</code> to get a timestamp of the initialization time. For performance and accuracy reasons, rather than querying system time each time the game wants to know what time it is, we create and start a <code class="language-plaintext highlighter-rouge">Stopwatch</code> class instance when we query the initialization timestamp. When time is requested, we add elapsed time from the stopwatch to our timestamp and convert it to <code class="language-plaintext highlighter-rouge">DateTime</code> or <code class="language-plaintext highlighter-rouge">CoreGameTime</code>. With that we have half of our required clocks taken care of.</p>

<p><code class="language-plaintext highlighter-rouge">RealGameTime</code> is represented using a class called <code class="language-plaintext highlighter-rouge">FixedQuantumGameTime</code>. Behind this sci-fi sounding name we have basically a less accurate version of <code class="language-plaintext highlighter-rouge">CoreGameTime</code> that advances in fixed intervals, which in our case are 50 ms.</p>

<p>When the game does the <code class="language-plaintext highlighter-rouge">UpdateFixedTime()</code> stage of the update loop, which handles time-sensitive processing such as physics and timers, it synchronizes the value of <code class="language-plaintext highlighter-rouge">RealGameTime</code> by calling the <code class="language-plaintext highlighter-rouge">FixedQuantumGameTime.UpdateToNow()</code> method that does something along these lines:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get current CoreGameTime and time step length.</span>
<span class="n">TimeSpan</span> <span class="n">gameTime</span> <span class="p">=</span> <span class="n">Clock</span><span class="p">.</span><span class="n">GameTime</span><span class="p">;</span>
<span class="n">TimeSpan</span> <span class="n">quantumSize</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="m">50</span><span class="p">);</span>

<span class="c1">// Calculate the total number of steps.</span>
<span class="c1">// Because Ticks are integers, we lose the remainder</span>
<span class="c1">// of the division and get a nice round number.</span>
<span class="kt">long</span> <span class="n">numTimeQuantums</span> <span class="p">=</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">Ticks</span> <span class="p">/</span> <span class="n">quantumSize</span><span class="p">.</span><span class="n">Ticks</span><span class="p">;</span>

<span class="c1">// Get a new TimeSpan representing the number of full steps.</span>
<span class="n">TimeSpan</span> <span class="n">realGameTime</span> <span class="p">=</span> <span class="n">quantumSize</span> <span class="p">*</span> <span class="n">numTimeQuantums</span>
</code></pre></div></div>

<p>The game then advances its <code class="language-plaintext highlighter-rouge">CurrentTime</code> in 50 ms intervals until it catches up to <code class="language-plaintext highlighter-rouge">RealGameTime</code>. For every time its clock advances, the game calls <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code> once. When everything is going smoothly and there are no time-consuming tasks running, like region generation, an <code class="language-plaintext highlighter-rouge">UpdateFixedTime()</code> call should do only a single <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code>. To keep the simulation from being stuck in an endless loop in situations where it for some reason cannot keep up, there is an additional check that breaks the loop when it exceeds the expected frame time of 50 ms.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// _gameTimer is a Stopwatch instance that starts with the game.</span>
<span class="n">TimeSpan</span> <span class="n">updateStartTime</span> <span class="p">=</span> <span class="n">_gameTimer</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">_currentGameTime</span> <span class="p">+</span> <span class="n">FixedTimeBetweenUpdates</span> <span class="p">&lt;=</span> <span class="n">RealGameTime</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_currentGameTime</span> <span class="p">+=</span> <span class="n">FixedTimeBetweenUpdates</span><span class="p">;</span>

    <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>

    <span class="c1">// Bail out if we have exceeded the frame budget</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_gameTimer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">-</span> <span class="n">updateStartTime</span> <span class="p">&gt;</span> <span class="n">FixedTimeBetweenUpdates</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything up until this point has been relatively straightforward, but now the real time shenanigans begin. During <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code> the reins are partially handed over to the <code class="language-plaintext highlighter-rouge">GameEventScheduler</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">DoFixedTimeUpdate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Current simulation time is passed as an argument</span>
    <span class="n">GameEventScheduler</span><span class="p">.</span><span class="nf">TriggerEvents</span><span class="p">(</span><span class="n">_currentGameTime</span><span class="p">);</span>
    <span class="c1">// Everything else</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In fact, <code class="language-plaintext highlighter-rouge">GameEventScheduler</code>’s clock has priority over the game’s when current time is requested by various systems:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">CurrentTime</span> <span class="p">{</span> <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">GameEventScheduler</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">?</span> <span class="n">GameEventScheduler</span><span class="p">.</span><span class="n">CurrentTime</span> <span class="p">:</span> <span class="n">_currentGameTime</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>So what does <code class="language-plaintext highlighter-rouge">EventScheduler</code> do? Essentially, it allows the game to set up timers and trigger actions when they expire. You provide it with with a <code class="language-plaintext highlighter-rouge">TimeSpan</code> representing a delay before something should happen and an object representing the callback that needs to be executed, and it does everything else.</p>

<p>Believe it or not, this system appears to be an evolution of a similar system from <em>Diablo II</em>. Take a look at this code snippet from the <a href="https://github.com/ThePhrozenKeep/D2MOO">D2MOO</a> decompilation project:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AI think delay setup</span>
<span class="kt">int32_t</span> <span class="n">nAiDelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pGame</span><span class="o">-&gt;</span><span class="n">nGameType</span> <span class="o">||</span> <span class="n">pGame</span><span class="o">-&gt;</span><span class="n">dwGameType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get delay for the current difficulty from MonStats.txt</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="n">pMonStatsTxtRecord</span><span class="o">-&gt;</span><span class="n">nAIdel</span><span class="p">[</span><span class="n">pGame</span><span class="o">-&gt;</span><span class="n">nDifficulty</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// Fall back to normal difficulty</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="n">pMonStatsTxtRecord</span><span class="o">-&gt;</span><span class="n">nAIdel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Fall back to the default delay value</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nAiDelay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">nAiDelay</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Schedule the next think event</span>
<span class="n">EVENT_SetEvent</span><span class="p">(</span><span class="n">pGame</span><span class="p">,</span> <span class="n">pModeChange</span><span class="o">-&gt;</span><span class="n">pUnit</span><span class="p">,</span> <span class="n">UNITEVENTCALLBACK_AITHINK</span><span class="p">,</span> <span class="n">nAiDelay</span> <span class="o">+</span> <span class="n">pGame</span><span class="o">-&gt;</span><span class="n">dwGameFrame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Diablo II’s timing is completely frame-based with the game running at a constant framerate of 25 Hz. The code in this example retrieves the monster AI think delay value from a data file (<code class="language-plaintext highlighter-rouge">MonStats.txt</code>) and schedules a think event. At 25 FPS each frame is going to take <code class="language-plaintext highlighter-rouge">1000 / 25 = 40 ms</code>, meaning this delay will take <code class="language-plaintext highlighter-rouge">15 * 40 = 600 ms</code>. At Nightmare and Hell difficulty modes this delay is <code class="language-plaintext highlighter-rouge">14 * 40 = 560 ms</code> and <code class="language-plaintext highlighter-rouge">13 * 40 = 520 ms</code> respectively.</p>

<p>And here is reverse engineered code that does the equivalent in Marvel Heroes:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">Think</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">float</span> <span class="n">thinkTime</span> <span class="p">=</span> <span class="m">500</span><span class="p">;</span> <span class="c1">// slow think </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TargetEntity</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">||</span> <span class="n">AssistedEntity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">thinkTime</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span> <span class="c1">// fast think</span>
    <span class="nf">ScheduleAIThinkEvent</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMilliseconds</span><span class="p">(</span><span class="n">thinkTime</span><span class="p">)</span> <span class="p">*</span> <span class="n">Game</span><span class="p">.</span><span class="n">Random</span><span class="p">.</span><span class="nf">NextFloat</span><span class="p">(</span><span class="m">0.9f</span><span class="p">,</span> <span class="m">1.1f</span><span class="p">));</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">ScheduleAIThinkEvent</span><span class="p">(</span><span class="n">TimeSpan</span> <span class="n">timeOffset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Various checks and additional variation</span>
    <span class="c1">// for the offset happening here are omitted.</span>

    <span class="n">eventScheduler</span><span class="p">.</span><span class="nf">ScheduleEvent</span><span class="p">(</span><span class="n">_thinkEvent</span><span class="p">,</span> <span class="n">nextThinkTimeOffset</span><span class="p">,</span> <span class="n">_pendingEvents</span><span class="p">);</span>
    <span class="n">_thinkEvent</span><span class="p">.</span><span class="nf">Get</span><span class="p">().</span><span class="n">OwnerController</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Diablo II’s units are now called entities, Excel .txt files became prototypes, and instead of the number of frames we provide a <code class="language-plaintext highlighter-rouge">TimeSpan</code> as an argument for scheduling an event. The “slow thinking mode” is pretty much equivalent to the thinking rate from Diablo II. And this is not where similarities end: internally, <code class="language-plaintext highlighter-rouge">EventScheduler</code> still operates based on frames, just like Diablo II.</p>

<p>All scheduled events are grouped by “buckets”, with each bucket representing a frame. When an event is scheduled, it is put into a bucket based on the current time and requested delay, and its precise fire time is recorded.</p>

<p>When the <code class="language-plaintext highlighter-rouge">TriggerEvents()</code> method is called from <code class="language-plaintext highlighter-rouge">DoFixedTimeUpdate()</code>, the event scheduler advances its clock in fixed time steps until it catches up to the <code class="language-plaintext highlighter-rouge">_currentGameTime</code> that was passed as an argument, and each time it advances it executes all events in the bucket corresponding to the frame. Here is what a simplified version of this code looks like:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Determine time window</span>
<span class="kt">long</span> <span class="n">startFrame</span> <span class="p">=</span> <span class="n">CurrentTime</span><span class="p">.</span><span class="nf">CalcNumTimeQuantums</span><span class="p">(</span><span class="n">_quantumSize</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">endFrame</span> <span class="p">=</span> <span class="n">updateEndTime</span><span class="p">.</span><span class="nf">CalcNumTimeQuantums</span><span class="p">(</span><span class="n">_quantumSize</span><span class="p">);</span>

<span class="c1">// Process all frames that are within our time window</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="p">=</span> <span class="n">startFrame</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">endFrame</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">ScheduledEvent</span> <span class="n">@event</span> <span class="k">in</span> <span class="n">_buckets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="c1">// Set event scheduler's time to the precise event fire time</span>
        <span class="n">CurrentTime</span> <span class="p">=</span> <span class="n">@event</span><span class="p">.</span><span class="n">FireTime</span><span class="p">;</span>

        <span class="c1">// Invalidate event</span>
        <span class="n">_scheduledEvents</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">@event</span><span class="p">);</span>
        <span class="n">@event</span><span class="p">.</span><span class="n">EventGroupNode</span><span class="p">?.</span><span class="nf">Remove</span><span class="p">();</span>
        <span class="n">@event</span><span class="p">.</span><span class="nf">InvalidatePointers</span><span class="p">();</span>

        <span class="c1">// Run event callback</span>
        <span class="n">@event</span><span class="p">.</span><span class="nf">OnTriggered</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Synchronize time with the game</span>
<span class="n">CurrentTime</span> <span class="p">=</span> <span class="n">currentGameTime</span><span class="p">;</span>
</code></pre></div></div>

<p>Before the event scheduler triggers an event, it sets its clock to the precise time when the event is supposed to be fired. And because <code class="language-plaintext highlighter-rouge">Game.CurrentTime</code> returns the value of <code class="language-plaintext highlighter-rouge">GameEventScheduler.CurrentTime</code>, any game logic that runs as a result of the event callback is going to have precise time despite the simulation advancing in 50 ms steps.</p>

<p>But here is the crazy thing: as far as I can tell, events within their frame buckets are not sorted by fire time. Therefore, it is possible for the time to go <em>backwards</em>, although only within the confines of a single frame. Which in a way makes sense: events happening within the same frame are batched together and happen “simultaneously”, so the execution order here is not critical. The main potential problem would be inconsistent timing due to an event callback potentially scheduling another event, but because time is always set to the precise fire time, it’s going to remain consistent.</p>

<p>RIght now we have most of this system working, with the exception of the bucket management system. As a temporary solution we are storing all events in a single collection that we iterate to determine the events that would go in the bucket we would be processing, which is not ideal for performance, but it does the job well enough for now. The API for the system is pretty much done, and we can worry about optimizing internal implementation later.</p>

<p>And this is how time in Marvel Heroes works.</p>

<h2 id="finding-a-path-forward">Finding a Path Forward</h2>

<p><em>AlexBond is back again this month to talk about his work on pathfinding and AI.</em></p>

<hr />

<p>Hello, it’s AlexBond again. In this report I would like to talk about how AI works and the <code class="language-plaintext highlighter-rouge">NaviPath</code> generation process.</p>

<h3 id="aicontroller">AIController</h3>

<p>For an agent’s AI to work, the agent needs to enter the simulation using <code class="language-plaintext highlighter-rouge">SetSimulated()</code>, and its AI controller needs to be activated. (<em>Editor’s note: “agent” is the term the game uses to refer to world entities that can interact with the game world, such as avatars, enemies, team-ups, and so on</em>).</p>

<p>AI controller activation happens when an agent enters the game world, in the <code class="language-plaintext highlighter-rouge">OnEnteredWorld()</code> function: if the agent has a defined <code class="language-plaintext highlighter-rouge">BehaviorProfile</code>, an <code class="language-plaintext highlighter-rouge">AIController</code> instance is created. <code class="language-plaintext highlighter-rouge">AIController</code> consists of three main parts:</p>

<ul>
  <li>
    <p><strong>Brain</strong> - a behavior profile for the <code class="language-plaintext highlighter-rouge">ProceduralAI</code> system.</p>
  </li>
  <li>
    <p><strong>Senses</strong> - a class for determining potential allies and enemies that scans everyone every second in the defined <code class="language-plaintext highlighter-rouge">AggroRange</code>.</p>
  </li>
  <li>
    <p><strong>Blackboard</strong> - AI’s memory where temporary state is stored in the form of a <code class="language-plaintext highlighter-rouge">PropertyCollection</code>, as well as various vectors.</p>
  </li>
</ul>

<p>The main function of a controller is <code class="language-plaintext highlighter-rouge">Think()</code>. To keep server load in check, this function runs via a scheduled event every 90-110 ms in the “fast” thinking mode and every 450-500 ms in the “slow” thinking mode. When it runs, it activates the <code class="language-plaintext highlighter-rouge">Brain</code> and runs commands defined in the AI profile. AI profiles include some state logic and defines behavior templates for each state.</p>

<p>Let’s take a look at a concrete example - the think function for <code class="language-plaintext highlighter-rouge">ProceduralProfileVanityPetPrototype</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Think</span><span class="p">(</span><span class="n">AIController</span> <span class="n">ownerController</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Guard checks omitted</span>
    <span class="n">ProceduralAI</span> <span class="n">proceduralAI</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Brain</span><span class="p">;</span>
    <span class="n">Agent</span> <span class="n">agent</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">Agent</span><span class="p">;</span>
    <span class="n">WorldEntity</span> <span class="n">master</span> <span class="p">=</span> <span class="n">ownerController</span><span class="p">.</span><span class="n">AssistedEntity</span><span class="p">;</span>
    <span class="n">Game</span> <span class="n">game</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">Game</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">master</span><span class="p">.</span><span class="n">IsInWorld</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">distanceToMasterSq</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">DistanceSquared2D</span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">master</span><span class="p">.</span><span class="n">RegionLocation</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distanceToMasterSq</span> <span class="p">&gt;</span> <span class="n">MaxDistToMasterBeforeTeleportSq</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Teleport to master</span>
            <span class="nf">HandleContext</span><span class="p">(</span><span class="n">proceduralAI</span><span class="p">,</span> <span class="n">ownerController</span><span class="p">,</span> <span class="n">TeleportToMasterIfTooFarAway</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Move normally</span>
    <span class="nf">HandleMovementContext</span><span class="p">(</span><span class="n">proceduralAI</span><span class="p">,</span> <span class="n">ownerController</span><span class="p">,</span> <span class="n">agent</span><span class="p">.</span><span class="n">Locomotor</span><span class="p">,</span> <span class="n">PetFollow</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First, the pet determines its <em>master</em> (<code class="language-plaintext highlighter-rouge">AssistedEntity</code>) and the distance between them. If this distance exceeds the defined value, the pet teleports using <code class="language-plaintext highlighter-rouge">HandleContext()</code>. Then movement is initiated using <code class="language-plaintext highlighter-rouge">HandleMovementContext()</code>.</p>

<p><code class="language-plaintext highlighter-rouge">HandleMovementContext()</code> sets the state to <code class="language-plaintext highlighter-rouge">MoveTo</code>, which consists of four stages:</p>

<ul>
  <li>
    <p>Validate</p>
  </li>
  <li>
    <p>Start</p>
  </li>
  <li>
    <p>Update</p>
  </li>
  <li>
    <p>End</p>
  </li>
</ul>

<p>The agent then receives a command based on the settings defined in the <code class="language-plaintext highlighter-rouge">ContextPrototype</code>. In our vanity pet example this command is simply generating a path to <code class="language-plaintext highlighter-rouge">AssistedEntity</code>.</p>

<h3 id="generatepath">GeneratePath</h3>

<p>Path generation begins inside the <code class="language-plaintext highlighter-rouge">Locomotor</code> class. First, it disables <em>influence points</em> for <em>owner</em> (the pet) and <em>other</em> (the avatar) by calling the <code class="language-plaintext highlighter-rouge">DisableNavigationInfluence()</code> method. It then proceeds to the generation process itself - <code class="language-plaintext highlighter-rouge">GeneratePathInternal()</code>.</p>

<p>This process consists of three main steps:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">GeneratePathStep()</code> - we scan all <code class="language-plaintext highlighter-rouge">NaviTriangle</code> instances near the <em>startTriangle</em> until we find our destination - <em>goalTriangle</em>. All steps are recorded in <em>genPathState</em>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FunnelStep()</code> - a hard to understand algorithm, the goal of which is to remove unnecessary <code class="language-plaintext highlighter-rouge">NaviPoint</code> instances and determine <code class="language-plaintext highlighter-rouge">NaviSide</code> - the side to steer to avoid collision with an object (either left or right). The radius of the node to steer around is determined by summing the radiuses of the owner (the pet) and the <em>influenceRadius</em> - the radius of the object bound to the <code class="language-plaintext highlighter-rouge">NaviPoint</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CalcAccurateDistance()</code> - now that we have a path, we calculate its actual length taking into account all necessary steering and picking the shortest sides.</p>
  </li>
</ul>

<p>To illustrate this process, I have prepared two examples of path generation:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-1.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-1.jpg" alt="Pathfinding Example 1" /></a></p>

<p>As you an see, there are two entities between the pet and the avatar: S.T.A.S.H. and Maria Hill.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-1.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-1.gif" alt="Pathfinding Animation 1" style="max-height: 400px;" /></a>
</center>

<p>Now let’s take a look at a more involved example:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-example-2.jpg" alt="Pathfinding Example 2" /></a></p>

<p>In this case we have obstacles in the form of walls. The radiuses of nodes to steer around will be equal to the pet’s. Three paths are generated, and the shortest one is picked.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-2.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-06/pathfinding-animation-2.gif" alt="Pathfinding Animation 2" style="max-height: 400px;" /></a>
</center>

<p>Finding and fixing bugs in implementations of these algorithms took me a week. I even had to implement SVG export for the navi system to visualize what was happening. In the end, all issues were solved, and now we have pets and team-ups working in the server emulator.</p>

<p>As you run around with them, keep in mind that every 200 ms they perform complex calculations to find their path to you. In addition to that, <code class="language-plaintext highlighter-rouge">Locomotor</code> has a <em>repath</em> feature that checks and potentially rebuilds the path every 250 ms in case new objects appear in the way.</p>

<p>Now you should have a better understanding of how AI works. Although team-ups currently do not attack, they scan for targets every second, and when we enable these targets, combat will begin!</p>

<hr />

<p>It is time for us to get back to coding. We hope you all are going to join us again in July for a special one year anniversary report!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: May 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: May 2024" /><published>2024-05-31T19:00:00+03:00</published><updated>2024-05-31T19:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/05/31/progress-report-may-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-05/header.jpg" alt="MHServerEmu Progress Report - May 2024" /></p>

<p>Dread it, run from it, MHServerEmu Progress Report arrives all the same.</p>

<h2 id="back-in-time">Back in Time</h2>

<p>This month there has been an unexpected breakthrough. As I was finishing combing through the client’s serialization routines we talked about in the <a href="/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html">previous report</a>, I came to a realization just how little is actually needed to get in-game in some form. So I had an idea: what if we had a heavily stripped down version of the server, a minimum viable product with as much version-specific functionality removed as possible? In theory, this would allow us to get in-game using pretty much any version of the game client, which could be useful for various reasons. I decided to test this idea in practice by taking a build of version 1.10, dating back to the game’s original launch in June 2013,  and seeing if this turns out as simple as I thought. If I could get 1.10 running, any version from that all the way to 1.53 would be feasible.</p>

<p>I started by taking just the <code class="language-plaintext highlighter-rouge">MHServerEmu.Core</code> library, which handles aspects such as low level serialization and networking, and did a new lightweight server implementation with it. To my surprise, after just a couple hours of work on a single evening, I was in-game.</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-absolute-win.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-absolute-win.jpg" alt="I see this as an absolute win." /></a>
<p style="font-style: italic;">I see this as an absolute win.</p>
</center>

<p>My hypothesis turned out to be correct: not only all post-launch versions of the game are fundamentally very similar, but there is only one thing that can cause the process of putting a player into a game to fail - not having a valid name specified for the player. The only other little thing that needed fixing was the fact that older versions of the game do not allow entities with zero health to move around, but with just a little bit of extra work I was able to solve this.</p>

<p>One thing that is now possible is making use of some of the internal builds we were able to recover from Steam. These builds have all console commands unlocked, some of which can be used to get a better understanding of how the game works under the hood. For example, there is a number of visualization features for various aspects of the navi system, including mesh triangulation, pathfinding, entity bounds, and much more. Here is Avengers Tower with debug visualization for navimesh, collision shapes, physics sweeps, and pathfinding.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-navi-debug.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-navi-debug.jpg" alt="Navi Debug Mode" /></a></p>

<p>In addition to that, we can now explore some of the content that was never finished and later ended up being removed from the client. Two major examples of such content are the Savage Land patrol zone, also referred to as United Tribes in the game files, and the Thanos raid that was going to be centered around Knowhere. Both of them were <a href="https://www.ign.com/articles/2015/10/12/marvel-heroes-2016-announced-secret-invasion-story-coming">mentioned by Gazillion when promoting the Marvel Heroes 2016 rebrand</a>, and early versions of them are present in version 1.48, also known as the last pre-BUE version. The screenshots below represent this content the way it was in December 2016, a little less than a year before the game’s shutdown.</p>

<p>Savage Land Siege Patrol / United Tribes is the one closer to being finished. Although it is referred to as a “patrol zone”, apparently it was going to be more of its own thing, featuring some form of tower defense gameplay. The region layout present in the client resembles three-lane MOBA level design, but with additional twists and turns reminiscent of tower defense games.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-map.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-map.jpg" alt="United Tribes Map" /></a></p>

<p>Players start at the base where they can go down one of three lanes.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-base.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-base.jpg" alt="United Tribes Base" /></a></p>

<p>Here is what the middle of the map looks like.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-mid.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-mid.jpg" alt="United Tribes Mid" /></a></p>

<p>And on the opposite side of the map there is what appears to be an unfinished boss arena that uses the Red Onslaught’s model from the Axis raid as a placeholder.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-boss.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-united-tribes-boss.jpg" alt="United Tribes Boss" /></a></p>

<p>On the cosmic side of things we have the Thanos raid. As far as we can tell, it was going to feature Knowhere as a new hub region, similar to Genosha that accompanied the Axis raid, and this same hub was going to be the starting area of the raid itself. This hub features special camera settings, making it rotate around the center as you move on the outer ring.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-knowhere.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-knowhere.jpg" alt="Knowhere Hub" /></a></p>

<p>The raid itself was planned to include eight areas (the descriptions are mostly speculations based on file names and layouts):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ThanosRaidPart1Area</code>, containing four subareas - <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_A</code>, <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_B</code>, <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_C</code>, and <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_D</code>. <code class="language-plaintext highlighter-rouge">Knowhere_Spoke_A</code> is the only section of the raid that features mostly completed environment artwork. All other areas have only greyboxed layouts that occasionally reuse existing assets.</li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-raid-spoke-a.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-raid-spoke-a.jpg" alt="Thanos Raid Spoke A" /></a></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart3AreaBlackDwarf</code> (also referred to as <code class="language-plaintext highlighter-rouge">Knowhere_Hub_Part2_BlackDwarf</code> in the cell names), which appears to be an arena where players would have fought Black Dwarf.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart4AreaTransportBay</code> (<code class="language-plaintext highlighter-rouge">Knowhere_Transport_Bay_A</code>) looks like a section where players were supposed to fight their way through to a spaceship.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ThanosRaidPart5AreaShipCombat</code> is some kind of encounter where players were supposed to defend their spaceship acquired in the previous area.</p>
  </li>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">ThanosRaidPart6AreaSupergiant</code> player would board Thanos’ flagship, Sanctuary II, and fight Supergiant. In the beginning of this area there is what looks like the debris of the ship players acquired and defended in previous areas.</p>
  </li>
  <li>
    <p>The next area is called <code class="language-plaintext highlighter-rouge">ThanosRaidPart7AreaGauntlet</code>, and it appears to be an encounter where the raid would split into two teams and fight their way through Sanctuary II in series of three rooms for each team.</p>
  </li>
  <li>
    <p>It is followed by <code class="language-plaintext highlighter-rouge">ThanosRaidPart8AreaCorvusProxima</code> , the bridge of Sanctuary II, where players would have fought Corvus Glaive and Proxima Midnight.</p>
  </li>
  <li>
    <p>The same layout is reused for <code class="language-plaintext highlighter-rouge">ThanosRaidPart9AreaThanos</code>, and supposedly this is where the fight with Thanos himself was going to happen.</p>
  </li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-arena.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-thanos-arena.jpg" alt="Thanos Raid Thanos Arena" /></a></p>

<p>One other version we are now able to examine is 1.53, which is the version of the game that was on the test center when the game was shut down. It features:</p>

<ul>
  <li>
    <p>The costume closet system, which would turn costumes into options you could unlock and select in a separate panel, rather than equippable items.</p>
  </li>
  <li>
    <p>Playable Spider-Woman.</p>
  </li>
  <li>
    <p>An unfinished version of the playable Gladiator Thor. I mean Unworthy Thor. Actually, he is also referred to as just “Odinson”. Whatever his name was going to be, this was going to be an alternative, distinctly Mjolnir-less, version of Thor as a completely separate hero.</p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=Jop6iN1bO1Q">Apocalypse terminal from the console version of the game.</a></p>
  </li>
  <li>
    <p>Omega items, which were going to be some form of equipment set system with bonuses for equipping multiple items from the same set.</p>
  </li>
  <li>
    <p>A number of costumes for various heroes, including Apocalypse-themed costumes for Psylocke, Magik, Jean Grey, and Storm, costumes based on the Thor Ragnarok film for Thor, Loki, and Hulk, and other costumes not directly related to a specific event.</p>
  </li>
</ul>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-unworthy-thor.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/mini-screenshot-unworthy-thor.jpg" alt="Unworthy Gladiator Thor Odinson" /></a></p>

<p>One issue with this version is that its newest build, <code class="language-plaintext highlighter-rouge">1.53.0.203</code> from November 8th 2017, does not contain the assets for all the new content, such as new costumes. If you want to get the most content, you have to go back to at least <code class="language-plaintext highlighter-rouge">1.53.0.62</code> from two weeks prior to that, with all the extra bugs that entails. Even the earlier build though lacks the assets for some of the new regions, such as a new event terminal referred to as Hel Unleashed / Hela Palace, as well as a five-man version of the Muspelheim raid, both of which appear to had been planned as Thor Ragnarok tie-ins. While we do still plan to support version 1.53, as it is technically very similar to 1.52 we are currently focusing on right now, the definitive post-BUE version of Marvel Heroes is most likely going to be some kind of modded amalgamation of multiple versions.</p>

<p>The biggest takeaway from this development though is that it has definitively proven the viability of restoring pretty much any version of the game we have the client for. Just booting any version of the game now takes literally minutes (except for beta builds that have some additional jank that still needs to be figured out). It would require some effort to go as far back as 1.10, but adapting our 1.52 work for both 1.48 and 1.53 is most likely going to be significantly less difficult than we expected. As for the mini-emulator we have been using, we plan to share its source code relatively soon, once it is in a slightly more polished and user-friendly state.</p>

<h2 id="the-road-to-area-of-interest">The Road to Area of Interest</h2>

<p>Back in the realm of version 1.52 some significant backend progress has been achieved this month. The next major obstacle we need to overcome to get the game to a more playable state is implementing a proper area of interest system, and for that we had some cleaning up to do.</p>

<p>An area of interest is a server-side representation of what a particular client is aware of. When something changes in the game state (for example, your health goes up or down), only the clients that are interested in the affected entities should be notified. To find the interested clients, we need to be able to iterate connected players and check each of their individual areas of interest. However, in our previous temporary implementation of handling asynchronous network events a player could join or leave the game at arbitrary times, causing the iteration process to fail.</p>

<p>So one aspect that needed to be fixed is putting aside a specific point in the main game loop when new players could be added and removed. Whenever asynchronous events would happen, they would simply enqueue players to be added or removed during the next update. There is code for such behavior in the client, and we modeled our implementation after it. Same as Gazillion, we use a double buffer style approach: we have two instances of each queue, and when it is time to process joining / leaving players, the only thing we do in a lock is swap pointers to these two instances. While we process players in the instance we got, the other instance continues being filled asynchronously with players we are going to process in the next update. In the end this protects the game thread from asynchronous multithreaded weirdness and allows us to safely iterate players within the main loop.</p>

<p>One unfortunate side effect of this implementation was that it broke persistent player data saving. To understand how this happened we need to look at the bigger picture. Here is a rough overview of the server achitecture the game expects based on our observations:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-05/player-manager.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-05/player-manager.png" alt="Player Manager" /></a></p>

<p>The client connects directly only to the frontend server (FES). FES then relays client messages to the player manager, which distributes players across various game instances hosted by game instance servers (GIS). Because the player manager is aware where each player is, it can relay messages received from the frontend further down to the game instance where they belong. The player manager is the ultimate overseer of the entire game, and it would make sense for it to be the one interacting with the database. For those familiar with Diablo and other Blizzard games, the role of the player manager there would be handled by Battle.net.</p>

<p>We currently follow this structure pretty closely, but with some deviations. We have only a single server, and game instances are managed directly by the player manager without a separate GIS, but the overall flow is the same. So when a player disconnects, it raises an asynchronous event on the frontend server, that is then relayed to the player manager and handled by it. This handling includes removing the disconnected player from the game instance they were in and saving their data. However, now that the processing of joining and leaving players is deferred to a specific point in time, if you save player data to the database straight away, you are going to save an outdated copy of it, because the game instance most likely will have to wait until the next game frame to update the database model that is written. To fix this, we had to come up with a mechanism that also defers database writes until the game instance finishes processing leaving player. Added to the mix is also a possible case of multiple clients attempting to use the same account. Multithreading is fun!</p>

<p>With that out of the way, the next thing that needed to be done was cleaning up our entity management system and implementing inventories. One issue we had still hanging from the days of working with hardcoded packets was that player and avatar entities existed outside of the entity manager, which made it impossible for them to interact with other systems, such as areas of interest that we need to implement. However, if we were to just mix players and avatars with all the crates, cars and Maggia goons spawning all over the world, it would make it somewhat difficult to clean up when a player leaves a game. This is where inventories come in.</p>

<p>When most people think of an inventory, they probably imagine a grid full of epic loot. Marvel Heroes takes a more generalized approch: any entity can be in an inventory of any other entity. So all of your inactive avatars actually exist in the <code class="language-plaintext highlighter-rouge">PlayerAvatarLibrary</code> inventory. The avatar you are currently playing as gets put in the <code class="language-plaintext highlighter-rouge">PlayerAvatarInPlay</code> inventory. All of your team-ups exist in the <code class="language-plaintext highlighter-rouge">PlayerTeamUpLibrary</code> inventory. Same goes for summons that are contained in the <code class="language-plaintext highlighter-rouge">AgentSummonedEntities</code> inventory. Things you would expect to be stored in an inventory, such as equipment, is also included. To summarize, the inventory system in the game actually represents ownership relations between entities.</p>

<p>So by implementing the inventory system we could solve the problem of cleaning up all the various entities related to a player simply by recursively iterating all of their owned entities. And this is exactly what I did: we now have all the basic logic needed for adding, moving, and removing entities within inventories, as well as a lot of validation code mirroring the client implementation of the system. There is still some work to do before items you all know and love begin showing up in various inventory grids in the UI, but the implemented functionality is enough to take care of avatars, as well as  team-ups, who now show up as unlocked in latest nightly builds.</p>

<p>With all of this cleanup and refactoring we now reach a point where we can work on properly implementing the area of interest system, which is going to be the foundation of all client-server communication going forward. Once that is done, we are most likely going to enter another period of explosive progress, similar to the one we had in March when we got the game database fully working.</p>

<h2 id="behaviorism-and-us">Behaviorism and Us</h2>

<p>Before we wrap things up, here is also a quick update on what AlexBond has been up to. While I have been focusing on the more foundational aspects of the server, he has been digging into a system that is going to become rather important later on - behavior, also known as AI.</p>

<p>We are most likely going to go into more details on this in a future report, but here is an overview of what it looks like. Behavior affects anything that can do anything on its own: one obvious example of this is enemies, but there are also team-ups, pets, projectiles, and even orbs and boons that drop from various sources. It is implemented as a finite state machine with fourteen possible states: <code class="language-plaintext highlighter-rouge">Delay</code>, <code class="language-plaintext highlighter-rouge">Despawn</code>, <code class="language-plaintext highlighter-rouge">Flank</code>, <code class="language-plaintext highlighter-rouge">Flee</code>, <code class="language-plaintext highlighter-rouge">Flock</code>, <code class="language-plaintext highlighter-rouge">Interact</code>, <code class="language-plaintext highlighter-rouge">MoveTo</code>, <code class="language-plaintext highlighter-rouge">Orbit</code>, <code class="language-plaintext highlighter-rouge">Rotate</code>, <code class="language-plaintext highlighter-rouge">SelectEntity</code>, <code class="language-plaintext highlighter-rouge">Teleport</code>, <code class="language-plaintext highlighter-rouge">TriggerSpawners</code>, <code class="language-plaintext highlighter-rouge">UseAffixPower</code>, <code class="language-plaintext highlighter-rouge">UsePower</code>, and <code class="language-plaintext highlighter-rouge">Wander</code>. Transitions between these states are controlled by various <em>procedural profiles</em>, of which there are over a hundred in version 1.52. Some profiles are more generic, such as <code class="language-plaintext highlighter-rouge">ProceduralProfileBasicMeleePrototype</code>, while others are very specific, like <code class="language-plaintext highlighter-rouge">ProceduralProfileDrDoomPhase2Prototype</code>. The data for procedural profiles, such as what powers to use and how often, is defined in prototypes contained in the game database.</p>

<p>Surprisingly enough, the client contains not only all of the data, but also the vast majority of the code for procedural profiles. As far as we can tell, the main reason for this is that the AI system was also utilized by bots designed to stress-test servers with artificial load. While the full functionality for this feature is removed in shipping builds, there are enough traces of it for us to reverse engineer.</p>

<p>Over the course of May Alex has reimplemented 114 procedural profiles, and is now working on states. Once some more of the foundational systems are working, such as areas of interest and locomotion, this should bring some more life back to the game. It is not going to be “playable”, because we are most likely not going to have a working power system implementation for quite some time, but it should in theory make things like having a team-up or pet follow you in the game possible.</p>

<hr />

<p>And with that the third and final progress report of this spring is over. See you in the summer!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: April 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: April 2024" /><published>2024-04-30T19:00:00+03:00</published><updated>2024-04-30T19:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/04/30/progress-report-april-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-04/header.jpg" alt="MHServerEmu Progress Report - April 2024" /></p>

<p>Another month has passed, and we have some more updates to share regarding the development of MHServerEmu.</p>

<h2 id="i-serialize">I, Serialize</h2>

<p>Communication is key in relationships, and the one between the client and the server is no exception. A very important aspect of computer communication is the process of serialization - describing a data structure or an object so that it can be restored at another time and/or place. Serialization is commonplace in games: every time you save or load, you are serializing or deserializing the state of the game. Refactoring and improving our server’s serialization capabilities is something I have spent the better part of April working on. Before we dive into the specifics of what exactly Gazillion concocted, let us take a look at the bigger picture first. Some of this has already been mentioned in previous reports, but this time we are diving deeper than ever before.</p>

<p>One of the most popular serialization formats these days is JSON: it represents data as plain text, which makes it easily readable and convenient to edit, but also highly inefficient both in terms of bandwidth and serialization time. As mentioned in previous reports, the core technology that Marvel Heroes relies on for serialization is Google’s <a href="https://protobuf.dev/">Protocol Buffers</a> (protobufs). Here is how it works: first, you define a structure using its language:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetStructItemSpec</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">itemProtoRef</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint32</span>    <span class="na">itemLevel</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">rarityProtoRef</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint32</span>    <span class="na">seed</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint32</span>    <span class="na">creditsAmount</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="n">NetStructAffixSpec</span>    <span class="na">affixSpecs</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">equippableBy</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, you run the structures you defined through a code generator that produces highly efficient, but also very repetitive and barely readable code in your desired programming language. You can add this code to your program as a library, and then call it when you need something serialized. An important aspect of the code produced this way is that it includes the so-called “descriptors” that contain real-time type information (RTTI) and can be parsed by special tools, such as <a href="https://github.com/dennwc/protod">protod</a>, to restore the original definitions. This is exactly what we did: we reconstructed the original protobuf structures from the compiled C++ client code, which we then used to generate a C# library that serializes data in a way the client can understand. Such language interoperability is one of the key features of protobufs.</p>

<p>One way Gazillion uses protobufs is to implement a system that resembles the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>, and is the foundation of all network messages: requests are represented as objects that are serialized using protobufs, and then sent over a network. Here is an example of a server to client message that includes the <code class="language-plaintext highlighter-rouge">NetStructItemSpec</code> structure from the previous example, and is used to broadcast chat messages when players find rare items:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageBroadcastRareItem</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">string</span>    <span class="na">playerName</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">NetStructItemSpec</span>    <span class="na">item</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="n">ChatRoomTypes</span>    <span class="na">roomType</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And this is where the intended use of protobufs ends and we get into the hackery territory. As you look through the defined messages, you begin to see things like this pop up:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessageEntityCreate</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">baseData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessageLocomotionStateUpdate</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessageActivatePower</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">NetMessagePowerResult</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">bytes</span>    <span class="na">archiveData</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/hell.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/hell.jpg" alt="Gazillion Hackery" /></a></p>

<p>To make sense of this, first, we need to understand how protobufs work under the hood. <em>Note: We are going to assume little-endian byte order unless noted otherwise.</em></p>

<p>At the heart of protobufs lies the so-called <a href="https://protobuf.dev/programming-guides/encoding/">wire format</a>, which is used to encode your defined structures as binary data. The basic unit of information in protobufs is called a varint, which stands for <strong>var</strong>iable-width <strong>int</strong>eger. Typically, when you want to store a value, you use a data type with a certain amount of memory allocated to it, which dictates its bounds: a classic example of this is a signed 32-bit integer, which can store values from <code class="language-plaintext highlighter-rouge">-2147483648</code> to <code class="language-plaintext highlighter-rouge">2147483647</code>. When you store smaller values, you may need just one or two bytes, but a 32-bit signed integer is still going to use all four of them, even though most of the bits are going to be left unset. Protobufs solve this problem in two steps. First, when varints are encoded, the most significant bit in each byte is reserved as the “continuation bit” that determines whether there are more  bytes that follow it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10010110 00000001
^ MSB    ^ MSB
</code></pre></div></div>

<p>When decoding, we continue to read bytes until we get to the one where the most significant bit is not set. This way we can encode a value equivalent to a 64-bit unsigned integer, and it is going to take from one to ten bytes, with smaller values using fewer bytes.</p>

<p>If you were to use this approach to encode a signed integer though, you would run into an issue: since the most significant bit of an unencoded signed integer is used to determine whether it is negative or not, you are going to have go through a bunch of mostly useless zeroes to get to it, and you will end up using all ten bytes even for a value as small as <code class="language-plaintext highlighter-rouge">-1</code>. This is where the second part of the protobuf magic comes in: zig-zag encoding. The idea is that you mix positive and negative values together in a “zig-zag” pattern, with even numbers representing positive values, and odd numbers representing negative values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Encoded      Decoded
0            0
1              -1
2            1
3              -2
4            2
</code></pre></div></div>

<p>One last piece of the original protobuf puzzle we need to understand is how floating point values are encoded. Here a simple pointer hack is used: we just reinterpret the same four bytes used to store a 32-bit float as an unsigned 32-bit integer, and then we encode it using the method above.</p>

<p>Now that we have experienced the tragic backstory flashback, we can take a look at Gazillion’s secret serialization sauce. It seems they were unhappy with how protobufs performed out of the box, so they created their own custom abstraction layer on top of the base protobuf wire format - <em>archives</em>. An archive is an object that combines a memory buffer with functionality for four modes of serialization:</p>

<ul>
  <li>
    <p><strong>Migration</strong>: for server &lt;-&gt; server serialization.</p>
  </li>
  <li>
    <p><strong>Database</strong>: for server &lt;-&gt; database serialization.</p>
  </li>
  <li>
    <p><strong>Replication</strong>: for server &lt;-&gt; client serialization.</p>
  </li>
  <li>
    <p><strong>Disk</strong>: for server &lt;-&gt; file serialization.</p>
  </li>
</ul>

<p>Each mode can be used both for packing and unpacking, so in total we actually have eight different modes. To interact with an archive, we use the <code class="language-plaintext highlighter-rouge">Transfer()</code> method that has overloads for most common primitive types, such as <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, and so on, but also structures like <code class="language-plaintext highlighter-rouge">Vector3</code>, collections, and objects that implement the <code class="language-plaintext highlighter-rouge">ISerialize</code> interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">ISerialize</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Most <code class="language-plaintext highlighter-rouge">Transfer()</code> overloads act as wrappers than convert the passed value to or from an unsigned integer, and serialize it as a varint using the internal <code class="language-plaintext highlighter-rouge">Transfer_()</code> method:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">ioData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Convert int to uint and write it</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="n">CodedOutputStream</span><span class="p">.</span><span class="nf">EncodeZigZag32</span><span class="p">(</span><span class="n">ioData</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Read a uint and convert it back to int</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
        <span class="n">ioData</span> <span class="p">=</span> <span class="n">CodedInputStream</span><span class="p">.</span><span class="nf">DecodeZigZag32</span><span class="p">(</span><span class="n">encodedData</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In addition to the protobuf wire format, Gazillion brought some of their own tricks to the table. For instance, along with the standard protobuf way of encoding floating point values, archives support another, more efficient, but less precise way:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">TransferFloatFixed</span><span class="p">(</span><span class="k">ref</span> <span class="kt">float</span> <span class="n">ioData</span><span class="p">,</span> <span class="kt">int</span> <span class="n">precision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">precision</span> <span class="p">=</span> <span class="n">precision</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">precision</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="n">CodedOutputStream</span><span class="p">.</span><span class="nf">EncodeZigZag32</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">ioData</span> <span class="p">*</span> <span class="n">precision</span><span class="p">));</span>
        <span class="k">return</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">encodedData</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="nf">Transfer_</span><span class="p">(</span><span class="k">ref</span> <span class="n">encodedData</span><span class="p">);</span>
        <span class="n">ioData</span> <span class="p">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">CodedInputStream</span><span class="p">.</span><span class="nf">DecodeZigZag32</span><span class="p">(</span><span class="n">encodedData</span><span class="p">))</span> <span class="p">/</span> <span class="n">precision</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A precision argument is passed, which represents the power of 2 by which the value is multiplied. The fractional part is then discarded, and the value is encoded as a regular signed integer using the zig-zag method. The process is reversed to get an approximation of the original value with the given precision. Here is an example of a real value being encoded:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Encode</span>
<span class="kt">float</span> <span class="k">value</span> <span class="p">=</span> <span class="m">12.3689f</span><span class="p">;</span>
<span class="k">value</span> <span class="p">=</span> <span class="k">value</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="m">3</span><span class="p">);</span>                  <span class="c1">// 12.3689 * 8 = 98.9512</span>
<span class="kt">uint</span> <span class="n">encodedValue</span> <span class="p">=</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>           <span class="c1">// 98</span>

<span class="c1">// Decode</span>
<span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">encodedValue</span> <span class="p">/</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="m">3</span><span class="p">);</span>    <span class="c1">// 98 / 8 = 12.250</span>
</code></pre></div></div>

<p>So we end up with a value of <code class="language-plaintext highlighter-rouge">12.250</code>, which is an approximation of the original <code class="language-plaintext highlighter-rouge">12.3689</code>. The main use case for this kind of encoding is efficiently packing <code class="language-plaintext highlighter-rouge">Vector3</code> and <code class="language-plaintext highlighter-rouge">Orientation</code> structures, which consist of multiple <code class="language-plaintext highlighter-rouge">float</code> values, and reducing the amount of network traffic used by systems like locomotion.</p>

<p>The final boss of these encoding strategies is the way <code class="language-plaintext highlighter-rouge">bool</code> values are encoded. This caused us a lot of headaches when we first started the development of this project. The boolean data type represents a binary value that can be either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. However, since the smallest addressable unit of memory in many computer architectures is a byte, which consists of eight bits, a <code class="language-plaintext highlighter-rouge">bool</code> value typically occupies eight times more memory than it actually needs.</p>

<p>To deal with this inefficiency, Gazillion implemented a custom format for packing multiple boolean values into a single byte. When you first attempt to write a <code class="language-plaintext highlighter-rouge">bool</code> to an archive, it writes a byte and remembers the offset at which it was written. If the value is true, it writes <code class="language-plaintext highlighter-rouge">0x81</code>, otherwise <code class="language-plaintext highlighter-rouge">0x1</code>. The next time you try to write a <code class="language-plaintext highlighter-rouge">bool</code>, the archive goes back to the offset of the previously written bool byte, and packs the additional value into it. This continues until the archive packs up to five values to that byte, after which it writes a new byte and updates the offset. The end result you end up with is what we used to call “phantom bools”: when you read encoded data back, each boolean-packed byte contains up to four extra values in addition to the one that was being transfered in that <code class="language-plaintext highlighter-rouge">Transfer()</code> call. Here is how it ends up being structured:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bits  | Num Encoded | Hex  | Values
10000 | 001         | 0x81 | true
00000 | 001         | 0x1  | false
11000 | 010         | 0xC2 | true, true
01000 | 010         | 0x42 | false, true
00000 | 011         | 0x3  | false, false, false
10100 | 011         | 0xA3 | true, false, true
11111 | 101         | 0xFD | true, true, true, true, true
</code></pre></div></div>

<p>Each primitive data type may also use alternative encoding methods depending on the mode of serialization. The examples above are all for the replication mode, which we have to reimplement as accurately as possible, because it is the mode used to communicate with the client. Since we have the full control of the backend, for other modes, such as database, we can either reuse replication encoding, or come up with some kind of custom solution.</p>

<p>With the theory out of the way, we arrive at the practical application of archives. This is done via the previously mentioned <code class="language-plaintext highlighter-rouge">ISerialize</code> interface. It is implemented by objects that need to be serialized to archives, and when the stars align it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_currentCount</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_totalCount</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timeStart</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timeEnd</span><span class="p">);</span>
    <span class="n">success</span> <span class="p">&amp;=</span> <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">_timePaused</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code handles both serialization and deserialization in all modes, it is easy to read and maintain, and in general it looks like a good time. However, the saying “no plan survives contact with the enemy” is very true here. A lot of <code class="language-plaintext highlighter-rouge">ISerialize</code> implementations in the game look a lot more like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">Archive</span> <span class="n">archive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

    <span class="kt">uint</span> <span class="n">numElements</span> <span class="p">=</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">_myList</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
    <span class="n">archive</span><span class="p">.</span><span class="nf">Transfer</span><span class="p">(</span><span class="k">ref</span> <span class="n">numElements</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPacking</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPersistent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; database serialization</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsReplication</span> <span class="p">&amp;&amp;</span> <span class="n">archive</span><span class="p">.</span><span class="n">ReplicationPolicy</span><span class="p">.</span><span class="nf">HasFlag</span><span class="p">(</span><span class="n">AOINetworkPolicyValues</span><span class="p">.</span><span class="n">ReplicateToProximity</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; client serialization</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsPersistent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// database -&gt; server deserialization</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">archive</span><span class="p">.</span><span class="n">IsReplication</span> <span class="p">&amp;&amp;</span> <span class="n">archive</span><span class="p">.</span><span class="n">ReplicationPolicy</span><span class="p">.</span><span class="nf">HasFlag</span><span class="p">(</span><span class="n">AOINetworkPolicyValues</span><span class="p">.</span><span class="n">ReplicateToProximity</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// server -&gt; client deserialization</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything ends up being completely mixed up and coupled together, which makes it the opposite of a good time. However, these messy implementations provide us with a valuable insight into how the backend of the game, including database persistence, worked. Essentially, your account data, heroes, items, and so on would be serialized to an archive in the database mode to get what was pretty much a save file. This save file would then be saved to the database as a <a href="https://en.wikipedia.org/wiki/Object_storage">blob data type</a>.</p>

<p>All the necessary migration between versions would be handled by the same <code class="language-plaintext highlighter-rouge">Serialize()</code> method during unpacking, meaning that implementations <em>also</em> had to include additional complexity overhead of all the patches ever released so that someone who played for a week in 2013 could still log in again in 2017, with all their progress preserved and migrated on login. Thankfully, we do not have any old saved data to account for, and even when we do implement the support for more versions of the game, we can handle this conversion with an external tool of some kind if the need arises.</p>

<p><code class="language-plaintext highlighter-rouge">archiveData</code> byte arrays mentioned when I was talking about protobuf network messages are actually these same “save files”, but serialized in replication mode, which includes additional runtime information that is generally omitted from persistent storage, as well as some other differences. Some of these messages were actually standard protobuf structures prior to version 1.25, in which the developers did an optimization pass of their network protocol that included the conversion of some of the standard protobuf messages to archives.  Good examples of this are <code class="language-plaintext highlighter-rouge">NetMessageLocomotionStateUpdate</code> and <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code>: rather than representing an object, they are used as a more efficient way of packing runtime information. Here is an example of what <code class="language-plaintext highlighter-rouge">NetMessagePowerResult</code> looked like in version 1.24:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">NetMessagePowerResult</span> <span class="p">{</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">powerPrototypeId</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">targetEntityId</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">required</span> <span class="kt">uint64</span>    <span class="na">flags</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">bool</span>    <span class="na">isSelfTarget</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">powerOwnerEntityId</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">ultimateOwnerEntityId</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">combinedOwnerEntityId</span>    <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damagePhysical</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damageEnergy</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">damageMental</span>    <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">float</span>    <span class="na">healing</span>    <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="k">optional</span> <span class="n">NetStructPoint3</span>    <span class="na">powerOwnerPosition</span>    <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">int64</span>    <span class="na">powerAssetRefOverride</span>    <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
    <span class="k">optional</span> <span class="kt">uint64</span>    <span class="na">transferToEntityId</span>    <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So what I have been spending most of April doing is painstakingly going through all classes the implement the <code class="language-plaintext highlighter-rouge">ISerialize</code> interface, untangling the mess, and making adjustments to structures of serializable objects as needed. All of this is a necessary step for implementing the area of interest (AOI) system that handles replication of the server-side simulation to clients, but this is a story for another time.</p>

<h2 id="time-is-a-flat-circle">Time is a Flat Circle</h2>

<p>Serialization is not the only issue I have been tackling lately. As we get more and more fundamental systems working, we get closer to the real meat of this project - the real-time simulation of the game world, and the “real-time” aspect of it is quite tricky.</p>

<p>Probably the most ubiquitous programming pattern you can see in video games is the <a href="https://gameprogrammingpatterns.com/game-loop.html">game loop</a>. In its most simplest form it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">ProcessInput</span><span class="p">();</span>    <span class="c1">// Get input from keyboard / mouse / controllers</span>
    <span class="nf">Update</span><span class="p">();</span>          <span class="c1">// Update the simulation accordingly</span>
    <span class="nf">Render</span><span class="p">();</span>          <span class="c1">// Render the new state of the simulation</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we are dealing with a server, there are some I/O differences, but the general idea is the same:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">ProcessClientMessages</span><span class="p">();</span>    <span class="c1">// Player input is serialized and sent over a network</span>
    <span class="nf">Update</span><span class="p">();</span>                   <span class="c1">// Update the simulation accordingly</span>
    <span class="nf">SendUpdatesToClients</span><span class="p">();</span>     <span class="c1">// "Render" the new simulation state to clients</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We still process player input, even though we receive it with a delay, we update the simulation accordingly, and then we “render” the results, but instead of outputting a frame buffer to a screen we send message packets over a network. Therefore, most common wisdom regarding game loops is applicable to our case as well.</p>

<p>The big problem with this simple loop is that it runs as fast as your computer can run it. Therefore, the game is going to slow down or speed up depending on the processing power of the computer running it. It is not 1990 anymore, and our computers generally no longer have turbo buttons to account for this, so we have to deal with it in software.</p>

<p>One common way of solving this is to introduce the so-called delta time - the time difference in seconds between the previous update and the current one:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">_lastFrameStartTime</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="c1">// Divide to convert milliseconds to seconds</span>
    <span class="kt">float</span> <span class="n">delta</span> <span class="p">=</span> <span class="p">(</span><span class="n">currentTime</span> <span class="p">-</span> <span class="n">_lastFrameStartTime</span><span class="p">)</span> <span class="p">/</span> <span class="m">1000f</span><span class="p">;</span>
    <span class="n">_lastFrameStartTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="nf">ProcessInput</span><span class="p">();</span>
    <span class="nf">Update</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="nf">Render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then when we update something, we multiply our time-sensitive values by <code class="language-plaintext highlighter-rouge">delta</code> to account for how much time has passed:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">_position</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_speed</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_position</span> <span class="p">+=</span> <span class="n">_speed</span> <span class="p">*</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So the less time has passed since the last update, the less distance we are going to cover in this update. This works great if the game is running locally, and it is the approach you are most likely familiar with if you have ever worked with popular game engines. However, it is not a one-size-fits-all solution. One issue with it is that most video games rely on single-precision floating-point numbers (floats) for a lot of their calculations, which are fast, but also subject to rounding errors. The faster your computer runs, the more updates that involve float calculations it does, and the more float calculations it does, the more its rounding error builds up. In online multiplayer games this leads to clients getting desynchronized from the server, which is something that should be minimized.</p>

<p>To avoid this issue, a fixed update interval is used, commonly referred to as a “tick rate”. This is especially a hot topic in competitive shooters, where the tick rate can get as high as 120+ Hz (so 8.33 ms or less per simulation update). The rendering frequency in this case is generally decoupled from the main simulation, so it is possible to render the game at hundreds of frames per second even with a modest tick rate. The smoothness in this case is achieved by a combination of interpolation and independent simulation of systems that do not have synchronized, such as particle effects. A good example of this is <em>Overwatch</em>, which at launch ran at a modest (by competitive shooter standards) tick rate of around 21 Hz, and eventually it got upgraded to approximately 63 Hz in a later patch. The biggest downside of a low tickrate is that it “batches” events together, causing some things that occured separately to be processed simultaneously, such as you and your opponent shooting and killing each other.</p>

<p>Marvel Heroes also uses this approach: internally it refers to its ticks as “frames”, and by default it runs at the “framerate” of exactly 20 Hz (50 ms per frame). The code that runs the simulation is shared by both the server and the client: the server runs it as a standalone thing, while in the client it is integrated into Unreal Engine, so essentially you have a mini-engine running inside Unreal. To keep the gameplay smooth and responsive, the client runs its own instance of the simulation and corrects it using the information that the server “renders” to it.</p>

<p>So what do you do after you finish your fixed-time update? You wait until it is time for another update. The naive way to approach it is this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">float</span> <span class="n">TargetFrameTime</span> <span class="p">=</span> <span class="m">50.0f</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">_previousTime</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_accumulatedTime</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_accumulatedTime</span> <span class="p">-=</span> <span class="n">TargetFrameTime</span><span class="p">;</span>
        <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>    <span class="c1">// Process input, update state, send updates</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While precise, doing it this way keeps the thread constantly busy, wasting power doing pretty much nothing. Thankfully, there is a handy tool provided to us by the operating system - sleep, which is a feature that lets the OS know that we are not currently doing anything, and the CPU can be used for something else, or it can stay idle if nothing else is going on. This provides us with a much more efficient, but still rather naive way of implementing this, which we previously used for MHServerEmu:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&lt;</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">sleepTime</span> <span class="p">=</span> <span class="n">TargetFrameTime</span> <span class="p">-</span> <span class="n">_accumulatedTime</span><span class="p">;</span>
        <span class="c1">// Sleep() takes an integer number of milliseconds as its argument</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">sleepTime</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Do the update if enough time has passed</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So what is so naive about this? The fact that the thread scheduler treats what you tell it to do like the pirate code: it is more like guidelines than actual rules. The time you specify is actually the minimum amount of time the thread is going to sleep, and how much it overshoots this target depends on: your operating system and its version, your hardware, whether a high precision timer is enabled, ambient entropy levels, the state of Schrödinger’s cat, and who knows what else.</p>

<p>This is a problem we are still working on solving, but the solution we are trying out at the time of writing is one of multiple used by the <a href="https://monogame.net/">MonoGame framework</a> (a modern offshoot of Microsoft’s XNA), which involves sleeping in smaller intervals with checks inbetween:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">currentTime</span> <span class="p">=</span> <span class="nf">GetTime</span><span class="p">();</span>
    <span class="n">_accumulatedTime</span> <span class="p">+=</span> <span class="n">currentTime</span> <span class="p">-</span> <span class="n">_previousTime</span><span class="p">;</span>
    <span class="n">_previousTime</span> <span class="p">=</span> <span class="n">currentTime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&lt;</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">TargetFrameTime</span> <span class="p">-</span> <span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="m">2.0</span><span class="p">)</span>
            <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wrap this in while loop to catch up if we missed some frames</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_accumulatedTime</span> <span class="p">&gt;=</span> <span class="n">TargetFrameTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_accumulatedTime</span> <span class="p">-=</span> <span class="n">TargetFrameTime</span><span class="p">;</span>
        <span class="nf">DoFixedTimeUpdate</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The results we have seen with this implementation range from “good enough” to “pretty great”. When testing on a virtual machine running Kubuntu, the overshoot was generally within our leeway of 2 ms, while on Windows 10 our measured sleep times seemed to be around 15 ms (given the requested 1 ms of sleep), which appears to match the default Windows timer resolution. For measuring this we have used the <code class="language-plaintext highlighter-rouge">Stopwatch</code> class provided by .NET. For now this seems to be accurate enough for our 50 ms window, but for potentially running a more precise simulation we are going to need a better solution.</p>

<p>There are still some tricks we can try out, including those employed by MonoGame and its cousin <a href="https://fna-xna.github.io/">FNA</a>, such as importing and calling native Windows API functions related to timer resolutions, making use of <code class="language-plaintext highlighter-rouge">Thread.SpinWait()</code>, and others. As more gameplay systems become functional, we are also going to have to improve our catchup system: fixed-time update systems are prone to so-called “death spirals”, where your computer is unable to update the simulation fast enough, which leaves more work to do for the next update, and eventually it ends up getting completely stuck. There are strategies to mitigate and potentially recover from these, and it is something we are going to dive deeper in the future.</p>

<h2 id="navi-population-and-physics">Navi, Population, and Physics</h2>

<p><em>AlexBond is back yet again to discuss how things have been going on his front. Please see the <a href="/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html">March report</a> for more context on the work he has been doing lately.</em></p>

<hr />

<p>Hey everyone, it’s AlexBond. This month has ended up being rather fruitful, although it may not seem this way at first. Let’s take a look.</p>

<p>Here are the main things I have been working on:</p>

<ul>
  <li>
    <p>Finishing up the NaviSystem</p>
  </li>
  <li>
    <p>BlackOutZone</p>
  </li>
  <li>
    <p>PropSets</p>
  </li>
  <li>
    <p>AreaPopulation</p>
  </li>
  <li>
    <p>SpawnSpec</p>
  </li>
  <li>
    <p>PlayKismetSeq</p>
  </li>
  <li>
    <p>EntityFilter Evaluate</p>
  </li>
  <li>
    <p>PhysicsManager and NaviSweep</p>
  </li>
</ul>

<p><strong>NaviSystem</strong> has been improved: all issues have been fixed, and we now have the <code class="language-plaintext highlighter-rouge">NaviMesh.Contains()</code> function that we can use to determine whether an object is contained within the playable area or not. One of the issues that has been fixed is the spawning of NPCs outside of the playable area. In addition, this has laid the foundation for processing game physics interactions.</p>

<p>A <strong>BlackOutZone</strong> is a marker with a radius that defines a zone where enemy spawning is restricted. This information is contained within Cell markers. Some blackout zones are defined in missions or spawners, and NPCs can spawn only if the required mission is in the correct state. When all markers are placed via <code class="language-plaintext highlighter-rouge">SpawnBlackOutZone()</code>, we get another tool to detect intersections with a zone - <code class="language-plaintext highlighter-rouge">InBlackOutZone()</code>. This adds another check when spawning <em>ClusterEntities</em>.</p>

<p><strong>PropSets</strong> are sets of random destructible objects that appear in an area, such as boxes and cars. Markers are picked using <code class="language-plaintext highlighter-rouge">GetRandomPropMarkerOfType()</code> from <code class="language-plaintext highlighter-rouge">PropShapeLists</code>, and then placed in the world. We now have even more cars and trash!</p>

<p><strong>AreaPopulation</strong> is another way of spawning enemies in the game world, but in this case instead of markers we have groups and their weights. Each <em>area</em> has an <code class="language-plaintext highlighter-rouge">AreaPrototype.Population</code> field that contains <code class="language-plaintext highlighter-rouge">Themes.Enemies</code>, as well as population density parameters. We calculate the density of enemies that are already present in an area, and then we determine how many additional enemies we need to add to get to the defined threshold. To get a more accurate density value we use <code class="language-plaintext highlighter-rouge">CalcSpawnableArea()</code> via <code class="language-plaintext highlighter-rouge">NaviMesh</code> while taking into account space not occupied by blackout zones. This way enemies are distributed randomly and evenly along appropriate cells using <code class="language-plaintext highlighter-rouge">SpawnInCell()</code>. Examples of regions that rely on this spawning method include Training Camp, Daily Bugle, Classified Bovine Sector, almost all terminals, as well as other regions that previously seemed rather deserted.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-cows.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-cows.jpg" alt="An Amoosing Sight" /></a></p>

<p>Fun fact: the terminal version of Sinister Lab has a population override that prevents dinosaur enemies from spawning there, even though they are present in the story mode version of this region. Some players didn’t seem to remember this.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser.png" alt="Population Override" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-dinos.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-dinos.jpg" alt="Life Finds a Way" /></a></p>

<p><strong>SpawnSpec</strong> is a class responsible for spawning all groups of enemies, including regular NPCs that are typically tied to missions or their own spawners. By merging the spawning system into the SpawnSpec class we have finally been able to get rid of issues with objects hovering in the air and getting stuck in the ground. One remaining problem is that because many destructible props currently spawn after enemies, the system is unable to properly detect collisions, which leads to enemies getting stuck in cars and barrels. This is going to be resolved on its own once spawners get their own timers and events for doing their work.</p>

<p><strong>PlayKismetSeq</strong> is a command that can be sent as a message to the client to start a scripted Unreal Engine cutscene. For example, I have added a trigger for such sequence to the Raft, and now you can see the Quinjet landing when you load into the region. This also includes an animation of Juggernaut running away.</p>

<p><em>Editor’s Note:  Kismet is the name of the visual scripting language that was available in Unreal Engine 3. Those of you who have experience with versions 4 and 5 are most likely familiar with Blueprints: Kismet is an earlier iteration of the same concept. For more information on Kismet see the <a href="https://docs.unrealengine.com/udk/Three/KismetHome.html">official documentation</a>. And now, back to our regularly scheduled programming.</em></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-kismet.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-kismet.jpg" alt="Reporting for Duty!" /></a></p>

<p>After that I started investigating what triggers these sequences, and that led me to <em>hotspots</em> and <em>MissionConditionPrototype</em>.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-browser-2.png" alt="Population Override" /></a></p>

<p>Everything turned out to be more complicated than I expected, and I ended up working on implementing mission logic and game physics…</p>

<p><strong>EntityFilters</strong> are sets of conditions for triggering mission events. To get the result of a condition it has to be determined using the <code class="language-plaintext highlighter-rouge">Evaluate()</code> function, as well as a cached <code class="language-plaintext highlighter-rouge">EntityTrackingContextMap</code> in the <strong>InteractionManager</strong>. This function is coupled with lots of various systems: regions, areas, entities, missions. I have implemented all the base logic, and this foundation is going to come in handy in the future.</p>

<p>The <strong>PhysicsManager</strong> calculates displacements and collisions. The server runs <code class="language-plaintext highlighter-rouge">PhysicsResolveEntities()</code> every frame and checks all active entities for collisions. Internally displacements are called <em>sweeps</em>, and they are handled by the <em>NaviSweep</em> class. NaviSweep consists of numerous real time calculations. After studying some of them, we were able to figure out the source of inspiration for many of them: the book <a href="https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323">Real-Time Collision Detection by Christer Ericson</a>. Many of the functions used in the game are taken from this book word for word, and it has helped us to make sense of everything. Below is a figure from the book that explains how the <code class="language-plaintext highlighter-rouge">Sphere.Sweep(Aabb)</code> function works.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-04/alex-rtcd.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-04/alex-rtcd.png" alt="Real-Time Collision Detection by Christer Ericson" /></a></p>

<p><em>PhysicsManager</em> and <em>NaviSweep</em> do a lot of projection and collision detection, but the end result of all these calculations is the triggering of these three events:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnCollide()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnOverlapBegin()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OnOverlapEnd()</code></p>
  </li>
</ul>

<p>We now have triggers, we can check conditions with <code class="language-plaintext highlighter-rouge">Evaluate()</code>, but we still don’t have an <em>avatar</em> that is going to interact with all of these.</p>

<p>For an avatar (a playable character) to be able to enter the physical world and interact with it, it requires a working <em>Locomotor</em> system.</p>

<p>The server runs <code class="language-plaintext highlighter-rouge">LocomoteEntities()</code> every frame to calculate all types of movements in the game. The Locomotor system is responsible for things such as: moving enemies with <code class="language-plaintext highlighter-rouge">MoveTo()</code>, finding their paths with <code class="language-plaintext highlighter-rouge">GeneratePath()</code>, rotating them with <code class="language-plaintext highlighter-rouge">LookAt()</code>, processing flight, various restrictions, velocity, synchronizing these movements between the server and the client with <code class="language-plaintext highlighter-rouge">SetSyncState()</code>, as well as interacting with the <strong>NaviPath</strong> system. And this is what I am going to be working on next month!</p>

<hr />

<p>We hope you enjoyed this report, see you again next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: March 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: March 2024" /><published>2024-03-31T19:50:00+03:00</published><updated>2024-03-31T19:50:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/03/31/progress-report-march-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-03/header.jpg" alt="MHServerEmu Progress Report - March 2024" /></p>

<p>Spring has come to the Northern Hemisphere, and the development of MHServerEmu is blooming.</p>

<h2 id="010-release">0.1.0 Release</h2>

<p>This month we have reached an important milestone: our first “official” binary release. Version 0.1.0 represents the progress we were able to achieve in the first 8 months of this project, including all the work on the game database, properties, and region generation we have been talking about in these reports. In addition to that, we have implemented enough fundamental systems to remove the last remaining hardcoded data packets, which allows us to fully control the data that is serialized to the client and no longer be bound to a specific version of the game.</p>

<p>If you have been following the development and tried out the nightly snapshot builds, most of what is contained in this release should be familiar to you. However, there are a few extras we included.</p>

<p>0.1.0 comes with the new Setup Sorcerer Supreme tool, which is our flavored spin on the setup wizard idea that is common in software. Here is what it currently does:</p>

<ul>
  <li>
    <p>Verifies the game client version by finding the main executable, hashing it, and comparing the hash to the expected one.</p>
  </li>
  <li>
    <p>Copies the <code class="language-plaintext highlighter-rouge">.sip</code> files required to run the server to the MHServerEmu data directory.</p>
  </li>
  <li>
    <p>Creates a <code class="language-plaintext highlighter-rouge">StartClient.bat</code> file that launches the client configured to connect to a local server.</p>
  </li>
  <li>
    <p>Creates a <code class="language-plaintext highlighter-rouge">StartClientAutoLogin.bat</code> file that launches the client configured to connect to a local server with automatic login using pre-defined credentials.</p>
  </li>
</ul>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-03/setup-sorcerer-supreme.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/setup-sorcerer-supreme.png" alt="Setup Sorcerer Supreme" /></a>
</center>

<p>This release also comes bundled with the Apache web server and web assets for the in-game store and news panels. These assets are also available separately in the new <a href="https://github.com/Crypto137/MHServerEmuWebAssets">MHServerEmuWebAssets</a> repository.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/news.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/news.jpg" alt="New Web Assets - News Panel" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/store.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/store.jpg" alt="New Web Assets - Store Panel" /></a></p>

<p>As soon as 0.1.0 was released, we started working on version 0.2.0. Currently we do not have any estimates for when it is going to be out, but like always you can follow the progress on <a href="https://github.com/Crypto137/MHServerEmu/network">GitHub</a> and via nightly builds.</p>

<h2 id="game-database-browser">Game Database Browser</h2>

<p>Kawaikikinou has finished the work on a new game database browser tool that allows you to easily browse all the static game data we have been decoding over the past few months. Now you can relatively easily find out, for instance, what was the <em>actual</em> drop rate of the infamous Gem of the Kursed.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/game-database-browser.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/game-database-browser.jpg" alt="Game Database Browser" /></a></p>

<p>The browser works by plugging in existing server code into a WPF-based GUI. This is more of a development tool rather than something that is intended to be used by end users, but it has already proven to be extremely helpful in getting a better understanding of how everything fits together. The source code is available on <a href="https://github.com/Kawaikikinou/MHServerEmu/tree/game-database-browser">GitHub</a>.</p>

<h2 id="server-architecture-improvements">Server Architecture Improvements</h2>

<p>One of the first things I wanted to do in 0.2.0 was to make improvements to the overall server achitecture and how data flows around. Here is an overview of what has been done so far.</p>

<p>Major parts of the server (game, player management, billing, and so on) have been decoupled from each other and split into separate library projects. This allows us to potentially remove or substitute certain service implementations. For example, the database access layer can now be more easily modified to use various persistent storage solutions, such as a fully featured database management system. Also this allows us to reuse game code for tools, like the previously mentioned game database browser.</p>

<p>Duplicate login handling has been improved. Previously, the player manager would refuse connections for any players that are trying to log in using an account that is already logged in. This could cause potential issues if for some reason a player remained logged in due to an unexpected crash or some other problem. Now it works like most online games: when a duplicate login is detected, the already logged in player is disconnected, their data is saved, and then reassigned to the new session.</p>

<p>Our continuous integration pipeline that is used for nightly builds now has an additional step - running automated tests. As the server codebase grows, it becomes harder and harder to keep track of all the potential things that could break, especially because there are certain parts that have to be 100% in sync with the client. With daily automated testing hopefully we will be able to discover and fix any potential issues with existing code as soon as they come up.</p>

<p>The network message flow has been overhauled. Messages are now deserialized asynchronously before they reach game simulations, which frees up valuable frame time. The way messages are batched together and sent to the clients has also been redone, and is now closer to the client implementation. Connected players are now represented in the game they are in by <code class="language-plaintext highlighter-rouge">PlayerConnection</code> instances, which allowed us to clean up message handling and improve individual player state tracking.</p>

<p>The work on this front continues, and some more progress has been made with properly reimplementing the custom Gazillion serialization archive system, which we are going to talk more about in the next report.</p>

<h2 id="steam-deck-support">Steam Deck Support</h2>

<p>Thanks to the efforts of <strong>FF_Lowthor</strong> from our Discord server we have been able to get the game running on Linux (and Steam Deck).</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/steam-deck.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/steam-deck.jpg" alt="Marvel Heroes Steam Deck" /></a></p>

<p>The game client has a rather peculiar compatibility issue when running under Proton. During the authentication process the client receives a session token and a 256-bit AES encryption key from the auth server. It then generates an initialization vector (IV) that it mixes with the encryption key to encrypt the token it received, which is then used to authenticate with the frontend server. Something goes wrong somewhere in this token encryption process under Proton, which causes the authentication to fail.</p>

<p>FF_Lowthor has made a patch that allows the client to ignore this error and proceed with the login without a properly encrypted token. You can apply this patch by changing <code class="language-plaintext highlighter-rouge">75</code> to <code class="language-plaintext highlighter-rouge">EB</code> at <code class="language-plaintext highlighter-rouge">0x019B317E</code> in the Win64 version of <code class="language-plaintext highlighter-rouge">MarvelHeroesOmega.exe</code> either manually with a hex editor, or using our <a href="https://github.com/Crypto137/MHPatcher">MHPatcher</a> tool.</p>

<p>Server-side you also have to enable <code class="language-plaintext highlighter-rouge">BypassAuth</code> in <code class="language-plaintext highlighter-rouge">Config.ini</code> to allow clients to log in without valid session tokens. As quality of life feature, the server now also saves data for the default account used when BypassAuth is enabled in a JSON file.</p>

<h2 id="entity-spawning-and-navi">Entity Spawning and Navi</h2>

<p>This month AlexBond is back to talk about world entity spawning and the NaviSystem. If you have not already, be sure to check out his explanation of the procedural region generation from the <a href="/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html">January report</a>.</p>

<hr />

<p>Hey everyone, it’s AlexBond. In this report I would like to talk about the enemy spawning process and a little bit about NaviMesh generation.</p>

<h3 id="clusterobject">ClusterObject</h3>

<p><code class="language-plaintext highlighter-rouge">ClusterObject</code> is the foundation of all spawners in the game, from idle NPCs standing around and chatting with each other, to armies of enemies in a formation with their leaders and henchmen.</p>

<p>At the heart of these objects lies data from <code class="language-plaintext highlighter-rouge">PopulationObjectPrototype</code> instances. They describe the number of regulars enemies (called <em>riders</em>), their <em>formation</em>, and a bunch of other settings. This prototype class has various derived classes that define whether a group has a <em>leader</em>, how many <em>henchmen</em> it contains, and many other specifics. ClusterObjects also belong to a <code class="language-plaintext highlighter-rouge">ClusterGroup</code>, and there is a derived <code class="language-plaintext highlighter-rouge">ClusterEntity</code> class that is responsible for spawning specific enemies.</p>

<h3 id="populationmarker-spawning">PopulationMarker Spawning</h3>

<p>Cell prototypes contain <code class="language-plaintext highlighter-rouge">SpawnMarkerPrototype</code> instances. When we load region missions, we look for the <code class="language-plaintext highlighter-rouge">PopulationSpawns</code> field that describes the amount of enemies on the map and the name of the spawn marker. We assemble all of this information into the <code class="language-plaintext highlighter-rouge">PopulationMarkers</code> array, and in the <code class="language-plaintext highlighter-rouge">Cell.PostGenerate()</code> method we add enemies to their places.</p>

<p>For random placements we have the <code class="language-plaintext highlighter-rouge">SpawnMarkerRegistry</code> class that uses <code class="language-plaintext highlighter-rouge">SpawnReservation</code> to randomly pick free markers that are appropriate for specific enemies.</p>

<p>After determining the required marker coordinates, we place the enemy group using the assigned formation method. There are four kinds of formations:</p>

<ul>
  <li>
    <p>BoxFormation - grid-type formation that uses rows and columns.</p>
  </li>
  <li>
    <p>LineFormation - formation along a line.</p>
  </li>
  <li>
    <p>ArcFormation - formation along an arc.</p>
  </li>
  <li>
    <p>FixedFormation - formation that uses fixed coordinates (FormationSlot).</p>
  </li>
</ul>

<p>Other than formations, there is also placement using coordinates defined in <code class="language-plaintext highlighter-rouge">EncounterResourcePrototype</code>. For example, Jessica Jones and Ben Urich in the Avengers Tower are placed this way.</p>

<h3 id="spawner">Spawner</h3>

<p>A <em>spawner</em> is a special entity type that contains information about the number of enemies, their spawn timers, the uniqueness of their spawn distance, and many other parameters. Since spawners are derived from entities, they can be a part of a ClusterObject.</p>

<p>Currently we do not take spawn timers into account, so all enemies spawn at the same time (which occasionally looks overly populated).</p>

<p>One important distinction of spawners is that they place enemies randomly using the <code class="language-plaintext highlighter-rouge">PickPositionInSector()</code> method. To better illustrate how this works, let’s imagine a game of darts:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/darts.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/darts.png" alt="Spawner Darts" /></a></p>

<p>We divide the space in a radius around an object into equal sections, and then we randomly determine the slot we are going to use for spawning. Then we check for collisions with other objects, and if this check fails we randomly pick another spawning point. Currently we do not have any Navi checks, so many enemies spawn in the air or inside walls.</p>

<p>In addition to spawners described in missions and cells, there are also spawners defined in MetaState prototypes.</p>

<h3 id="metastate-spawning">MetaState Spawning</h3>

<p>All region prototypes have a <code class="language-plaintext highlighter-rouge">MetaGame</code> field. We can get MetaState by going through the following sequence:</p>

<center>
Region – MetaGames – GameModes – ApplyStates
</center>

<p>For wave-based regions, such as the S.H.I.E.L.D. Holo-Sim, the path is slightly different:</p>

<center>
Region – MetaGames – GameModes – States
</center>

<p>There are different varieties of MetaStates:</p>

<ul>
  <li>
    <p>MetaStateMissionProgressionPrototype</p>
  </li>
  <li>
    <p>MetaStateMissionActivatePrototype</p>
  </li>
  <li>
    <p>MetaStateMissionSequencerPrototype</p>
  </li>
  <li>
    <p>MetaStateWaveInstancePrototype</p>
  </li>
  <li>
    <p>MetaStatePopulationMaintainPrototype</p>
  </li>
</ul>

<p>Right now we don’t have properly working events in the game, so we just get population objects from the <code class="language-plaintext highlighter-rouge">PopulationRequiredObjectPrototype</code>, and then we retrieve PopulationMarkers, which we then proceed to use as described above.</p>

<p>There is one more type of enemy placements defined in <code class="language-plaintext highlighter-rouge">PopulationThemePrototype</code> instances. Instead of markers, it uses <code class="language-plaintext highlighter-rouge">BlackOutZonePrototype</code> instances and weights. However, we cannot implement this method of spawning without the NaviSystem.</p>

<h3 id="navisystem">NaviSystem</h3>

<p>Over the last month I have been working on reimplementing the NaviSystem, and I have already achieved some results. Essentially, the NaviSystem is a <code class="language-plaintext highlighter-rouge">NaviMesh</code>, which is a set of <code class="language-plaintext highlighter-rouge">NaviTriangles</code> consisting of three <code class="language-plaintext highlighter-rouge">NaviEdges</code> built from two <code class="language-plaintext highlighter-rouge">NaviPoints</code>. The generation process happens in the <code class="language-plaintext highlighter-rouge">NaviCDT</code> class (CDT stands for Constrained Delaunay Triangulation). <a href="https://gwlucastrig.github.io/TinfourDocs/DelaunayIntroCDT/index.html">Here is an article</a> about this technique in case you are interested to learn more.</p>

<p>When we initialize a game region, we create a region-sized rectangle consisting of two triangles. Then we add cell information to <code class="language-plaintext highlighter-rouge">ModifyMeshPatch</code> using <code class="language-plaintext highlighter-rouge">AddNavigationDataToRegion()</code>, which we then use to add points to our NaviMesh by breaking our triangles into smaller <code class="language-plaintext highlighter-rouge">SplitTriangles</code>. Afterwards these points are connected by an edge that splits other edges through <code class="language-plaintext highlighter-rouge">SplitEdge()</code>. After adding all edges, we mark triangles with <code class="language-plaintext highlighter-rouge">MarkupMesh()</code>. We then apply the following <code class="language-plaintext highlighter-rouge">PathFlags</code> as necessary:</p>

<ul>
  <li>
    <p>Walk</p>
  </li>
  <li>
    <p>Fly</p>
  </li>
  <li>
    <p>Power</p>
  </li>
  <li>
    <p>Sight</p>
  </li>
  <li>
    <p>TallWalk</p>
  </li>
</ul>

<p>By knowing the coordinates of a point we can determine what triangle it is in, and this way the game understands whether you can walk, fly, use abilities, or aim in this point.</p>

<p>Here is an animation of how triangles are broken down for the <code class="language-plaintext highlighter-rouge">NPEAvengersTowerHUBRegion</code>:</p>

<center>
<a href="/MHServerEmu/assets/blog/progress-report/2024-03/triangulate.gif"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/triangulate.gif" alt="NaviMesh Generation" /></a>
<p>(Note: P=100 means that 100 NaviPoints were added to the NaviMesh.)</p>
</center>

<p>If we filter the triangles and show only those that contain the Walk PathFlag, we get an outline of the Avengers Tower:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-03/navimesh.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-03/navimesh.png" alt="Walkable Triangles" /></a></p>

<p>There is still a work to do with the NaviSystem. For example, it took me three days to find the cause of one of the issues. The system is complex, but it is the foundation of all physics in the game.</p>

<hr />

<p>This is all we have for you today. See you in a month!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: February 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: February 2024" /><published>2024-02-28T15:00:00+03:00</published><updated>2024-02-28T15:00:00+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/02/28/progress-report-february-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-02/header.jpg" alt="MHServerEmu Progress Report - February 2024" /></p>

<p>February may be the shortest month, but we are definitely not short on progress this time.</p>

<h2 id="the-merging-is-complete">The Merging is Complete</h2>

<p>The biggest news of the month is without doubt that the changes that AlexBond and Kawaikikinou have been implementing and testing on the experimental branch over the past few months have been merged with the master branch. The highlights of these changes include:</p>

<ul>
  <li>
    <p>Fully-featured implementation of DRAG (Dynamic Random Area Generator), which makes all regions not only explorable, but also different between visits. The current system refreshes regions every five minutes as long as there are no players in them, but this is something we will continue to iterate on.</p>
  </li>
  <li>
    <p>Early implementation of the population system, which handles the spawning of entities, including enemies, NPCs, and interactable objects, across the entire game. There is still a lot of work to be done here, including dynamic enemy spawning, but the regions now feel a lot less lonely.</p>
  </li>
  <li>
    <p>Early experiment that allows to deal damage to enemies. This is more of a quick hack than a real implementation, but it does make exploration way more fun.</p>
  </li>
</ul>

<p>This is an important milestone that brings us closer towards our first official “release”, 0.1.0, that we currently expect to happen in March. In addition to what you can see in the current nightly build, it is also going to have some more additional polish, including a streamlined setup process that would not require you to manually configure a web server.</p>

<p>Once that is out, the current plan is to shift our focus back towards fundamentals, including overhauling our entity management and replication systems.</p>

<p>With the important news out of the way, let us take a closer look at some of the more technical happenings of February.</p>

<h2 id="a-song-of-bits-and-bytes">A Song of Bits and Bytes</h2>

<p>What I have personally spent the most of my time working on this month is finally implementing one of the core systems of Marvel Heroes - properties.</p>

<p>All dynamic objects in the game are called <em>entities</em>. This includes player characters (internally called <em>avatars</em>), NPCs, enemies, projectiles, interactable objects, items, and so on. Entities are essentially collections of properties that define their state: what level they are, how much health they have, whether they are visible or not, and so on. Because of their integral role in pretty much all gameplay interactions, everything related to properties is very highly optimized, which makes it very difficult to untangle. If you include all the research and the foundational systems that had to be done beforehand, you could say that implementing properties actually took six months.</p>

<p>A property is a pair of two 64-bit values: a <em>PropertyId</em> and a <em>PropertyValue</em>. As you can probably guess from their names, one identifies a property, and the other contains its actual value.</p>

<p>The simplest form of a PropertyId looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-combatlevel.png" alt="Property Id - Combat Level" /></a></p>

<p>The game initializes the so-called property info table and enumerates all property types during startup. Most of the properties are defined in code and are sorted alphabetically by their name. However, there are some additional data-only properties that are sorted by their blueprint id and appended at the end of the enumeration. Overall in version 1.52.0.1700 there are 1030 properties, of which 29 are data-only.</p>

<p>11 of the 64 bits in a PropertyId are allocated to the enum value, so the maximum possible number of property types is <code class="language-plaintext highlighter-rouge">1 &lt;&lt; 11 = 2048</code>. The remaining 53 bits are distributed amongst 0-4 <em>parameters</em>. For example, this PropertyId for a <code class="language-plaintext highlighter-rouge">Waypoint</code> property contains a single parameter that specifies which waypoint this property unlocks:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-waypoint.png" alt="Property Id - Waypoint" /></a></p>

<p>There are three supported types of parameters: integers, prototype ids, and asset ids. However, there is a problem: prototype and asset ids are actually 64-bit hashes, so how are we supposed to fit multiple 64-bit values in the 53 bits we have for parameters? This is where trickery comes in.</p>

<p>During game database initialization the game sorts all 64-bit prototype ids it contains, and then divides them into two types of buckets: by C++ class they bind to, and by Calligraphy blueprint they use. So you end up with arrays of sorted ids for each prototype class and blueprint. And by knowing which array to look in and where, you can retrieve the full id. A similar process happens for assets, so by knowing the asset type and its index you can get the id.</p>

<p>The game databases server-side and client-side are in sync, and the game makes heavy use of this in network communication to reduce the amount of data that needs to be sent back and forth. Instead of sending a number like <code class="language-plaintext highlighter-rouge">421791326977791218</code>, which is the prototype id of the playable Iron Man avatar, you can send just <code class="language-plaintext highlighter-rouge">3</code>, which is the index in the array of prototypes that use the avatar blueprint.</p>

<p>Property types have corresponding prototypes that contain additional metadata, including the types and subtypes (prototype blueprint or asset type) of all parameters. During property info table initialization the game processes all property prototypes and allocates the 53-bit param budget to defined parameters. First, it allocates the amount of bits needed to store the maximum index value for all prototype and asset parameters, and then it splits the remaining bits amongst any integer parameters, up to 31 bits (so only positive integers with a value up of up to <code class="language-plaintext highlighter-rouge">2147483647</code>). For example, here is a PropertyId for an <code class="language-plaintext highlighter-rouge">AvatarLibraryLevel</code> property that defines the displayed level in the hero roster for Iron Man:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-avatarlibrarylevel.png" alt="Property Id - Avatar Library Level" /></a></p>

<p>7 bits are allocated to hold the maximum value of the avatar prototype index, and then 31 of the remaining 46 bits are taken by an integer value. 15 bits in this case are left unused.</p>

<p>Finally, here is an example of a <code class="language-plaintext highlighter-rouge">Proc</code> property that has four parameters:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/propertyid-proc.png" alt="Property Id - Proc" /></a></p>

<p>Param0 is the asset value that defines the proc trigger type, Param1 is the power prototype of the power triggered by this proc, and the remaining params are additional integer values. First <code class="language-plaintext highlighter-rouge">7 + 15 = 22</code> bits are allocated to asset and prototype params, and then the remaining bits are split evenly between integer params, <code class="language-plaintext highlighter-rouge">31 / 2 = 15</code> bits per parameter.</p>

<p>This is not where trickery ends however. Marvel Heroes makes heavy use of the encoding format developed by Google for their <a href="https://protobuf.dev/programming-guides/encoding/">Protocol Buffers</a> technology, and the way it works is that values can take anywhere from one to ten bytes depending on how high they are, with higher values taking more bytes. The number you end up with for a PropertyId often has a lot of zeroes at the end, so you waste a lot of network traffic if you send it as is. To circumvent this, the order of bytes is reversed before serialization: so <code class="language-plaintext highlighter-rouge">0x18E0000000000000</code> from the first example becomes <code class="language-plaintext highlighter-rouge">0x00000000000018E0</code>, or just <code class="language-plaintext highlighter-rouge">0x18E0</code>. However, there is an annoying inconsistency: when serializing a single property instead of a whole property collection, the game reverses the order of individual <em>bits</em> rather than <em>bytes</em>. So <code class="language-plaintext highlighter-rouge">0001 1000 1110 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code> becomes <code class="language-plaintext highlighter-rouge">0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 0001 1000</code>, or just <code class="language-plaintext highlighter-rouge">111 0001 1000</code>, which is equivalent to a hex value of <code class="language-plaintext highlighter-rouge">0x718</code>.</p>

<p>And then we have PropertyValue. Thankfully, this one is not nearly as complicated. There are eleven data types that can be stored in a property value, most of them are simple 64-bit integer or 32-bit floating point values. But there are two funny ones: <em>Curve</em> and <em>Int21Vector3</em>.</p>

<p>With a curve property rather than assigning it a value, you assign it an index property and a curve. And then the value of the curve property gets automatically updated from the curve, using the value of the index property as the curve index. For example, all heroes have a <code class="language-plaintext highlighter-rouge">HealthBase</code> property that uses <code class="language-plaintext highlighter-rouge">CombatLevel</code> as its index. So the value of <code class="language-plaintext highlighter-rouge">HealthBase</code> automatically changes whenever <code class="language-plaintext highlighter-rouge">CombatLevel</code> is updated (i.e. you level up). The default curve used by playable characters, <code class="language-plaintext highlighter-rouge">CharacterHealthMAX.curve</code>, actually goes all the way to level 101 and looks like this:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/healthbase-curve.png" alt="HealthBase Curve Property" /></a></p>

<p>With an Int21Vector3 we have a Vector3 to store, which consists of three 32-bit floating point values (X, Y, and Z coordinates), but we only have 64 bits. In this case the compression is lossy: individual values are rounded and cast to integers. The 64 bits are split into <code class="language-plaintext highlighter-rouge">64 / 3 = 21</code> bits per value. The values remain signed, so we end up with 20 magnitude bits + 1 sign bit, which gives us a range from <code class="language-plaintext highlighter-rouge">-1048576</code> to <code class="language-plaintext highlighter-rouge">1048575</code> for each coordinate.</p>

<p>One challenge with implementing PropertyValue has been adapting the original C++ API to C#. Property collections in the client use templates for property getters and setters that look something along these lines:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="o">=</span> <span class="n">properties</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">PropertyId</span><span class="p">(</span><span class="n">CharacterLevel</span><span class="p">));</span>
</code></pre></div></div>

<p>For the C# API we ended up with a combination of indexers and implicit casting that looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Getter</span>
<span class="kt">int</span> <span class="n">characterLevel</span> <span class="p">=</span> <span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">];</span>

<span class="c1">// Setter</span>
<span class="n">properties</span><span class="p">[</span><span class="n">PropertyEnum</span><span class="p">.</span><span class="n">CharacterLevel</span><span class="p">]</span> <span class="p">=</span> <span class="m">60</span><span class="p">;</span>
</code></pre></div></div>

<p>The final piece of the property puzzle is aggregation. A property collection can be attached as a child to another property collection, and the values of the parent are going to be aggregated with the child. Each property collection actually contains two lists of properties: one for base values held in this particular collection, and one for values aggregated with all of its children. This system is what enables, for example, equipping and unequipping items that affect your character’s stats, or applying buffs and debuffs (internally called <em>conditions</em>). There is not too much interesting to say about aggregation, it is just a lot of mundane work to make sure that all values are updated properly.</p>

<p>And with all of that we now have a working property system. We have already started making use of it to replace some of the hardcoded data from captured packets we had to rely on, as well as doing little experiments, like the recently implemented damage dealing hack. One remaining aspect that we are going to have to tackle on in the future is the eval system, which allows properties to be used as variables in scripted formulas (for example, for calculating maximum health taking into account all bonuses and penalties). But that is going to be a whole massive endeavor of its own.</p>

<h2 id="an-interesting-development">An Interesting Development</h2>

<p>As Alex was implemeting region generation and entity spawning, an issue immerged. Turns out loading an entire region worth of environments and entities puts a significant amount of strain on the client, especially if you are running on lower-end hardware. So we needed to come up with a solution, at least a temporary one.</p>

<p>The way this is supposed to be handled is through a process called replication. The server is the “dungeon master”, it is aware of everything happening to everyone, but each client should only be aware of what is relevant to them. Not only does it reduce the amount of data that needs to be exchanged and improve performance, it also helps prevent some forms of cheating, such as map hacking. If the client literally has no information on what lies ahead, it is much harder to peek beyond what should be observable (<del>there is actually a potential way around this, but I am not going to disclose it here</del>).</p>

<p>Internally the game calls the data that needs to be sent to clients their <em>interest</em>, with each client having their own <em>areas of interest</em> (AOI). There are at least five area of interest channels that we are currently aware of:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToProximity</code>: the client needs to know what is happening around its physical location in the game world.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToParty</code>: the client needs to be informed of its party members even if they are not in proximity.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>: some entities should be replicated only to their owners. For example, this is not Diablo II, so only you should be able to see the loot you get from defeating enemies.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToDiscovered</code>: when the client finds an NPC or a transition to another region, the client should still be somewhat aware of the entity, even if they are no longer in proximity with one another (a bit like fog of war in RTS games).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ReplicateToTrader</code>: when trading items the clients should be aware of what is being traded.</p>
  </li>
</ul>

<p>These channels can be mixed together, like <code class="language-plaintext highlighter-rouge">ReplicateToProximity</code> and <code class="language-plaintext highlighter-rouge">ReplicateToOwner</code>, so the client is aware only of the loot that belongs to it and is in proximity. We are still investigating how this system works, so some of these examples may not be completely accurate.</p>

<p>In the current version of MHServerEmu we now have an early implementation of proximity-based area of interest. This allows us to send cell and entity data as you move in the game world, reducing load times significantly. We also have some additional functionality not present in the original game for players running on ultrawide monitors and/or with a custom camera maximum distance: by typing <code class="language-plaintext highlighter-rouge">!player AOIVolume value</code> in chat you can customize the “draw distance” of entities that are considered to be in proximity.</p>

<p>Replication is a core part of any online game, because it is what keeps all clients synchronized with the game state happening on the server. We will most likely go more in-depth on this in future reports, once it is closer to being finished.</p>

<h2 id="live-tuning">Live Tuning</h2>

<p>One fun thing we were able to do this month is get the live tuning system up and running. This is a system that allowed the developers to do quick hotfixes without patching the game. While somewhat limited compared to changing game data directly, there are some interesting things you can do with it.</p>

<p>For instance, regions have the following live tuning “knobs” available to them:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">RegionTuningVar</span> <span class="p">{</span>
    <span class="na">eRTV_PlayerLimit</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">eRTV_Enabled</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">eRT_BonusXPPct</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">eRT_XPBuffDisplay</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">eRT_BonusItemFindMultiplier</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="na">eRTV_NumRegionTuningVars</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eRTV_Enabled</code> allows the server to disable individual regions. This is how, for example, the Mystic Mayhem in Limbo event is implemented: Limbo is a regular region that is disabled with live tuning unless the event is running. So by turning off this setting we can make Limbo accessible in-game.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-1.jpg" alt="Live Tuning - Limbo Waypoint" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-2.jpg" alt="Live Tuning - Limbo" /></a></p>

<p>Or we can go in the opposite direction and disable everything <em>but</em> Limbo. Feels like 2013 again!</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-limbo-3.jpg" alt="Live Tuning - Disable Regions" /></a></p>

<p>Another group of tuning parameters affects avatar entities:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">AvatarEntityTuningVar</span> <span class="p">{</span>
	<span class="na">eAETV_BonusXPPct</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="na">eAETV_XPBuffDisplay</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="na">eAETV_EternitySplinterPrice</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="na">eAETV_Enabled</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="na">eAETV_NumAvatarEntityTuningVars</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eAETV_Enabled</code> here works similarly to regions, allowing us to disable individual heroes. One possible use for this feature could be implementing an Infinity War themed event where half of the playable heroes would be picked randomly and disabled for the duration of the event.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg"><img src="/MHServerEmu/assets/blog/progress-report/2024-02/tuning-disable-avatar.jpg" alt="Live Tuning - Disable Avatars" /></a></p>

<p>All the tuning parameters are defined in the protocol and can be found <a href="https://github.com/Crypto137/MHServerEmu/blob/master/proto/CommonMessages.proto#L42">here</a>. You can experiment with them yourself by editing <code class="language-plaintext highlighter-rouge">LiveTuningData.json</code> located in <code class="language-plaintext highlighter-rouge">MHServerEmu\Data\Game\</code>.</p>

<hr />

<p>This is all we have to share today. Thank you very much for following the development of MHServerEmu. See you next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MHServerEmu Progress Report: January 2024</title><link href="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html" rel="alternate" type="text/html" title="MHServerEmu Progress Report: January 2024" /><published>2024-01-30T03:06:40+03:00</published><updated>2024-01-30T03:06:40+03:00</updated><id>https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024</id><content type="html" xml:base="https://crypto137.github.io/MHServerEmu/blog/2024/01/30/progress-report-january-2024.html"><![CDATA[<!--more-->

<p><img src="/MHServerEmu/assets/blog/progress-report/2024-01/header.jpg" alt="MHServerEmu Progress Report - January 2024" /></p>

<p>Hello there! The first month of 2024 is now almost behind us, and we have been hard at work on all things Marvel Heroes. Let us dive right in!</p>

<h2 id="calligraphyserializer-is-a-lie">CalligraphySerializer is a Lie</h2>

<p>Before continuing I strongly suggest you read the reports from <a href="/MHServerEmu/blog/2023/11/28/progress-report-november-2023.html">November 2023</a> and <a href="/MHServerEmu/blog/2023/12/25/progress-report-december-2023.html">December 2023</a> if you have not done so already. You have been warned.</p>

<p>Most of my time in January has been spent untangling the web that is the <code class="language-plaintext highlighter-rouge">CalligraphySerializer</code> class. And the fun begins right from the name: despite being called a “serializer”, it literally cannot serialize any data. It is used strictly for deserialization of Calligraphy prototypes. You literally cannot trust things to do what they say they do.</p>

<p>What it actually does can be summarized like this:</p>

<ol>
  <li>
    <p>It takes a blank prototype instance of a certain type as input.</p>
  </li>
  <li>
    <p>If the prototype references a parent prototype, the parent data is copied to the child. If the parent has not yet been loaded, it goes through the deserialization process itself, and this continues until all parents are loaded.</p>
  </li>
  <li>
    <p>All serialized Calligraphy field groups are processed. Regular field group have their fields matched to fields defined in the prototype class, its parents, and mixin fields, and then deserialized using the appropriate parser method. Property field groups represent individual properties and are used to reconstruct property collections.</p>
  </li>
  <li>
    <p>A prototype can have embedded prototypes, so this whole process is recursive.</p>
  </li>
</ol>

<p>As of right now, we have most of the regular field group processing working, but we still need to implement property collection reconstruction, as well as some small things here and there. Our overall current implementation progress is represented in the following diagram:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/calligraphy-serializer-wip.png" alt="CalligraphySerializer WIP" /></a></p>

<p>One of the biggest challenges I have had to deal with implementing this has been matching serialized fields to appropriate class fields. The client uses a custom <a href="https://en.wikipedia.org/wiki/Run-time_type_information">run-time type information</a> system for this called GRTTI. While it should be technically possible to reimplement GRTTI, it would also be somewhat like reinventing the wheel when our server emulator is written in C#, which already has very strong reflection capabilities that can be used to get a very similar result.</p>

<p>C# reflection has its drawbacks though: while extremely flexible, it is notoriously slow, and when you have to use it literally hundreds of thousands of times, it really adds up. In one of our unoptimized testing cases it took over 80 seconds to load all prototypes, while the original game did it in 3. In the end, with some targeted result caching, I have been able to get it to a pretty reasonable time of about 12 seconds, which should be more than good enough for our current needs. There is always more room for more optimization, but that is going to come later on. It should also be noted that all of this is a one-time cost during server startup, and if you do not have prototype frontloading enabled, you are most likely not going to notice this at all.</p>

<p>Another big issue that has come up has been taking care of mixins. While most embedded prototypes can be handled with recursion, there are some very specific cases where you have so-called mixin prototypes that need to be deserialized as if they were a part of the prototype itself. Their field groups are mixed with regular field groups (which is where I am guessing the name is coming from), and there are cases where you have entire collections of mixin prototypes. There is a significant amount of extra code that handles mixins specifically, and they are used in literally only three prototypes classes (out of over a thousand) in the entire game: <code class="language-plaintext highlighter-rouge">LocomotorPrototype</code> and <code class="language-plaintext highlighter-rouge">PopulationInfoPrototype</code> in <code class="language-plaintext highlighter-rouge">AgentPrototype</code>, <code class="language-plaintext highlighter-rouge">ProductPrototype</code> in <code class="language-plaintext highlighter-rouge">ItemPrototype</code>, and lists of <code class="language-plaintext highlighter-rouge">ConditionPrototype</code> and <code class="language-plaintext highlighter-rouge">ConditionEffectPrototype</code> in <code class="language-plaintext highlighter-rouge">PowerPrototype</code>. So in the case of list mixins there is literally a single prototype class that this entire subsystem exists for.</p>

<p>While there has been very good progress, the work on CalligraphySerializer is still not done. It is now possible to access a lot of the game data from code and use it in features like region generation, but there are still some aspects of mixin fields that need to be finished, as well as the property system, which is tightly tangled with the entire game.</p>

<h2 id="pipeline-improvements">Pipeline Improvements</h2>

<p>Another thing I have been able to work on this month is some general improvements to our delivery pipeline.</p>

<p>First of all, MHServerEmu now clearly states its version, build time, and build configuration:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/versioning.png" alt="MHServerEmu Versioning" /></a></p>

<p>This is a pretty minor change, but it is going to make it much easier to figure out and solve issues as they arise.</p>

<p>Also, we now have automated nightly builds powered by GitHub actions and <a href="https://nightly.link/">nightly.link</a>. Thanks to that, if you want to try MHServerEmu out, instead of building the source code yourself, you can just download the latest build <a href="https://nightly.link/Crypto137/MHServerEmu/workflows/nightly-release-windows-x64/master?preview">here</a>. Those builds are based on the the latest <code class="language-plaintext highlighter-rouge">master</code> branch code, and are in general a decent representation of our current progress.</p>

<p>These small steps bring us closer towards a big milestone, which would be our first official binary release, tentatively numbered 0.1.0. We are going to talk more about that in the future.</p>

<h2 id="here-comes-a-new-challenger">Here Comes a New Challenger!</h2>

<p>This month our development team has expanded by 50%: <strong>Kawaikikinou</strong> has joined me (Crypto137) and AlexBond in restoring Marvel Heroes back to its glory.</p>

<p>MHServerEmu is a very complex project that involves many moving parts, so some time had to be spent to bring our new team member up to speed with what we are working on, but there are already some results that can be seen. So far Kawaikikinou has been mostly helping AlexBond with ironing out issues with region generation (more on that later), as well as improving the reliability of our code by introducing unit testing.</p>

<p>Another thing I am personally very excited about is <a href="https://github.com/Kawaikikinou/MHLogHelper">the new region visualization tool</a> he developed. Knowing is half the battle, and getting a better visual idea of what exactly is going on on the backend is going to be very helpful in the long run.</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-1.png" alt="MHLogHelper Screenshot 1" /></a></p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/mhloghelper-2.png" alt="MHLogHelper Screenshot 2" /></a></p>

<h2 id="the-joy-of-region-generation-with-alexbond">The Joy of Region Generation with AlexBond</h2>

<p>This time I am joined by a co-writer: in this section AlexBond is going to go in-depth on what is happening behind the scenes with region generation.</p>

<hr />

<p>Hello everyone. I am AlexBond, and I am working on reimplementing the region generation. We are lucky to have the region generation code ifself present in the client, but it is disabled. Most likely it was among common game files, which is why it ended up in the client, or maybe the developers had the option to enable it for testing. In any case, in two months I was able to reimplement the region generation in C#.</p>

<p>Of course, I am not without faults, so we ended up with a number of bugs. So this month me and <strong>Kawaikikinou</strong> have been testing this new code and fixing all the issues. As of the time of writing, we have tested regions up to chapter 3, and it is also possible to load into other chapters with some workarounds. Our goal is to get an exact copy of a region generated by the client when it has generation enabled. We do the comparisons using logs and the IDA debugger. Over the course of testing I was able to get a slightly better understanding of the generation process, I would like to share with you what I have discovered.</p>

<h3 id="region-prototype">Region Prototype</h3>

<p>A region prototype contains information about the type of generator a region uses. There are three region generators in total, but for now we are going to take a look at the most complicated and interesting one - <code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code>.</p>

<p><code class="language-plaintext highlighter-rouge">SequenceRegionGenerator</code> is a generator that describes a tree of <em>areas</em>, and this tree contains all possible variations with weights for each one. Branches of this tree contain area prototypes. Overall this can be represented as a kind of a chain sequence:</p>

<center>Area 1 - Area 2 - Area 3 - an so on</center>

<p>The <code class="language-plaintext highlighter-rouge">ProcessSequence()</code> function runs recursively through the tree of areas. During its run it uses a random seed to determine sequences (<code class="language-plaintext highlighter-rouge">PickSequence()</code>), areas (<code class="language-plaintext highlighter-rouge">PickArea()</code>), their positions and connections to other areas (<code class="language-plaintext highlighter-rouge">PickAreaPlacement()</code>), and in the end it runs the generator of the current area. This recursion goes through the entire tree from the end to the beginning.</p>

<p>For example, in Madripoor it goes like this:</p>

<center>LowTown -&gt; Cove -&gt; BambooForest -&gt; Beach</center>

<p>If an area generator runs into an error, all previous areas are destroyed and rebuilt until the error disappears. To prevent infinite rebuilds, there is a special parameter called <code class="language-plaintext highlighter-rouge">MaxGenerationTimeInSec</code>, but currently I am not using it (perhaps I should).</p>

<h3 id="area-prototype">Area Prototype</h3>

<p>An area prototype defines the type of generator and the cell generation rules. In total there are seven different area generators, but I would like to talk about the most commonly used ones - <code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> and <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> (<code class="language-plaintext highlighter-rouge">GridAreaGenerator</code>).</p>

<h4 id="cellgridgenerator">CellGridGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">CellGridGenerator</code> is a rectangle of cells, and the size of this rectangle is defined in the area prototype.</p>

<p>The generation process includes ten attempts of creating an arrangement of cells that adheres to certain requirements. Now I am going to describe creation functions.</p>

<p><code class="language-plaintext highlighter-rouge">InitializeContainer()</code> - creates a <code class="language-plaintext highlighter-rouge">CellContainer</code> with a size of <code class="language-plaintext highlighter-rouge">CellsX</code> by <code class="language-plaintext highlighter-rouge">CellsY</code>. This is just a rectangle for holding cells that are going to be added.</p>

<p><code class="language-plaintext highlighter-rouge">EstablishExternalConnections()</code> - defines which sides are going to have cells for connecting to adjacent areas.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRandomInstanceLinks()</code> - defines connections to various <code class="language-plaintext highlighter-rouge">RandomInstances</code> (not all regions contain those).</p>

<p><code class="language-plaintext highlighter-rouge">CreateRequiredCells()</code> - defines groups of cells to be placed:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredSuperCells</code> - places consisting of multiple cells (mostly 2x2), like the Fall Tribe village in Savage Land, or buildings.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredSuperCells</code> - this type is used only in the <code class="language-plaintext highlighter-rouge">MutateMarshArea</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RegionTransitionSpec</code> - these are mostly places for waypoints and entrances to various treasure rooms. These places are determined using teleports contained in <code class="language-plaintext highlighter-rouge">RegionConnectionNodePrototype</code> that exit to this region.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RandomInstances</code> - a list of random places, these are not in the game…</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredCells</code> - these are special places that must be present in an area, like shops or cafes (e.g. <code class="language-plaintext highlighter-rouge">Madripoor_Lower_BobaTeaPOI_A</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RequiredPOICells</code> - cells from <code class="language-plaintext highlighter-rouge">POIGroups</code>, I cannot say for sure what they are (they appear in <code class="language-plaintext highlighter-rouge">Wakanda</code>, <code class="language-plaintext highlighter-rouge">DangerRooms</code>, <code class="language-plaintext highlighter-rouge">CowRegion</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NonRequiredNormalCells</code> - another group of cells, used in <code class="language-plaintext highlighter-rouge">HellsKitchen</code> (<code class="language-plaintext highlighter-rouge">Brownstone_C_Barricade_ESW_A</code>).</p>
  </li>
</ul>

<p>Now we have a filled <code class="language-plaintext highlighter-rouge">CellContainer</code> with a number <code class="language-plaintext highlighter-rouge">CellRefs</code>, and if it is successful we can move onto destroying and adding cells to the current area.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousCells()</code> - this process uses <code class="language-plaintext highlighter-rouge">RoomKillChancePct</code> to determine the number of cells that need to be destroyed using the <code class="language-plaintext highlighter-rouge">RoomKillMethod</code>. There are three deletion methods - Random, Edge, and Corner. When deleting cells there are checks for paths between imporant points, and only the cells that can be safely removed without breaking those paths are removed.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessDeleteExtraneousConnections()</code> - removes redundant connections between cells using <code class="language-plaintext highlighter-rouge">ConnectionKillChancePct</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> - the main function that randomly picks cells for creation. If a cell has not been previously defined, it is going to be picked from the appropriate <code class="language-plaintext highlighter-rouge">CellSet</code> based on cell type.</p>

<p>At this point <code class="language-plaintext highlighter-rouge">CellGridGenerator</code> either succeeds or fails. If it fails, all areas are destroyed and regenerated.</p>

<h4 id="widegridareagenerator">WideGridAreaGenerator</h4>

<p><code class="language-plaintext highlighter-rouge">WideGridAreaGenerator</code> differs by having <code class="language-plaintext highlighter-rouge">GenerateRoads()</code> and <code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code>, as well as a different implementation of <code class="language-plaintext highlighter-rouge">ProcessCellTypes()</code> that picks cells based not on their type, but <code class="language-plaintext highlighter-rouge">RequiredWalls</code>.</p>

<p><code class="language-plaintext highlighter-rouge">GenerateRoads()</code> - defined by the Roads prototype in the generator. This function uses the <code class="language-plaintext highlighter-rouge">DijkstraRoad()</code> method based on the <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> for finding the shortest path between nodes.</p>

<p><code class="language-plaintext highlighter-rouge">CreateProceduralSuperCells()</code> - if the <code class="language-plaintext highlighter-rouge">ProceduralSuperCells</code> field contains data, it creates a random set for a 2x2 square and rotates it randomly.</p>

<p>Here is an example of generation for <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaA</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 4<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Corner</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>X</td><td>X</td><td></td><td>X</td></tr><tr><td>B</td><td></td><td></td><td>A</td></tr></table></div>
</div>

<p>As we can see, in this case the path from A to B is preserved, and 60% of the cells were removed using the corner method.</p>

<p>This is what we get in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-1.png" alt="Region Generation Example 1" /></a></p>

<p>Now let us take a look at the next area, <code class="language-plaintext highlighter-rouge">CH0204Q36AIMLabAreaC</code>:</p>

<div style="display: flex;">
<div style="flex: 1;">CellsX = 3<br />CellsY = 3<br />RoomKillChancePct = 60<br />ConnectionKillChancePct = 15<br />RoomKillMethod = Random</div>
<div><table style="margin-bottom: 0px;"><tr><td>X</td><td></td><td>B</td></tr><tr><td>C</td><td></td><td>X</td></tr><tr><td>X</td><td>X</td><td>X</td></tr></table></div>
</div>

<p>As we can see, in this case the path from B to C is preserved and 60% of the cells were removed using the random method.</p>

<p>And here is what it looks like in-game:</p>

<p><a href="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png"><img src="/MHServerEmu/assets/blog/progress-report/2024-01/region-generation-2.png" alt="Region Generation Example 2" /></a></p>

<p>Hopefully now it should be more clear how all of this functions.</p>

<p>As for my work, recently I have merged the new prototype system written by Crypto137, and now the testing of generation is much faster, and it is going to be easier to merge with the main repository. But we still have a lot of tests to do, so please be patient.</p>

<hr />

<p>Back to Crypto to wrap things up. We are getting very close to finally reaping the fruits of our efforts over the past few months, and hopefully we will be able to deliver results that are more visible in-game soon enough. We are just as excited as you are to finally see some things come together. Until next time!</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry></feed>